<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensors and the TensorMap type ¬∑ TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li class="is-active"><a class="tocitem" href>Tensors and the <code>TensorMap</code> type</a><ul class="internal"><li><a class="tocitem" href="#Storage-of-tensor-data-1"><span>Storage of tensor data</span></a></li><li><a class="tocitem" href="#Constructing-tensor-maps-and-accessing-tensor-data-1"><span>Constructing tensor maps and accessing tensor data</span></a></li><li><a class="tocitem" href="#Vector-space-and-linear-algebra-operations-1"><span>Vector space and linear algebra operations</span></a></li><li><a class="tocitem" href="#Tensor-factorizations-1"><span>Tensor factorizations</span></a></li><li><a class="tocitem" href="#Index-manipulations-1"><span>Index manipulations</span></a></li><li><a class="tocitem" href="#Tensor-contractions-and-tensor-networks-1"><span>Tensor contractions and tensor networks</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/spaces/">Vector spaces, symmetry sectors an fusion trees</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tensors and the <code>TensorMap</code> type</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tensors and the <code>TensorMap</code> type</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/tensors.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_tensors-1"><a class="docs-heading-anchor" href="#s_tensors-1">Tensors and the <code>TensorMap</code> type</a><a class="docs-heading-anchor-permalink" href="#s_tensors-1" title="Permalink"></a></h1><p>This last page explains how to create and manipulate tensors in TensorKit.jl. As this is probably the most important part of the manual, we will also focus more strongly on the usage and interface, and less so on the underlying implementation. The only aspect of the implementation that we will address is the storage of the tensor data, as this is important to know how to create and initialize a tensor, but will in fact also shed light on how some of the methods work.</p><p>As mentioned, all tensors in TensorKit.jl are interpreted as linear maps (morphisms) from a domain (a <code>ProductSpace{S,N‚ÇÇ}</code>) to a domain (another <code>ProductSpace{S,N‚ÇÅ}</code>), with the same <code>S&lt;:ElementarySpace</code> that labels the type of spaces associated with the individual tensor indices. The overall type for all such tensor maps is <code>AbstractTensorMap{S, N‚ÇÅ, N‚ÇÇ}</code>. Note that we place information about the codomain before that of the domain. Indeed, we have already encountered the constructor for the concrete parametric type <code>TensorMap</code> in the form <code>TensorMap(..., codomain, domain)</code>. This convention is opposite to the mathematical notation, e.g. <span>$\mathrm{Hom}(W,V)$</span> or <span>$f:W‚ÜíV$</span>, but originates from the fact that a normal matrix is also denoted as having size <code>m √ó n</code> or is constructed in Julia as <code>Array(..., (m, n))</code>, where the first integer <code>m</code> refers to the codomain being <code>m</code>- dimensional, and the seond integer <code>n</code> to the domain being <code>n</code>-dimensional. This also explains why we have consistently used the symbol <span>$W$</span> for spaces in the domain and <span>$V$</span> for spaces in the codomain. A tensor map <span>$t:(W‚ÇÅ ‚äó ‚Ä¶ ‚äó W_{N‚ÇÇ}) ‚Üí (V‚ÇÅ ‚äó ‚Ä¶ ‚äó V_{N‚ÇÅ})$</span> will be created in Julia as <code>TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W1 ‚äó ... ‚äó WN2)</code>.</p><p>Furthermore, the abstract type <code>AbstractTensor{S,N}</code> is just a synonym for <code>AbstractTensorMap{S,N,0}</code>, i.e. for tensor maps with an empty domain, which is equivalent to the unit of the monoidal category, or thus, the field of scalars <span>$ùïú$</span>.</p><p>Currently, <code>AbstractTensorMap</code> has two subtypes. <code>TensorMap</code> provides the actual implementation, where the data of the tensor is stored in a <code>DenseArray</code> (more specifically a <code>DenseMatrix</code> as will be explained below). <code>AdjointTensorMap</code> is a simple wrapper type to denote the adjoint of an existing <code>TensorMap</code> object. In the future, additional types could be defined, to deal with sparse data, static data, diagonal data, etc...</p><h2 id="Storage-of-tensor-data-1"><a class="docs-heading-anchor" href="#Storage-of-tensor-data-1">Storage of tensor data</a><a class="docs-heading-anchor-permalink" href="#Storage-of-tensor-data-1" title="Permalink"></a></h2><p>Before discussion how to construct and initalize a <code>TensorMap{S}</code>, let us discuss what is meant by &#39;tensor data&#39; and how it can efficiently and compactly be stored. Let us first discuss the case <code>sectortype(S) == Trivial</code> sector, i.e. the case of no symmetries. In that case the data of a tensor <code>t = TensorMap(..., V1 ‚äó ... ‚äó VN‚ÇÅ, W1 ‚äó ... ‚äó WN2)</code> can just be represented as a multidimensional array of size</p><p><code>(dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ))</code></p><p>which can also be reshaped into matrix of size</p><p><code>(dim(V1)*dim(V2)*‚Ä¶*dim(VN‚ÇÅ), dim(W1)*dim(W2)*‚Ä¶*dim(WN‚ÇÇ))</code></p><p>and is really the matrix representation of the linear map that the tensor represents. In particular, given a second tensor <code>t2</code> whose domain matches with the codomain of <code>t</code>, function composition amounts to multiplication of their corresponding data matrices. Similarly, tensor factorizations such as the singular value decomposition, which we discuss below, can act directly on this matrix representation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>One might wonder if it would not have been more natural to represent the tensor data as <code>(dim(V1), dim(V2), ‚Ä¶, dim(VN‚ÇÅ), dim(WN‚ÇÇ), ‚Ä¶, dim(W1))</code> given how employing the duality naturally reverses the tensor product, as encountered with the interface of <a href="man/@ref"><code>repartition</code></a> for <a href="../sectors/#ss_fusiontrees-1">fusion trees</a>. However, such a representation, when plainly <code>reshape</code>d to a matrix, would not have the above properties and would thus not constitute the matrix representation of the tensor in a compatible basis.</p></div></div><p>Now consider the case where <code>sectortype(S) == G</code> for some <code>G</code> which has <code>FusionStyle(G) == Abelian()</code>, i.e. the representations of an Abelian group, e.g. <code>G == ‚Ñ§‚ÇÇ</code> or <code>G == U‚ÇÅ</code>. In this case, the tensor data is associated with sectors <code>(a1, a2, ‚Ä¶, aN‚ÇÅ) ‚àà sectors(V1 ‚äó V2 ‚äó ‚Ä¶ ‚äó VN‚ÇÅ)</code> and <code>(b1, ‚Ä¶, bN‚ÇÇ) ‚àà sectors(W1 ‚äó ‚Ä¶ ‚äó WN‚ÇÇ)</code> such that they fuse to a same common charge, i.e. <code>(c = first(‚äó(a1, ‚Ä¶, aN‚ÇÅ))) == first(‚äó(b1, ‚Ä¶, bN‚ÇÇ))</code>. The data associated with this takes the form of a multidimensional array with size <code>(dim(V1, a1), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ))</code>, or equivalently, a matrix of with row size <code>dim(V1, a1)*‚Ä¶*dim(VN‚ÇÅ, aN‚ÇÅ) == dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ))</code> and column size <code>dim(W1, b1)*‚Ä¶*dim(WN‚ÇÇ, aN‚ÇÇ) == dim(domain, (b1, ‚Ä¶, bN‚ÇÇ))</code>.</p><p>However, there are multiple combinations of <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> giving rise to the same <code>c</code>, and so there is data associated with all of these, as well as all possible combinations of <code>(b1, ‚Ä¶, bN‚ÇÇ)</code>. Stacking all matrices for different <code>(a1,‚Ä¶)</code> and a fixed value of <code>(b1,‚Ä¶)</code> underneath each other, and for fixed value of <code>(a1,‚Ä¶)</code> and different values of <code>(b1,‚Ä¶)</code> next to each other, gives rise to a larger block matrix of all data associated with the central sector <code>c</code>. The size of this matrix is exactly <code>(blockdim(codomain, c), blockdim(domain, c))</code> and these matrices are exactly the diagonal blocks whose existence is guaranteed by Schur&#39;s lemma, and which are labeled by the coupled sector <code>c</code>. Indeed, if we would represent the tensor map <code>t</code> as a matrix without explicitly using the symmetries, we could reorder the rows and columns to group data corresponding to sectors that fuse to the same <code>c</code>, and the resulting block diagonal representation would emerge. This basis transform is thus a permutation, which is a unitary operation, that will cancel or go through trivially for linear algebra operations such as composing tensor maps (matrix multiplication) or tensor factorizations such as a singular value decomposition. For such linear algebra operations, we can thus directly act on these large matrices, which correspond to the diagonal blocks that emerge after a basis transform, provided that the partition of the tensor indices in domain and codomain of the tensor are in line with our needs. For example, composing two tensor maps amounts to multiplying the matrices corresponding to the same <code>c</code> (provided that its subblocks labeled by the different combinations of sectors are ordered in the same way, which we guarantee by associating a canonical order with sectors). Henceforth, we refer to the <code>blocks</code> of a tensor map as those diagonal blocks, the existence of which is provided by Schur&#39;s lemma and which are labeled by the coupled sectors <code>c</code>. We directly store these blocks as <code>DenseMatrix</code> and gather them as values in a dictionary, together with the corresponding coupled sector <code>c</code> as key. For a given tensor <code>t</code>, we can access a specific block as <code>block(t, c)</code>, whereas <code>blocks(t)</code> yields an iterator over pairs <code>c=&gt;block(t,c)</code>.</p><p>The subblocks corresponding to a particular combination of sectors then correspond to a particular view for some range of the rows and some range of the colums, i.e. <code>view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ)</code> where the ranges <code>m‚ÇÅ:m‚ÇÇ</code> associated with <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> and <code>n‚ÇÅ:n‚ÇÇ</code> associated with <code>(b‚ÇÅ, ‚Ä¶, bN‚ÇÇ)</code> are stored within the fields of the instance <code>t</code> of type <code>TensorMap</code>. This <code>view</code> can then lazily be reshaped to a multidimensional array, for which we rely on the package <a href="https://github.com/Jutho/Strided.jl">Strided.jl</a>. Indeed, the data in this <code>view</code> is not contiguous, because the stride between the different columns is larger than the length of the columns. Nonetheless, this does not pose a problem and even as multidimensional array there is still a definite stride associated with each dimension.</p><p>When <code>FusionStyle(G) isa NonAbelian</code>, things become slightly more complicated. Not only do <code>(a1, ‚Ä¶, aN‚ÇÅ)</code> give rise to different coupled sectors <code>c</code>, there can be multiply ways in which they fuse to <code>c</code>. These different possibilities are enumerated by the iterator <code>fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> and <code>fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c)</code>, and with each of those, there is tensor data that takes the form of a multidimensional array, or, after reshaping, a matrix of size <code>(dim(codomain, (a1, ‚Ä¶, aN‚ÇÅ)), dim(domain, (b1, ‚Ä¶, bN‚ÇÇ))))</code>. Again, we can stack all such matrices with the same value of <code>f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> horizontally (as they all have the same number of rows), and with the same value of <code>f‚ÇÇ ‚àà fusiontrees((b1, ‚Ä¶, bN‚ÇÇ), c)</code> vertically (as they have the same number of columns). What emerges is a large matrix of size <code>(blockdim(codomain, c), blockdim(domain, c))</code> containing all the tensor data associated with the coupled sector <code>c</code>, where <code>blockdim(P, c) = sum(dim(P, s)*length(fusiontrees(s, c)) for s in sectors(P))</code> for some instance <code>P</code> of <code>ProductSpace</code>. The tensor implementation does not distinguish between abelian or non-abelian sectors and still stores these matrices as a <code>DenseMatrix</code>, accessible via <code>block(t, c)</code>.</p><p>At first sight, it might now be less clear what the relevance of this block is in relation to the full matrix representation of the tensor map, where the symmetry is not exploited. The essential interpretation is still the same. Schur&#39;s lemma now tells that there is a unitary basis transform which makes this matrix representation block diagonal, more specifically, of the form <span>$‚®Å_{c} B_c ‚äó ùüô_{c}$</span>, where <span>$B_c$</span> denotes <code>block(t,c)</code> and <span>$ùüô_{c}$</span> is an identity matrix of size <code>(dim(c), dim(c))</code>. The reason for this extra identity is that the group representation is recoupled to act as <span>$‚®Å_{c} ùüô ‚äó u_c(g)$</span> for all <span>$g ‚àà \mathsf{G}$</span>, with <span>$u_c(g)$</span> the matrix representation of group element <span>$g$</span> according to the irrep <span>$c$</span>. In the abelian case, <code>dim(c) == 1</code>, i.e. all irreducible representations are one-dimensional and Schur&#39;s lemma only dictates that all off-diagonal blocks are zero. However, in this case the basis transform to the block diagonal representation is not simply a permutation matrix, but a more general unitary matrix composed of the different fusion trees. Indeed, let us denote the fusion trees <code>f‚ÇÅ ‚àà fusiontrees((a1, ‚Ä¶, aN‚ÇÅ), c)</code> as <span>$X^{a_1, ‚Ä¶, a_{N‚ÇÅ}}_{c,Œ±}$</span> where <span>$Œ± = (e_1, ‚Ä¶, e_{N_1-2}; Œº‚ÇÅ, ‚Ä¶, Œº_{N_1-1})$</span> is a collective label for the internal sectors <code>e</code> and the vertex degeneracy labels <code>Œº</code> of a generic fusion tree, as discussed in the <a href="../sectors/#ss_fusiontrees-1">corresponding section</a>. The tensor is then represented as</p><p><img src="../img/tensor-storage.svg" alt="tensor storage"/></p><p>In this diagram, we have indicated how the tensor map can be rewritten in terms of a block diagonal matrix with a unitary matrix on its left and another unitary matrix (if domain and codomain are different) on its right. So the left and right matrices should actually have been drawn as squares. They represent the unitary basis transform. In this picture, red and white regions are zero. The center matrix is most easy to interpret. It is the block diagonal matrix <span>$‚®Å_{c} B_c ‚äó ùüô_{c}$</span> with diagonal blocks labeled by the coupled charge <code>c</code>, in this case it takes two values. Every single small square in between the dotted or dashed lines has size <span>$d_c √ó d_c$</span> and corresponds to a single element of <span>$B_c$</span>, tensored with the identity <span>$\mathrm{id}_c$</span>. Instead of <span>$B_c$</span>, a more accurate labelling is <span>$t^c_{(a_1 ‚Ä¶ a_{N‚ÇÅ})Œ±, (b_1 ‚Ä¶ b_{N‚ÇÇ})Œ≤}$</span> where <span>$Œ±$</span> labels different fusion trees from <span>$(a_1 ‚Ä¶ a_{N‚ÇÅ})$</span> to <span>$c$</span>. The dashed horizontal lines indicate regions corresponding to different fusion (actually splitting) trees, either because of different sectors <span>$(a_1 ‚Ä¶ a_{N‚ÇÅ})$</span> or different labels <span>$Œ±$</span> within the same sector. Similarly, the dashed vertical lines define the border between regions of different fusion trees from the domain to <code>c</code>, either because of different sectors <span>$(b_1 ‚Ä¶ b_{N‚ÇÇ})$</span> or a different label <span>$Œ≤$</span>.</p><p>To understand this better, we need to understand the basis transform, e.g. on the left (codomain) side. In more detail, it is given by</p><p><img src="../img/tensor-unitary.svg" alt="tensor unitary"/></p><p>Indeed, remembering that <span>$V_i = ‚®Å_{a_i} R_{a_i} ‚äó ‚ÑÇ^{n_{a_i}}$</span> with <span>$R_{a_i}$</span> the representation space on which irrep <span>$a_i$</span> acts (with dimension <span>$\mathrm{dim}(a_i)$</span>), we find <span>$V_1 ‚äó ‚Ä¶ ‚äó V_{N_1} = ‚®Å_{a_1, ‚Ä¶, a_{N‚ÇÅ}} (R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}}) ‚äó ‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>. In the diagram above, the wiggly lines correspond to the direct sum over the different sectors <span>$(a_1, ‚Ä¶, a_{N‚ÇÅ})$</span>, there depicted taking three possible values <span>$(a‚Ä¶)$</span>, <span>$(a‚Ä¶)‚Ä≤$</span> and <span>$(a‚Ä¶)‚Ä≤‚Ä≤$</span>. The tensor product <span>$(R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}}) ‚äó ‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span> is depicted as <span>$(R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}})^{‚äï n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>, i.e. as a direct sum of the spaces <span>$R_{(a‚Ä¶)} = (R_{a_1} ‚äó ‚Ä¶ ‚äó R_{a_{N_1}})$</span> according to the dotted horizontal lines, which repeat <span>$n_{(a‚Ä¶)} = n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}$</span> times. In this particular example, <span>$n_{(a‚Ä¶)}=2$</span>, <span>$n_{(a‚Ä¶)&#39;}=3$</span> and <span>$n_{(a‚Ä¶)&#39;&#39;}=5$</span>. The thick vertical line represents the separation between the two different coupled sectors, denoted as <span>$c$</span> and <span>$c&#39;$</span>. Dashed vertical lines represent different ways of reaching the coupled sector, corresponding to different <code>Œ±</code>. In this example, the first sector <span>$(a‚Ä¶)$</span> has one fusion tree to <span>$c$</span>, labeled by <span>$c,Œ±$</span>, and two fusion trees to <span>$c&#39;$</span>, labeled by <span>$c&#39;,Œ±$</span> and <span>$c&#39;,Œ±&#39;$</span>. The second sector has only a fusion tree to <span>$c$</span>, labeled by <span>$c,Œ±&#39;$</span>. The third sector only has a fusion tree to <span>$c&#39;$</span>, labeld by <span>$c&#39;, Œ±&#39;&#39;$</span>. Finally then, because the fusion trees do not act on the spaces <span>$‚ÑÇ^{n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}}$</span>, the dotted lines which represent the different <span>$n_{(a‚Ä¶)} = n_{a_1} √ó ‚Ä¶ n_{a_{N_1}}$</span> dimensions are also drawn vertically. In particular, for a given sector <span>$(a‚Ä¶)$</span> and a specific fusion tree <span>$X^{(a‚Ä¶)}_{c,Œ±}: R_{(a‚Ä¶)}‚ÜíR_c$</span>, the action is <span>$X^{(a‚Ä¶)}_{c,Œ±} ‚äó ùüô_{n_{(a‚Ä¶)}}$</span>, which corresponds to the diagonal green blocks in this drawing where the same matrix <span>$X^{(a‚Ä¶)}_{c,Œ±}$</span> (the fusion tree) is repeated along the diagonal. Note that the fusion tree is not a vector or single column, but a matrix with number of rows equal to <span>$\mathrm{dim}(R_{(a\ldots)}) = d_{a_1} d_{a_2} ‚Ä¶ d_{a_{N_1}}$</span> and number of columns equal to <span>$d_c$</span>. A similar interpretation can be given to the basis transform on the right, by taking its adjoint. In this particular example, it has two different combinations of sectors <span>$(b‚Ä¶)$</span> and <span>$(b‚Ä¶)&#39;$</span>, where both have a single fusion tree to <span>$c$</span> as well as to <span>$c&#39;$</span>, and <span>$n_{(b‚Ä¶)}=2$</span>, <span>$n_{(b‚Ä¶)&#39;}=3$</span>.</p><p>Note that we never explicitly store or act with the basis transforms on the left and the right. For composing tensor maps (i.e. multiplying them), these basis transforms just cancel, whereas for tensor factorizations they just go through trivially. They transform non-trivially when reshuffling the tensor indices, both within or in between the domain and codomain. For this, however, we can completely rely on the manipulations of fusion trees to implicitly compute the effect of the basis transform and construct the new blocks <span>$B_c$</span> that result with respect to the new basis.</p><p>Hence, as before, we only store the diagonal blocks <span>$B_c$</span> of size <code>(blockdim(codomain(t), c), blockdim(domain(t), c))</code> as a <code>DenseMatrix</code>, accessible via <code>block(t, c)</code>. Within this matrix, there are regions of the form <code>view(block(t, c), m‚ÇÅ:m‚ÇÇ, n‚ÇÅ:n‚ÇÇ)</code> that correspond to the data <span>$t^c_{(a_1 ‚Ä¶ a_{N‚ÇÅ})Œ±, (b_1 ‚Ä¶ b_{N‚ÇÇ})Œ≤}$</span> associated with a pair of fusion trees <span>$X^{(a_1 ‚Ä¶ a_{N‚ÇÅ}}_{c,Œ±}$</span> and <span>$X^{(b_1 ‚Ä¶ b_{N‚ÇÇ})}_{c,Œ≤}$</span>, henceforth again denoted as <code>f‚ÇÅ</code> and <code>f‚ÇÇ</code>, with <code>f‚ÇÅ.coupled == f‚ÇÇ.coupled == c</code>. The ranges where this subblock is living are managed within the tensor implementation, and these subblocks can be accessed via <code>t[f‚ÇÅ,f‚ÇÇ]</code>, and is returned as a <code>StridedArray</code> of size <span>$n_{a_1} √ó n_{a_2} √ó ‚Ä¶ √ó n_{a_{N_1}} √ó n_{b_1} √ó ‚Ä¶ n_{b_{N‚ÇÇ}}$</span>, or in code, <code>(dim(V1, a1), dim(V2, a2), ‚Ä¶, dim(VN‚ÇÅ, aN‚ÇÅ), dim(W1, b1), ‚Ä¶, dim(WN‚ÇÇ, bN‚ÇÇ))</code>. While the implementation does not distinguish between <code>FusionStyle isa Abelian</code> or <code>FusionStyle isa NonAbelian</code>, in the former case the fusion tree is completely characterized by the uncoupled sectors, and so the subblocks can also be accessed as <code>t[(a1, ‚Ä¶, aN‚ÇÅ), (b1, ‚Ä¶, bN‚ÇÇ)]</code>. When there is no symmetry at all, i.e. <code>sectortype(t) == Trivial</code>, <code>t[]</code> returns the raw tensor data as a <code>StridedArray</code> of size <code>(dim(V1), ‚Ä¶, dim(VN‚ÇÅ), dim(W1), ‚Ä¶, dim(WN‚ÇÇ))</code>, whereas <code>block(t, Trivial())</code> returns the same data as a <code>DenseMatrix</code> of size <code>(dim(V1) * ‚Ä¶ * dim(VN‚ÇÅ), dim(W1) * ‚Ä¶ * dim(WN‚ÇÇ))</code>.</p><h2 id="Constructing-tensor-maps-and-accessing-tensor-data-1"><a class="docs-heading-anchor" href="#Constructing-tensor-maps-and-accessing-tensor-data-1">Constructing tensor maps and accessing tensor data</a><a class="docs-heading-anchor-permalink" href="#Constructing-tensor-maps-and-accessing-tensor-data-1" title="Permalink"></a></h2><p>Having learned how a tensor is represented and stored, we can now discuss how to create tensors and tensor maps. From hereon, we focus purely on the interface rather than the implementation.</p><p>The most convenient set of constructors are those that construct  tensors or tensor maps with random or uninitialized data. They take the form</p><p><code>TensorMap(f, codomain, domain)</code></p><p><code>TensorMap(f, eltype::Type{&lt;:Number}, codomain, domain)</code></p><p><code>TensorMap(undef, codomain, domain)</code></p><p><code>TensorMap(undef, eltype::Type{&lt;:Number}, codomain, domain)</code></p><p>Here, in the first form, <code>f</code> can be any function or object that is called with an argument of type <code>Dims{2} = Tuple{Int,Int}</code> and is such that <code>f((m,n))</code> creates a <code>DenseMatrix</code> instance with <code>size(f(m,n)) == (m,n)</code>. In the second form, <code>f</code> is called as <code>f(eltype,(m,n))</code>. Possibilities for <code>f</code> are <code>randn</code> and <code>rand</code> from Julia Base. TensorKit.jl provides <code>randnormal</code> and <code>randuniform</code> as an synonym for <code>randn</code> and <code>rand</code>, as well as the new function  <code>randisometry</code>, alternatively called <code>randhaar</code>, that creates a random isometric <code>m √ó n</code> matrix <code>w</code> satisfying <code>w&#39;*w ‚âà I</code> distributed according to the Haar measure (this requires <code>m&gt;= n</code>). The third and fourth calling syntax use the <code>UndefInitializer</code> from Julia Base and generates a <code>TensorMap</code> with unitialized data, which could thus contain <code>NaN</code>s.</p><p>In all of these constructors, the last two arguments can be replaced by <code>domain‚Üícodomain</code> or <code>codomain‚Üêdomain</code>, where the arrows are obtained as <code>\rightarrow+TAB</code> and <code>\leftarrow+TAB</code>. These arrows just create a Julia <code>Pair</code>, i.e. also <code>domain =&gt; codomain</code> can be used, provided that <code>domain</code> and <code>codomain</code> are of type <code>ProductSpace</code>. The advantage of the unicode arrows is that they will also convert a single instance of type <code>S&lt;:ElementarySpace</code> to a corresponding <code>ProductSpace{S,1}</code>. Some examples are perhaps in order</p><pre><code class="language-julia-repl">julia&gt; t1 = TensorMap(randnormal, ‚ÑÇ^2 ‚äó ‚ÑÇ^3, ‚ÑÇ^2)
TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^2)):
[:, :, 1] =
 0.25066420142163015  -0.9985144897876708   0.8807932298322687
 0.7428442180199206   -0.9677198396529396  -0.4181512770102268

[:, :, 2] =
 -0.9102184018534457  -0.9914364702992893  -1.3317005045365073
 -0.6145927927013579  -1.4681934494431435   0.9457753033493674

julia&gt; t2 = TensorMap(randisometry, Float32, ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üê ‚ÑÇ^2)
TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^2)):
[:, :, 1] =
  0.16491222f0  -0.41239628f0  -0.27242774f0
 -0.5537304f0    0.55090845f0  -0.34409165f0

[:, :, 2] =
  0.16345567f0   -0.64062333f0   0.6082984f0
 -0.054626465f0  -0.010500831f0  0.43561786f0

julia&gt; t3 = TensorMap(undef, ‚ÑÇ^2 ‚Üí ‚ÑÇ^2 ‚äó ‚ÑÇ^3)
TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^2)):
[:, :, 1] =
 6.93799466889907e-310  6.93799639439646e-310  6.9379946691137e-310
 6.93800228863123e-310  6.93799639439804e-310  6.93799466889907e-310

[:, :, 2] =
 6.93800237072914e-310  6.9379963946004e-310  6.93799466913266e-310
 6.93799639459883e-310  6.937996394602e-310   6.93799639481543e-310

julia&gt; t4failed = TensorMap(undef, ComplexF64, ‚ÑÇ^2 =&gt; ‚ÑÇ^2 ‚äó ‚ÑÇ^3)
ERROR: MethodError: no method matching TensorMap(::UndefInitializer, ::Type{Complex{Float64}}, ::Pair{ComplexSpace,ProductSpace{ComplexSpace,2}})
Closest candidates are:
  TensorMap(::UndefInitializer, ::Type{T&lt;:Number}, !Matched::ProductSpace{S&lt;:ElementarySpace,N} where N, !Matched::ProductSpace{S&lt;:ElementarySpace,N} where N) where {S&lt;:ElementarySpace, T&lt;:Number} at /home/travis/build/Jutho/TensorKit.jl/src/tensors/tensor.jl:166
  TensorMap(::Any, ::Type{T&lt;:Number}, !Matched::ProductSpace{S&lt;:ElementarySpace,N} where N, !Matched::ProductSpace{S&lt;:ElementarySpace,N} where N) where {S&lt;:ElementarySpace, T&lt;:Number} at /home/travis/build/Jutho/TensorKit.jl/src/tensors/tensor.jl:159
  TensorMap(::Any, ::Type{T&lt;:Number}, !Matched::Union{ProductSpace{S&lt;:ElementarySpace,N} where N, S&lt;:ElementarySpace}, !Matched::Union{ProductSpace{S&lt;:ElementarySpace,N} where N, S&lt;:ElementarySpace}) where {T&lt;:Number, S&lt;:ElementarySpace} at /home/travis/build/Jutho/TensorKit.jl/src/tensors/tensor.jl:172
  ...

julia&gt; t4 = TensorMap(undef, ComplexF64, ProductSpace(‚ÑÇ^2) =&gt; ‚ÑÇ^2 ‚äó ‚ÑÇ^3)
TensorMap((‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^2)):
[:, :, 1] =
 6.93799466889907e-310 + 6.9379967272307e-310im  ‚Ä¶  6.9379967273224e-310 + 6.9379967272702e-310im
  6.9379967272323e-310 + 6.9380023607759e-310im     6.9379968945648e-310 + 6.93799466889907e-310im

[:, :, 2] =
  6.9379967273382e-310 + 6.93799672734453e-310im  ‚Ä¶  6.93799689457587e-310 + 6.93799466889907e-310im
 6.93799672727497e-310 + 6.93799689455137e-310im     6.93799672725283e-310 + 6.9379967272544e-310im

julia&gt; domain(t1) == domain(t2) == domain(t3) == domain(t4)
true

julia&gt; codomain(t1) == codomain(t2) == codomain(t3) == codomain(t4)
true

julia&gt; disp(x) = show(IOContext(Core.stdout, :compact=&gt;false), &quot;text/plain&quot;, trunc.(x; digits = 3));

julia&gt; t1[] |&gt; disp
2√ó3√ó2 Strided.StridedView{Float64,3,Array{Float64,1},typeof(identity)}:
[:, :, 1] =
 0.25   -0.998   0.88 
 0.742  -0.967  -0.418

[:, :, 2] =
 -0.91   -0.991  -1.331
 -0.614  -1.468   0.945
julia&gt; block(t1, Trivial()) |&gt; disp
6√ó2 Array{Float64,2}:
  0.25   -0.91 
  0.742  -0.614
 -0.998  -0.991
 -0.967  -1.468
  0.88   -1.331
 -0.418   0.945
julia&gt; reshape(t1[], dim(codomain(t1)), dim(domain(t1))) |&gt; disp
6√ó2 Array{Float64,2}:
  0.25   -0.91 
  0.742  -0.614
 -0.998  -0.991
 -0.967  -1.468
  0.88   -1.331
 -0.418   0.945</code></pre><p>Finally, all constructors can also be replaced by <code>Tensor(..., codomain)</code>, in which case the domain is assumed to be the empty <code>ProductSpace{S,0}()</code>, which can easily be obtained as <code>one(codomain)</code>. Indeed, the empty product space is the unit object of the monoidal category, equivalent to the field of scalars <code>ùïú</code>, and thus the multiplicative identity (especially since <code>*</code> also acts as tensor product on vector spaces).</p><p>The matrices created by <code>f</code> are the matrices <span>$B_c$</span> discussed above, i.e. those returned by <code>block(t, c)</code>. Only numerical matrices of type <code>DenseMatrix</code> are accepted, which in practice just means Julia&#39;s intrinsic <code>Matrix{T}</code> for some <code>T&lt;:Number</code>. In the future, we will add support for <code>CuMatrix</code> from <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArrays.jl</a> to harness GPU computing power, and maybe <code>SharedArray</code> from the Julia&#39;s <code>SharedArrays</code> standard library.</p><p>Support for static or sparse data is currently not available, and if it would be implemented, it would lead to new subtypes of <code>AbstractTensorMap</code> which are distinct from <code>TensorMap</code>.</p><p>Let&#39;s conclude this section with some examples with <code>RepresentationSpace</code>.</p><pre><code class="language-julia-repl">julia&gt; V1 = ‚Ñ§‚ÇÇSpace(0=&gt;3,1=&gt;2)
‚Ñ§‚ÇÇSpace(0=&gt;3, 1=&gt;2)

julia&gt; V2 = ‚Ñ§‚ÇÇSpace(0=&gt;2,1=&gt;1)
‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;1)

julia&gt; t = TensorMap(randn, V1 ‚äó V1, V2 ‚äó V2&#39;)
TensorMap((‚Ñ§‚ÇÇSpace(0=&gt;3, 1=&gt;2) ‚äó ‚Ñ§‚ÇÇSpace(0=&gt;3, 1=&gt;2)) ‚Üê (‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;1) ‚äó ‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;1)&#39;)):
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(0)):
[:, :, 1, 1] =
 -0.3146654932224187  0.7436422637883344
  0.8344391171008118  1.3020366034729771

[:, :, 2, 1] =
  1.3994109601511777   0.9562508571044347
 -0.47934992369827817  0.19398314756346047

[:, :, 1, 2] =
  0.09657322569840768   0.2753771183243375
 -0.5383496609468071   -0.7451903846145812

[:, :, 2, 2] =
 0.7067390892142882   -0.19389634012854448
 0.22151683068631153   0.23061498068566463
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(0)):
[:, :, 1, 1] =
 -0.2821577360766088  -1.294100203044881   -0.41544565878948614
  1.4369024579024914  -0.8889734127363913  -0.043079856753253654
  0.9437969517303597   0.5255235569476913   0.431932639112424

[:, :, 2, 1] =
  0.48619989843502953   -0.43558962838611764  0.38200240502420807
 -0.011531584260203556   0.0850786790961474   0.33320629319849915
  1.1687721213193802     0.3624664497229948   1.6776699452116617

[:, :, 1, 2] =
 -0.3613408355605243  -0.09485288482998747  -0.18842835526704513
 -2.025719633424143   -0.8604023747876554   -0.8954976899396095
 -0.566950778390794   -0.3665748642945825    0.17382656500562546

[:, :, 2, 2] =
 -0.38205472030002446  -0.6223654193665918   -1.2827635842386105
  0.8919541927579699   -0.48405374339547397   1.8866973091697181
  0.3179321598834096   -0.643219226614329    -0.5978873841007085
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(1)):
[:, :, 1, 1] =
 -1.3717616591435267  0.05573124515191072
 -0.8470228252728295  1.025702117730853
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(1)):
[:, :, 1, 1] =
 -1.5839988289885518   -1.4069303127321446   -1.081098396578378
  0.14537788510875163  -0.46355351165506165  -0.3211037163464986
 -1.8230713225334845    0.45744685964182286   0.963654921172558
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(0)):
[:, :, 1, 1] =
 -1.391380269919395  -0.33044236131537985  0.5121083433632312
  2.105642796317673   1.3579337121658184   0.9715506290477895

[:, :, 1, 2] =
 0.663691737369041    1.1893293158628044  -0.18182942987278783
 0.06158829531835959  0.9106490813437422   1.2484226468680972
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(0)):
[:, :, 1, 1] =
 -0.07381724983352608  1.005476086360162
  1.7081432316911505   1.2905206010298225
  0.0696524065089151   1.4368198856997432

[:, :, 1, 2] =
  0.8552231386385855  -0.28509352792405096
 -0.4001435425959775  -0.1369507551627794
 -2.4695558741967902  -0.44987812639578006
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(1)):
[:, :, 1, 1] =
 0.7564343523055971   0.1354981939011531  -1.4258613375867049
 0.4378931857038065  -1.278831335157929    1.986823637095424

[:, :, 2, 1] =
 -0.5207497289746555  -0.8163255921079319    0.6221240450861996
 -0.8632112896340554   0.40615443947008767  -0.8046155847202756
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(1)):
[:, :, 1, 1] =
 -1.2388951162326198   0.4734319098881854
  1.0570016289267128  -0.6071865576246587
  1.6829278555437226  -0.09037580515510787

[:, :, 2, 1] =
  0.6812382810400356   0.5182885717998893
 -0.4401958342032298   1.4006980324711298
 -0.12933743831869965  1.2655413697261335

julia&gt; (array = convert(Array, t)) |&gt; disp
5√ó5√ó3√ó3 Array{Float64,4}:
[:, :, 1, 1] =
 -0.282  -1.294  -0.415   0.0    0.0  
  1.436  -0.888  -0.043   0.0    0.0  
  0.943   0.525   0.431   0.0    0.0  
  0.0     0.0     0.0    -0.314  0.743
  0.0     0.0     0.0     0.834  1.302

[:, :, 2, 1] =
  0.486  -0.435  0.382   0.0    0.0  
 -0.011   0.085  0.333   0.0    0.0  
  1.168   0.362  1.677   0.0    0.0  
  0.0     0.0    0.0     1.399  0.956
  0.0     0.0    0.0    -0.479  0.193

[:, :, 3, 1] =
  0.0     0.0    0.0    -0.073  1.005
  0.0     0.0    0.0     1.708  1.29 
  0.0     0.0    0.0     0.069  1.436
 -1.391  -0.33   0.512   0.0    0.0  
  2.105   1.357  0.971   0.0    0.0  

[:, :, 1, 2] =
 -0.361  -0.094  -0.188   0.0     0.0  
 -2.025  -0.86   -0.895   0.0     0.0  
 -0.566  -0.366   0.173   0.0     0.0  
  0.0     0.0     0.0     0.096   0.275
  0.0     0.0     0.0    -0.538  -0.745

[:, :, 2, 2] =
 -0.382  -0.622  -1.282  0.0     0.0  
  0.891  -0.484   1.886  0.0     0.0  
  0.317  -0.643  -0.597  0.0     0.0  
  0.0     0.0     0.0    0.706  -0.193
  0.0     0.0     0.0    0.221   0.23 

[:, :, 3, 2] =
 0.0    0.0     0.0     0.855  -0.285
 0.0    0.0     0.0    -0.4    -0.136
 0.0    0.0     0.0    -2.469  -0.449
 0.663  1.189  -0.181   0.0     0.0  
 0.061  0.91    1.248   0.0     0.0  

[:, :, 1, 3] =
 0.0     0.0     0.0    -1.238   0.473
 0.0     0.0     0.0     1.057  -0.607
 0.0     0.0     0.0     1.682  -0.09 
 0.756   0.135  -1.425   0.0     0.0  
 0.437  -1.278   1.986   0.0     0.0  

[:, :, 2, 3] =
  0.0     0.0     0.0     0.681  0.518
  0.0     0.0     0.0    -0.44   1.4  
  0.0     0.0     0.0    -0.129  1.265
 -0.52   -0.816   0.622   0.0    0.0  
 -0.863   0.406  -0.804   0.0    0.0  

[:, :, 3, 3] =
 -1.583  -1.406  -1.081   0.0    0.0  
  0.145  -0.463  -0.321   0.0    0.0  
 -1.823   0.457   0.963   0.0    0.0  
  0.0     0.0     0.0    -1.371  0.055
  0.0     0.0     0.0    -0.847  1.025
julia&gt; d1 = dim(codomain(t))
25

julia&gt; d2 = dim(domain(t))
9

julia&gt; (matrix = reshape(array, d1, d2)) |&gt; disp
25√ó9 Array{Float64,2}:
 -0.282   0.486   0.0    -0.361  -0.382   0.0     0.0     0.0    -1.583
  1.436  -0.011   0.0    -2.025   0.891   0.0     0.0     0.0     0.145
  0.943   1.168   0.0    -0.566   0.317   0.0     0.0     0.0    -1.823
  0.0     0.0    -1.391   0.0     0.0     0.663   0.756  -0.52    0.0  
  0.0     0.0     2.105   0.0     0.0     0.061   0.437  -0.863   0.0  
 -1.294  -0.435   0.0    -0.094  -0.622   0.0     0.0     0.0    -1.406
 -0.888   0.085   0.0    -0.86   -0.484   0.0     0.0     0.0    -0.463
  0.525   0.362   0.0    -0.366  -0.643   0.0     0.0     0.0     0.457
  0.0     0.0    -0.33    0.0     0.0     1.189   0.135  -0.816   0.0  
  0.0     0.0     1.357   0.0     0.0     0.91   -1.278   0.406   0.0  
 -0.415   0.382   0.0    -0.188  -1.282   0.0     0.0     0.0    -1.081
 -0.043   0.333   0.0    -0.895   1.886   0.0     0.0     0.0    -0.321
  0.431   1.677   0.0     0.173  -0.597   0.0     0.0     0.0     0.963
  0.0     0.0     0.512   0.0     0.0    -0.181  -1.425   0.622   0.0  
  0.0     0.0     0.971   0.0     0.0     1.248   1.986  -0.804   0.0  
  0.0     0.0    -0.073   0.0     0.0     0.855  -1.238   0.681   0.0  
  0.0     0.0     1.708   0.0     0.0    -0.4     1.057  -0.44    0.0  
  0.0     0.0     0.069   0.0     0.0    -2.469   1.682  -0.129   0.0  
 -0.314   1.399   0.0     0.096   0.706   0.0     0.0     0.0    -1.371
  0.834  -0.479   0.0    -0.538   0.221   0.0     0.0     0.0    -0.847
  0.0     0.0     1.005   0.0     0.0    -0.285   0.473   0.518   0.0  
  0.0     0.0     1.29    0.0     0.0    -0.136  -0.607   1.4     0.0  
  0.0     0.0     1.436   0.0     0.0    -0.449  -0.09    1.265   0.0  
  0.743   0.956   0.0     0.275  -0.193   0.0     0.0     0.0     0.055
  1.302   0.193   0.0    -0.745   0.23    0.0     0.0     0.0     1.025
julia&gt; (u = reshape(convert(Array, TensorMap(I, codomain(t), fuse(codomain(t)))), d1, d1)) |&gt; disp
25√ó25 Array{Float64,2}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
julia&gt; (v = reshape(convert(Array, TensorMap(I, domain(t), fuse(domain(t)))), d2, d2)) |&gt; disp
9√ó9 Array{Float64,2}:
 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0
julia&gt; u&#39;*u ‚âà I ‚âà v&#39;*v
true

julia&gt; (u&#39;*matrix*v) |&gt; disp
25√ó9 Array{Float64,2}:
 -0.282   0.486  -0.361  -0.382  -1.583   0.0     0.0     0.0     0.0  
  1.436  -0.011  -2.025   0.891   0.145   0.0     0.0     0.0     0.0  
  0.943   1.168  -0.566   0.317  -1.823   0.0     0.0     0.0     0.0  
 -1.294  -0.435  -0.094  -0.622  -1.406   0.0     0.0     0.0     0.0  
 -0.888   0.085  -0.86   -0.484  -0.463   0.0     0.0     0.0     0.0  
  0.525   0.362  -0.366  -0.643   0.457   0.0     0.0     0.0     0.0  
 -0.415   0.382  -0.188  -1.282  -1.081   0.0     0.0     0.0     0.0  
 -0.043   0.333  -0.895   1.886  -0.321   0.0     0.0     0.0     0.0  
  0.431   1.677   0.173  -0.597   0.963   0.0     0.0     0.0     0.0  
 -0.314   1.399   0.096   0.706  -1.371   0.0     0.0     0.0     0.0  
  0.834  -0.479  -0.538   0.221  -0.847   0.0     0.0     0.0     0.0  
  0.743   0.956   0.275  -0.193   0.055   0.0     0.0     0.0     0.0  
  1.302   0.193  -0.745   0.23    1.025   0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     0.0    -1.391   0.663   0.756  -0.52 
  0.0     0.0     0.0     0.0     0.0     2.105   0.061   0.437  -0.863
  0.0     0.0     0.0     0.0     0.0    -0.33    1.189   0.135  -0.816
  0.0     0.0     0.0     0.0     0.0     1.357   0.91   -1.278   0.406
  0.0     0.0     0.0     0.0     0.0     0.512  -0.181  -1.425   0.622
  0.0     0.0     0.0     0.0     0.0     0.971   1.248   1.986  -0.804
  0.0     0.0     0.0     0.0     0.0    -0.073   0.855  -1.238   0.681
  0.0     0.0     0.0     0.0     0.0     1.708  -0.4     1.057  -0.44 
  0.0     0.0     0.0     0.0     0.0     0.069  -2.469   1.682  -0.129
  0.0     0.0     0.0     0.0     0.0     1.005  -0.285   0.473   0.518
  0.0     0.0     0.0     0.0     0.0     1.29   -0.136  -0.607   1.4  
  0.0     0.0     0.0     0.0     0.0     1.436  -0.449  -0.09    1.265
julia&gt; # compare with:
       block(t, ‚Ñ§‚ÇÇ(0)) |&gt; disp
13√ó5 Array{Float64,2}:
 -0.282   0.486  -0.361  -0.382  -1.583
  1.436  -0.011  -2.025   0.891   0.145
  0.943   1.168  -0.566   0.317  -1.823
 -1.294  -0.435  -0.094  -0.622  -1.406
 -0.888   0.085  -0.86   -0.484  -0.463
  0.525   0.362  -0.366  -0.643   0.457
 -0.415   0.382  -0.188  -1.282  -1.081
 -0.043   0.333  -0.895   1.886  -0.321
  0.431   1.677   0.173  -0.597   0.963
 -0.314   1.399   0.096   0.706  -1.371
  0.834  -0.479  -0.538   0.221  -0.847
  0.743   0.956   0.275  -0.193   0.055
  1.302   0.193  -0.745   0.23    1.025
julia&gt; block(t, ‚Ñ§‚ÇÇ(1)) |&gt; disp
12√ó4 Array{Float64,2}:
 -1.391   0.663   0.756  -0.52 
  2.105   0.061   0.437  -0.863
 -0.33    1.189   0.135  -0.816
  1.357   0.91   -1.278   0.406
  0.512  -0.181  -1.425   0.622
  0.971   1.248   1.986  -0.804
 -0.073   0.855  -1.238   0.681
  1.708  -0.4     1.057  -0.44 
  0.069  -2.469   1.682  -0.129
  1.005  -0.285   0.473   0.518
  1.29   -0.136  -0.607   1.4  
  1.436  -0.449  -0.09    1.265</code></pre><p>Here, we illustrated some additional concepts. We constructed a <code>TensorMap</code> where the blocks are initialized with the identity matrix using <code>I::UniformScaling</code> from Julia&#39;s <code>LinearAlgebra</code> standard library. This works even if the blocks are not square, in this case zero rows or columns (depending on the shape of the block) will be added. Creating a <code>TensorMap</code> with <code>I</code> is a useful way to construct a fixed unitary or isometry between two spaces. The operation <code>fuse(V)</code> creates an <code>ElementarySpace</code> which is isomorphic to a given space <code>V</code> (of type <code>ProductSpace</code> or <code>ElementarySpace</code>). Constructing a <code>TensorMap</code> between <code>V</code> and <code>fuse(V)</code> using the <code>I</code> constructor definitely results in a unitary, in particular it is the unitary which implements the basis change from the product basis to the coupled basis. In this case, for a group <code>G</code> with <code>FusionStyle(G) isa Abelian</code>, it is a permutation matrix. Specifically choosing <code>V</code> equal to the codomain and domain of <code>t</code>, we can construct the explicit basis transforms that bring <code>t</code> into block diagonal form.</p><p>Let&#39;s repeat the same exercise for <code>G = SU‚ÇÇ</code>, which has <code>FusionStyle(G) isa NonAbelian</code>.</p><pre><code class="language-julia-repl">julia&gt; V1 = SU‚ÇÇSpace(0=&gt;2,1=&gt;1)
SU‚ÇÇSpace(0=&gt;2, 1=&gt;1)

julia&gt; V2 = SU‚ÇÇSpace(0=&gt;1,1=&gt;1)
SU‚ÇÇSpace(0=&gt;1, 1=&gt;1)

julia&gt; t = TensorMap(randn, V1 ‚äó V1, V2 ‚äó V2&#39;)
TensorMap((SU‚ÇÇSpace(0=&gt;2, 1=&gt;1) ‚äó SU‚ÇÇSpace(0=&gt;2, 1=&gt;1)) ‚Üê (SU‚ÇÇSpace(0=&gt;1, 1=&gt;1) ‚äó SU‚ÇÇSpace(0=&gt;1, 1=&gt;1)&#39;)):
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
 -1.7833845824019792
* Data for fusiontree FusionTree{SU‚ÇÇ}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((0, 0), 0, (false, true), ()):
[:, :, 1, 1] =
  0.20403016311787428  -2.9053911399320156
 -0.37820127883922927   0.9598360045864258
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.6866821017849838
* Data for fusiontree FusionTree{SU‚ÇÇ}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 0, (false, true), ()):
[:, :, 1, 1] =
 -0.8424478759246166   0.5798644172173737
 -1.7406830880335367  -1.8460540237223029
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.28339966068225614  0.09785322753896565
* Data for fusiontree FusionTree{SU‚ÇÇ}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.961251262906238
  1.3448845155853213
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 0), 1, (false, true), ()):
[:, :, 1, 1] =
 0.8232881729905888
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 0.18177642532058796  0.025595777303985216
* Data for fusiontree FusionTree{SU‚ÇÇ}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -1.732625091800063
  0.946091986896355
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((0, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -0.40971040241783463
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -1.0202684818755223  -1.129788897865751
* Data for fusiontree FusionTree{SU‚ÇÇ}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
  0.8366551222642306
 -1.0628679596755906
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 1, (false, true), ()):
[:, :, 1, 1] =
 -1.2441825992367945
* Data for fusiontree FusionTree{SU‚ÇÇ}((1, 1), 2, (false, false), ()) ‚Üê FusionTree{SU‚ÇÇ}((1, 1), 2, (false, true), ()):
[:, :, 1, 1] =
 -0.039606062021725605

julia&gt; (array = convert(Array, t)) |&gt; disp
5√ó5√ó4√ó4 Array{Float64,4}:
[:, :, 1, 1] =
  0.204  -2.905   0.0    0.0     0.0  
 -0.378   0.959   0.0    0.0     0.0  
  0.0     0.0     0.0    0.0    -1.029
  0.0     0.0     0.0    1.029   0.0  
  0.0     0.0    -1.029  0.0     0.0  

[:, :, 2, 1] =
  0.0    0.0    -0.961  0.0    0.0
  0.0    0.0     1.344  0.0    0.0
 -0.283  0.097   0.0    0.582  0.0
  0.0    0.0    -0.582  0.0    0.0
  0.0    0.0     0.0    0.0    0.0

[:, :, 3, 1] =
  0.0    0.0     0.0    -0.961  0.0  
  0.0    0.0     0.0     1.344  0.0  
  0.0    0.0     0.0     0.0    0.582
 -0.283  0.097   0.0     0.0    0.0  
  0.0    0.0    -0.582   0.0    0.0  

[:, :, 4, 1] =
  0.0    0.0    0.0   0.0    -0.961
  0.0    0.0    0.0   0.0     1.344
  0.0    0.0    0.0   0.0     0.0  
  0.0    0.0    0.0   0.0     0.582
 -0.283  0.097  0.0  -0.582   0.0  

[:, :, 1, 2] =
 0.0    0.0    0.0  0.0    -1.732
 0.0    0.0    0.0  0.0     0.946
 0.0    0.0    0.0  0.0     0.0  
 0.0    0.0    0.0  0.0    -0.289
 0.181  0.025  0.0  0.289   0.0  

[:, :, 2, 2] =
 -0.486   0.334  0.0     0.591   0.0  
 -1.004  -1.065  0.0    -0.751   0.0  
  0.0     0.0    0.0     0.0    -0.857
 -0.721  -0.798  0.0     0.215   0.0  
  0.0     0.0    0.386   0.0     0.0  

[:, :, 3, 2] =
  0.0     0.0    0.0  0.0     0.591
  0.0     0.0    0.0  0.0    -0.751
  0.0     0.0    0.0  0.0     0.0  
  0.0     0.0    0.0  0.0    -0.641
 -0.721  -0.798  0.0  0.602   0.0  

[:, :, 4, 2] =
 0.0  0.0  0.0  0.0   0.0  
 0.0  0.0  0.0  0.0   0.0  
 0.0  0.0  0.0  0.0   0.0  
 0.0  0.0  0.0  0.0   0.0  
 0.0  0.0  0.0  0.0  -0.039

[:, :, 1, 3] =
  0.0     0.0     0.0     1.732  0.0  
  0.0     0.0     0.0    -0.946  0.0  
  0.0     0.0     0.0     0.0    0.289
 -0.181  -0.025   0.0     0.0    0.0  
  0.0     0.0    -0.289   0.0    0.0  

[:, :, 2, 3] =
 0.0    0.0    -0.591  0.0    0.0
 0.0    0.0     0.751  0.0    0.0
 0.721  0.798   0.0    0.641  0.0
 0.0    0.0    -0.602  0.0    0.0
 0.0    0.0     0.0    0.0    0.0

[:, :, 3, 3] =
 -0.486   0.334   0.0    0.0     0.0  
 -1.004  -1.065   0.0    0.0     0.0  
  0.0     0.0     0.0    0.0    -0.215
  0.0     0.0     0.0    0.255   0.0  
  0.0     0.0    -0.215  0.0     0.0  

[:, :, 4, 3] =
  0.0     0.0    0.0  0.0     0.591
  0.0     0.0    0.0  0.0    -0.751
  0.0     0.0    0.0  0.0     0.0  
  0.0     0.0    0.0  0.0    -0.602
 -0.721  -0.798  0.0  0.641   0.0  

[:, :, 1, 4] =
 0.0    0.0    -1.732   0.0    0.0
 0.0    0.0     0.946   0.0    0.0
 0.181  0.025   0.0    -0.289  0.0
 0.0    0.0     0.289   0.0    0.0
 0.0    0.0     0.0     0.0    0.0

[:, :, 2, 4] =
 0.0  0.0   0.0    0.0  0.0
 0.0  0.0   0.0    0.0  0.0
 0.0  0.0  -0.039  0.0  0.0
 0.0  0.0   0.0    0.0  0.0
 0.0  0.0   0.0    0.0  0.0

[:, :, 3, 4] =
 0.0    0.0    -0.591  0.0    0.0
 0.0    0.0     0.751  0.0    0.0
 0.721  0.798   0.0    0.602  0.0
 0.0    0.0    -0.641  0.0    0.0
 0.0    0.0     0.0    0.0    0.0

[:, :, 4, 4] =
 -0.486   0.334   0.0    -0.591  0.0  
 -1.004  -1.065   0.0     0.751  0.0  
  0.0     0.0     0.0     0.0    0.386
  0.721   0.798   0.0     0.215  0.0  
  0.0     0.0    -0.857   0.0    0.0  
julia&gt; d1 = dim(codomain(t))
25

julia&gt; d2 = dim(domain(t))
16

julia&gt; (matrix = reshape(array, d1, d2)) |&gt; disp
25√ó16 Array{Float64,2}:
  0.204   0.0     0.0     0.0     0.0    -0.486   0.0     0.0     0.0     0.0    -0.486   0.0     0.0     0.0     0.0    -0.486
 -0.378   0.0     0.0     0.0     0.0    -1.004   0.0     0.0     0.0     0.0    -1.004   0.0     0.0     0.0     0.0    -1.004
  0.0    -0.283   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.721   0.0     0.0     0.181   0.0     0.721   0.0  
  0.0     0.0    -0.283   0.0     0.0    -0.721   0.0     0.0    -0.181   0.0     0.0     0.0     0.0     0.0     0.0     0.721
  0.0     0.0     0.0    -0.283   0.181   0.0    -0.721   0.0     0.0     0.0     0.0    -0.721   0.0     0.0     0.0     0.0  
 -2.905   0.0     0.0     0.0     0.0     0.334   0.0     0.0     0.0     0.0     0.334   0.0     0.0     0.0     0.0     0.334
  0.959   0.0     0.0     0.0     0.0    -1.065   0.0     0.0     0.0     0.0    -1.065   0.0     0.0     0.0     0.0    -1.065
  0.0     0.097   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.798   0.0     0.0     0.025   0.0     0.798   0.0  
  0.0     0.0     0.097   0.0     0.0    -0.798   0.0     0.0    -0.025   0.0     0.0     0.0     0.0     0.0     0.0     0.798
  0.0     0.0     0.0     0.097   0.025   0.0    -0.798   0.0     0.0     0.0     0.0    -0.798   0.0     0.0     0.0     0.0  
  0.0    -0.961   0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.591   0.0     0.0    -1.732   0.0    -0.591   0.0  
  0.0     1.344   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.751   0.0     0.0     0.946   0.0     0.751   0.0  
  0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.039   0.0     0.0  
  0.0    -0.582   0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.602   0.0     0.0     0.289   0.0    -0.641   0.0  
 -1.029   0.0    -0.582   0.0     0.0     0.386   0.0     0.0    -0.289   0.0    -0.215   0.0     0.0     0.0     0.0    -0.857
  0.0     0.0    -0.961   0.0     0.0     0.591   0.0     0.0     1.732   0.0     0.0     0.0     0.0     0.0     0.0    -0.591
  0.0     0.0     1.344   0.0     0.0    -0.751   0.0     0.0    -0.946   0.0     0.0     0.0     0.0     0.0     0.0     0.751
  0.0     0.582   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.641   0.0     0.0    -0.289   0.0     0.602   0.0  
  1.029   0.0     0.0     0.0     0.0     0.215   0.0     0.0     0.0     0.0     0.255   0.0     0.0     0.0     0.0     0.215
  0.0     0.0     0.0    -0.582   0.289   0.0     0.602   0.0     0.0     0.0     0.0     0.641   0.0     0.0     0.0     0.0  
  0.0     0.0     0.0    -0.961  -1.732   0.0     0.591   0.0     0.0     0.0     0.0     0.591   0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     1.344   0.946   0.0    -0.751   0.0     0.0     0.0     0.0    -0.751   0.0     0.0     0.0     0.0  
 -1.029   0.0     0.582   0.0     0.0    -0.857   0.0     0.0     0.289   0.0    -0.215   0.0     0.0     0.0     0.0     0.386
  0.0     0.0     0.0     0.582  -0.289   0.0    -0.641   0.0     0.0     0.0     0.0    -0.602   0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.039   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0  
julia&gt; (u = reshape(convert(Array, TensorMap(I, codomain(t), fuse(codomain(t)))), d1, d1)) |&gt; disp
25√ó25 Array{Float64,2}:
 1.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  1.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  1.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  1.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    1.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  -0.707   0.0     0.0    0.0  0.707  0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0    -0.707   0.0    0.0  0.0    0.408  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.707   0.0     0.0    0.0  0.707  0.0    0.0    0.0
 0.0  0.0  0.0  0.0  -0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.816  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0    -0.707  0.0  0.0    0.0    0.707  0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    0.0
 0.0  0.0  0.0  0.0   0.577  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.707   0.0    0.0  0.0    0.408  0.0    0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.707  0.0  0.0    0.0    0.707  0.0
 0.0  0.0  0.0  0.0   0.0    0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0   0.0     0.0     0.0    0.0  0.0    0.0    0.0    1.0
julia&gt; (v = reshape(convert(Array, TensorMap(I, domain(t), fuse(domain(t)))), d2, d2)) |&gt; disp
16√ó16 Array{Float64,2}:
 1.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    1.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  1.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  0.0  1.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.999   0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.707  0.0    0.0     0.0     0.408   0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.707  0.0     0.0     0.0     0.707  0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.999
 0.0  0.0    0.0  0.0  0.0  0.0    -0.999  0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0    -0.707   0.0    0.0    0.0    -0.707   0.0     0.0    0.0  
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.0     0.0    -0.816   0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.707  0.0     0.0     0.0    -0.707  0.0  
 0.0  0.0    0.0  0.0  0.0  0.999   0.0    0.0     0.0     0.0    0.0    0.0     0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0     0.0     0.0    0.0    0.999   0.0     0.0     0.0    0.0  
 0.0  0.0    0.0  0.0  0.0  0.0     0.0    0.0    -0.707   0.0    0.0    0.0     0.707   0.0     0.0    0.0  
 0.0  0.577  0.0  0.0  0.0  0.0     0.0    0.0     0.0    -0.707  0.0    0.0     0.0     0.408   0.0    0.0  
julia&gt; u&#39;*u ‚âà I ‚âà v&#39;*v
true

julia&gt; (u&#39;*matrix*v) |&gt; disp
25√ó16 Array{Float64,2}:
  0.204  -0.842   0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0     0.0     0.0     0.0     0.0  
 -0.378  -1.74    0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0  
 -2.905   0.579   0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.959  -1.846   0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0  
 -1.783  -0.686   0.0    -0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0  
  0.0     0.0    -0.283   0.0     0.0     0.181   0.0     0.0    -1.02    0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.0    -0.0     0.0    -0.283   0.0     0.0     0.181   0.0     0.0    -1.02    0.0     0.0     0.0    -0.0     0.0     0.0  
  0.0     0.0     0.0     0.0    -0.283   0.0     0.0     0.181   0.0     0.0    -1.02    0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.097   0.0     0.0     0.025   0.0     0.0    -1.129   0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.097   0.0     0.0     0.025   0.0     0.0    -1.129   0.0     0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     0.097   0.0     0.0     0.025   0.0     0.0    -1.129   0.0     0.0     0.0     0.0     0.0  
  0.0     0.0    -0.961   0.0     0.0    -1.732   0.0     0.0     0.836   0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.0    -0.0     0.0    -0.961   0.0     0.0    -1.732   0.0     0.0     0.836   0.0     0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.0    -0.961   0.0     0.0    -1.732   0.0     0.0     0.836   0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     1.344   0.0     0.0     0.946   0.0     0.0    -1.062   0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.0    -0.0     0.0     1.344   0.0     0.0     0.946   0.0     0.0    -1.062   0.0     0.0     0.0    -0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     1.344   0.0     0.0     0.946   0.0     0.0    -1.062   0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.823   0.0     0.0    -0.409   0.0     0.0    -1.244   0.0     0.0     0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.823   0.0     0.0    -0.409   0.0     0.0    -1.244   0.0     0.0     0.0    -0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     0.823   0.0     0.0    -0.409   0.0     0.0    -1.244   0.0     0.0     0.0     0.0     0.0  
  0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.039   0.0     0.0     0.0     0.0  
  0.0     0.0    -0.0     0.0     0.0    -0.0     0.0     0.0    -0.0     0.0     0.0     0.0    -0.039   0.0     0.0     0.0  
  0.0    -0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.0     0.0     0.0     0.0    -0.039   0.0     0.0  
  0.0     0.0     0.0     0.0    -0.0     0.0     0.0    -0.0     0.0     0.0    -0.0     0.0     0.0     0.0    -0.039   0.0  
  0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0     0.0    -0.039
julia&gt; # compare with:
       block(t, SU‚ÇÇ(0)) |&gt; disp
5√ó2 Array{Float64,2}:
  0.204  -0.842
 -0.378  -1.74 
 -2.905   0.579
  0.959  -1.846
 -1.783  -0.686
julia&gt; block(t, SU‚ÇÇ(1)) |&gt; disp
5√ó3 Array{Float64,2}:
 -0.283   0.181  -1.02 
  0.097   0.025  -1.129
 -0.961  -1.732   0.836
  1.344   0.946  -1.062
  0.823  -0.409  -1.244
julia&gt; block(t, SU‚ÇÇ(2)) |&gt; disp
1√ó1 Array{Float64,2}:
 -0.039</code></pre><p>Note that the basis transforms <code>u</code> and <code>v</code> are no longer permutation matrices, but are still unitary. Furthermore, note that they render the tensor block diagonal, but that now every element of the diagonal blocks labeled by <code>c</code> comes itself in a tensor product with an identity matrix of size <code>dim(c)</code>, i.e. <code>dim(SU‚ÇÇ(1)) = 3</code> and <code>dim(SU‚ÇÇ(2)) = 5</code>.</p><p>To create a <code>TensorMap</code> with existing data, one can use the aforementioned form but with the function <code>f</code> replaced with the actual data, i.e. <code>TensorMap(data, codomain, domain)</code> or any of its equivalents. For the specific form of <code>data</code>, we distinguish between the case without and with symmetry. In the former case, one can just pass a <code>DenseArray</code>, either of rank <code>N‚ÇÅ+N‚ÇÇ</code> and with matching size <code>(dims(codomain)..., dims(domain)...)</code>, or just as a <code>DenseMatrix</code> with size <code>(dim(codomain), dim(domain))</code>. In the case of symmetry, <code>data</code> needs to be specified as a dictionary (some subtype of <code>AbstractDict</code>) with the blocksectors <code>c::G &lt;: Sector</code> as keys and the corresponding matrix blocks as value, i.e. <code>data[c]</code> is some <code>DenseMatrix</code> of size <code>(blockdim(codomain, c), blockdim(domain, c))</code>.</p><pre><code class="language-julia-repl">julia&gt; data = randn(3,3,3)
3√ó3√ó3 Array{Float64,3}:
[:, :, 1] =
 -0.775311   1.06975     -0.571026
 -2.42987   -0.00190717   0.768848
 -0.506386  -0.0705129   -0.574581

[:, :, 2] =
 -1.42478   -0.671937   0.164863
  0.843795  -0.131551  -0.127571
 -0.21671   -0.584392   0.26152

[:, :, 3] =
  1.23959    -0.746561  -0.449768
 -0.579454   -1.69869   -0.0453783
 -0.0789341   0.227293  -1.54921

julia&gt; t = TensorMap(data, ‚ÑÇ^3 ‚äó ‚ÑÇ^3, ‚ÑÇ^3)
TensorMap((‚ÑÇ^3 ‚äó ‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^3)):
[:, :, 1] =
 -0.775310832128496    1.0697486317430354     -0.5710256629329664
 -2.429866814489963   -0.0019071670228531042   0.7688480814743845
 -0.5063858813314656  -0.07051293723498359    -0.5745814028644406

[:, :, 2] =
 -1.424775075808484   -0.6719369808109201   0.1648631619776591
  0.8437946008140752  -0.1315514816081345  -0.12757065603737286
 -0.2167095514759772  -0.5843923312608855   0.2615204614290095

[:, :, 3] =
  1.2395883255403068   -0.7465612527369063   -0.44976791855029763
 -0.5794536899831605   -1.6986870593604988   -0.04537828476983172
 -0.07893410623174119   0.22729275996542442  -1.5492084732969733

julia&gt; t ‚âà TensorMap(reshape(data, (9, 3)), ‚ÑÇ^3 ‚äó ‚ÑÇ^3, ‚ÑÇ^3)
true

julia&gt; V = ‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;2)
‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;2)

julia&gt; data = Dict(‚Ñ§‚ÇÇ(0)=&gt;randn(8,2), ‚Ñ§‚ÇÇ(1)=&gt;randn(8,2))
Dict{‚Ñ§‚ÇÇ,Array{Float64,2}} with 2 entries:
  ‚Ñ§‚ÇÇ(0) =&gt; [2.24558 0.286624; 0.0841573 -1.24121; ‚Ä¶ ; 1.5712 0.527126; -0.57069‚Ä¶
  ‚Ñ§‚ÇÇ(1) =&gt; [-1.47299 0.760385; -0.33721 0.536496; ‚Ä¶ ; 0.350208 -1.07289; -0.258‚Ä¶

julia&gt; t2 = TensorMap(data, V*V, V)
TensorMap((‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;2) ‚äó ‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;2)) ‚Üê ProductSpace(‚Ñ§‚ÇÇSpace(0=&gt;2, 1=&gt;2))):
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(0),):
[:, :, 1] =
 -0.10303147017790171   1.571200050570718
 -0.24380953883632245  -0.5706977138778339

[:, :, 2] =
 -0.5057404945862969   0.5271262038635443
 -1.4758366901803346  -0.48845610389735755
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(0),):
[:, :, 1] =
 2.2455849128660277   -0.6053786258769707
 0.08415726852363233   1.346361694901005

[:, :, 2] =
  0.28662373964734555  0.36856112254691736
 -1.241211811062042    0.5554774755307399
* Data for sector (‚Ñ§‚ÇÇ(1), ‚Ñ§‚ÇÇ(0)) ‚Üê (‚Ñ§‚ÇÇ(1),):
[:, :, 1] =
 -1.4729891934436783   1.9539356899009486
 -0.33720981056778293  0.05296979459400488

[:, :, 2] =
 0.7603845703709003   1.821157100703745
 0.536495812971978   -0.24699705242374317
* Data for sector (‚Ñ§‚ÇÇ(0), ‚Ñ§‚ÇÇ(1)) ‚Üê (‚Ñ§‚ÇÇ(1),):
[:, :, 1] =
 -1.880915253720692    0.35020776754629823
 -0.8169354515694139  -0.2584167726988796

[:, :, 2] =
 -2.2149007245493926   -1.0728922197630726
  0.03585333983954107   0.23601380411519812</code></pre><h2 id="Vector-space-and-linear-algebra-operations-1"><a class="docs-heading-anchor" href="#Vector-space-and-linear-algebra-operations-1">Vector space and linear algebra operations</a><a class="docs-heading-anchor-permalink" href="#Vector-space-and-linear-algebra-operations-1" title="Permalink"></a></h2><p><code>AbstractTensorMap</code> instances <code>t</code> represent linear maps, i.e. homomorphisms in a <code>ùïú</code>-linear category, just like matrices. To a large extent, they follow the interface of <code>Matrix</code> in Julia&#39;s <code>LinearAlgebra</code> standard library. Many methods from <code>LinearAlgebra</code> are (re)exported by TensorKit.jl, and can then us be used without <code>using LinearAlgebra</code> explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks (typically using the same method) and never needs to perform any basis transforms.</p><p>In particular, <code>AbstractTensorMap</code> instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in <code>t = t1*t2</code>, which is also used for matrix multiplication. TensorKit.jl also supports (and exports) the mutating method <code>mul!(t, t1, t2)</code>.</p><p>Furthermore, when tensor map instances endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as <code>one(t)</code> or <code>one!(t)</code>, where the latter overwrites the contents of <code>t</code>. We can then also try to invert them using <code>inv(t)</code>, or, in case their inverse is composed with another tensor <code>t2</code>, <code>t1\t2</code> or <code>t2/t1</code>. The latter syntax also accepts instances <code>t1</code> whose domain and codomain are not the same, and then amounts to <code>pinv(t1)</code>, the Moore-Penrose pseudoinverse. This, however, is only really justified for <code>TensorMap{S}</code> instances with <code>S isa EuclideanSpace</code>. Returning to endomorphisms, we can compute their trace via <code>tr(t)</code> and exponentiate them using <code>exp(t)</code>, or if the contents of <code>t</code> can be destroyed in the process, <code>exp!(t)</code>. Furthermore, there are a number of tensor factorizations for both endomorphisms and general homomorphism that we discuss below.</p><p><code>AbstractTensorMap</code> instances behave themselves as vectors (i.e. they are <code>ùïú</code>-linear) and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other. There is also a <code>zero(t)</code>, the additive identity, which produces a zero tensor with the same domain and codomain as <code>t</code>. In addition, <code>TensorMap</code> supports basic Julia methods such as <code>fill!</code> and <code>copyto!</code>. Aside from basic <code>+</code> and <code>*</code> operations, TensorKit.jl reexports a number of efficient in-place methods from <code>LinearAlgebra</code>, such as <code>axpy!</code> (for <code>y ‚Üê Œ± * x + y</code>), <code>axpby!</code> (for <code>y ‚Üê Œ± * x + Œ≤ * y</code>), <code>lmul!</code> and <code>rmul!</code> (for <code>y ‚Üê Œ±*y</code> and <code>y ‚Üê y*Œ±</code>, which is typically the same) and <code>mul!</code>, which can be used for out-of-place scalar multiplication <code>y ‚Üê Œ±*x</code>.</p><p>Furthermore, for <code>S isa EuclideanSpace</code>, we can compute the norm of a <code>AbstractTensorMap{S}</code> instance and the the inner product between two instances, again provided they have the same domain and codomain. Furthermore, there is <code>normalize(t)</code> and <code>normalize!(t)</code> to return a scaled version of <code>t</code> with unit norm. <code>AbstractTensorMap</code> instances can be compared for exact (<code>t1 == t2</code>) or approximate (<code>t1 ‚âà t2</code>) equality, though the latter requires <code>norm</code> can be computed.</p><h2 id="Tensor-factorizations-1"><a class="docs-heading-anchor" href="#Tensor-factorizations-1">Tensor factorizations</a><a class="docs-heading-anchor-permalink" href="#Tensor-factorizations-1" title="Permalink"></a></h2><h2 id="Index-manipulations-1"><a class="docs-heading-anchor" href="#Index-manipulations-1">Index manipulations</a><a class="docs-heading-anchor-permalink" href="#Index-manipulations-1" title="Permalink"></a></h2><h2 id="Tensor-contractions-and-tensor-networks-1"><a class="docs-heading-anchor" href="#Tensor-contractions-and-tensor-networks-1">Tensor contractions and tensor networks</a><a class="docs-heading-anchor-permalink" href="#Tensor-contractions-and-tensor-networks-1" title="Permalink"></a></h2><p>TODO</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sectors/">¬´ Sectors, representation spaces and fusion trees</a><a class="docs-footer-nextpage" href="../../lib/spaces/">Vector spaces, symmetry sectors an fusion trees ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 3 February 2020 11:43">Monday 3 February 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
