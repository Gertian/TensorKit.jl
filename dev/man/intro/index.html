<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#ss_tensor-1"><span>What is a tensor?</span></a></li><li><a class="tocitem" href="#ss_symmetries-1"><span>Symmetries and block sparsity</span></a></li><li><a class="tocitem" href="#ss_categories-1"><span>Monoidal categories and their properties (optional)</span></a></li><li><a class="tocitem" href="#Bibliography-1"><span>Bibliography</span></a></li></ul></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/intro.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_intro-1"><a class="docs-heading-anchor" href="#s_intro-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#s_intro-1" title="Permalink"></a></h1><p>Before providing a typical &quot;user guide&quot; and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.</p><h2 id="ss_tensor-1"><a class="docs-heading-anchor" href="#ss_tensor-1">What is a tensor?</a><a class="docs-heading-anchor-permalink" href="#ss_tensor-1" title="Permalink"></a></h2><p>At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:</p><ul><li><p>A tensor <span>$t$</span> is an element from the   <a href="https://en.wikipedia.org/wiki/Tensor_product">tensor product</a> of <span>$N$</span> vector spaces   <span>$V_1 , V_2, …, V_N$</span>, where <span>$N$</span> is referred to as the <em>rank</em> or <em>order</em> of the   tensor, i.e.</p><p><span>$t ∈ V_1 ⊗ V_2 ⊗ … ⊗ V_N.$</span></p></li></ul><p>If you think of a tensor as an object with indices, a rank <span>$N$</span> tensor has <span>$N$</span> indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.</p><p>As the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field, i.e. there is no meaning in <span>$ℝ^5 ⊗ ℂ^3$</span>. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on <a href="man/@ref">Vector spaces</a>.</p><p>Aside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term &quot;tensor map&quot; as follows:</p><ul><li><p>A tensor map <span>$t$</span> is a linear map from a source or <em>domain</em>   <span>$W_1 ⊗ W_2 ⊗ … ⊗ W_{N_2}$</span> to a target or <em>codomain</em> <span>$V_1 ⊗ V_2 ⊗ … ⊗ V_{N_1}$</span>, i.e.</p><p><span>$t:W_1 ⊗ W_2 ⊗ … ⊗ W_{N_2} → V_1 ⊗ V_2 ⊗ … ⊗ V_{N_1}.$</span></p></li></ul><p>A <em>tensor</em> of rank <span>$N$</span> is then just a special case of a tensor map with <span>$N_1 = N$</span> and <span>$N_2 = 0$</span>. A contraction between two tensors is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.</p><p>In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map <span>$W → V$</span> is often denoted as a rank 2 tensor in <span>$V ⊗ W^*$</span>, where <span>$W^*$</span> corresponds to the dual space of <span>$W$</span>. This simple example introduces two new concepts.</p><ol><li><p>Typical vector spaces can appear in the domain and codomain in different variants, e.g.  as normal space or dual space. In fact, the most generic case is that every vector  space <span>$V$</span> has associated with it  a <a href="https://en.wikipedia.org/wiki/Dual_space">dual space</a> <span>$V^*$</span>,  a <a href="https://en.wikipedia.org/wiki/Complex_conjugate_vector_space">conjugate space</a>  <span>$\overline{V}$</span> and a conjugate dual space <span>$\overline{V}^*$</span>. The four different  vector spaces <span>$V$</span>, <span>$V^*$</span>, <span>$\overline{V}$</span> and <span>$\overline{V}^*$</span> correspond to the  representation spaces of respectively the fundamental, dual or contragredient, complex  conjugate and dual complex conjugate representation of the general linear group  <span>$\mathsf{GL}(V)$</span> <sup class="footnote-reference"><a id="citeref-tung" href="#footnote-tung">[tung]</a></sup>. In index notation these spaces are denoted with  respectively contravariant (upper), covariant (lower), dotted contravariant  and dotted covariant indices.</p><p>For real vector spaces, the conjugate (dual) space is identical to the normal (dual)  space and we only have upper and lower indices, i.e. this is the setting of e.g.  general relativity. For (complex) vector spaces with a sesquilinear inner product  <span>$\overline{V} ⊗ V → ℂ$</span>, the inner product allows to define an isomorphism from the  conjugate space to the dual space (known as  <a href="https://en.wikipedia.org/wiki/Riesz_representation_theorem">Riesz representation theorem</a>  in the more general context of Hilbert spaces).</p><p>In particular, in spaces with a Euclidean inner product (the setting of e.g. quantum  mechanics), the conjugate and dual space are naturally isomorphic (because the dual and  conjugate representation of the unitary group are the same). Again we only need upper  and lower indices (or kets and bras).</p><p>Finally, in <span>$ℝ^d$</span> with a Euclidean inner product, these four different spaces are  equivalent and we only need one type of index. The space is completely characterized by  its dimension <span>$d$</span>. This is the setting of much of classical mechanics and we refer to  such tensors as cartesian tensors and the corresponding space as cartesian space. These  are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some <code>AbstractArray{&lt;:Real,N}</code> in Julia) without loss of structure.</p><p>The implementation of all of this is discussed in <a href="man/@ref">Vector spaces</a>.</p></li><li><p>In the generic case, the identification between maps <span>$W → V$</span> and tensors in  <span>$V ⊗ W^*$</span> is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between <span>$V ⊗ W$</span> and <span>$W ⊗ V$</span> that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories. Nonetheless, we try to hide these  canonical isomorphisms from the user wherever possible.</p></li></ol><p>This brings us to our final (yet formal) definition</p><ul><li>A tensor (map) is a homorphism between two objects from the category <span>$\mathbf{Vect}$</span>   (or some subcategory thereof). In practice, this will be <span>$\mathbf{FinVect}$</span>, the   category of finite dimensional vector spaces. More generally, our concept of a tensor   makes sense, in principle, for any linear (a.k.a. <span>$\mathbf{Vect}$</span>-enriched) monoidal   category. We refer to the section   &quot;<a href="man/@ref">Monoidal categories and their properties (optional)</a>&quot;.</li></ul><h2 id="ss_symmetries-1"><a class="docs-heading-anchor" href="#ss_symmetries-1">Symmetries and block sparsity</a><a class="docs-heading-anchor-permalink" href="#ss_symmetries-1" title="Permalink"></a></h2><p>Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group <span>$\mathsf{G}$</span> which acts on the vector spaces <span>$V$</span> in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space <span>$V$</span> can be specified as the number of times every irreducible representation (irrep) <span>$a$</span> of <span>$\mathsf{G}$</span> appears, i.e.</p><p><span>$V = \bigoplus_{a} ℂ^{n_a} ⊗ R_a$</span></p><p>with <span>$R_a$</span> the space associated with irrep <span>$a$</span> of <span>$\mathsf{G}$</span>, which itself has dimension <span>$d_a$</span> (often called the quantum dimension), and <span>$n_a$</span> the number of times this irrep appears in <span>$V$</span>. If the unitary irrep <span>$a$</span> for <span>$g ∈ \mathsf{G}$</span> is given by <span>$u_a(g)$</span>, then the group action of <span>$\mathsf{G}$</span> on <span>$V$</span> is given by the unitary representation</p><p><span>$u(g) = \bigoplus_{a}  𝟙_{n_a} ⊗ u_a(g)$</span></p><p>with <span>$𝟙_{n_a}$</span> the <span>$n_a × n_a$</span> identity matrix. The total dimension of <span>$V$</span> is given by <span>$∑_a n_a d_a$</span>.</p><p>The reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps <span>$t:W_1 ⊗ W_2 ⊗ … ⊗ W_{N_2} → V_1 ⊗ V_2 ⊗ … ⊗ V_{N_1}$</span> that are invariant under the symmetry (i.e. that act as <a href="https://en.wikipedia.org/wiki/Equivariant_map#Representation_theory">intertwiners</a> between the symmetry action on the domain and the codomain). Indeed, such tensors should be block diagonal because of <a href="https://en.wikipedia.org/wiki/Schur%27s_lemma">Schur&#39;s lemma</a>, but only after we couple the individual irreps in the spaces <span>$W_i$</span> to a joint irrep, which is then again split into the individual irreps of the spaces <span>$V_i$</span>. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebsch–Gordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups <span>$\mathsf{G}$</span>. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, discussed below and only requires the <em>topological</em> data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah&#39;s W-symbol in the case of <span>$\mathsf{SU}_2$</span>). In particular, we don&#39;t actually need the Clebsch–Gordan coefficients themselves (but they can be useful for checking purposes).</p><p>Further details are provided in <a href="man/@ref">Sectors, representation spaces and fusion trees</a>.</p><h2 id="ss_categories-1"><a class="docs-heading-anchor" href="#ss_categories-1">Monoidal categories and their properties (optional)</a><a class="docs-heading-anchor-permalink" href="#ss_categories-1" title="Permalink"></a></h2><p>The purpose of this final introductory section (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors.  In the end, identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following definitions are mostly based on <sup class="footnote-reference"><a id="citeref-selinger" href="#footnote-selinger">[selinger]</a></sup>, <sup class="footnote-reference"><a id="citeref-kassel" href="#footnote-kassel">[kassel]</a></sup> and <a href="https://ncatlab.org/"><span>$n$</span>Lab</a>, to which we refer for further information. Furthermore, we recommend the nice introduction of <a href="man/^beer">Beer et al.</a></p><p>To start, a category <span>$C$</span> consists of</p><ul><li>a class <span>$|C|$</span> of objects <span>$V$</span>, <span>$W$</span>, …</li><li>for each pair of objects <span>$V$</span> and <span>$W$</span>, a set <span>$hom(W,V)$</span> of morphisms <span>$f:W→V$</span>;   for a given map <span>$f$</span>, <span>$W$</span> is called the <em>domain</em> or <em>source</em>, and <span>$V$</span> the   <em>codomain</em> or <em>target</em>.</li><li>composition of morphisms <span>$f:W→V$</span> and <span>$g:X→W$</span> into <span>$(f ∘ g):X→V$</span> that is   associative, such that for <span>$h:Y→X$</span> we have <span>$f ∘ (g ∘ h) = (f ∘ g) ∘ h$</span></li><li>for each object <span>$V$</span>, an identity morphism <span>$\mathrm{id}_V:V→V$</span> such that   <span>$f ∘ \mathrm{id}_W = f = \mathrm{id}_V ∘ f$</span>.</li></ul><p>In our case, i.e. the category <span>$\mathbf{Vect}$</span> (or some subcategory thereof), the objects are vector spaces, and the morphisms are linear maps between these vector spaces with &quot;matrix multiplication&quot; as composition. We refer to these morphisms as tensor maps exactly because there is a binary operation <span>$⊗$</span>, the tensor product, that allows to combine objects into new objects. This makes <span>$\mathbf{Vect}$</span> into a <strong>tensor category</strong>, a.k.a a <em>monoidal category</em>, which has</p><ul><li>a binary operation on objects <span>$⊗: |C| × |C| → |C|$</span></li><li>a binary operation on morphisms, also denoted as <span>$⊗$</span>, such that   <span>$⊗: hom(W_1,V_1) × hom(W_2,V_2) → hom(W_1 ⊗ W_2, V_1 ⊗ V_2)$</span></li><li>an identity object <span>$I$</span></li><li>three families of natural isomorphisms:<ul><li><span>$∀ V ∈ |C|$</span>, a left unitor <span>$λ_V: I ⊗ V → V$</span></li><li><span>$∀ V ∈ |C|$</span>, a right unitor <span>$ρ_V: V ⊗ I → V$</span></li><li><span>$∀ V_1, V_2, V_3 ∈ |C|$</span>, an associator   <span>$α_{V_1,V_2,V_3}:(V_1 ⊗ V_2) ⊗ V_3 → V_1 ⊗ (V_2 ⊗ V_3)$</span></li></ul>that satisfy certain consistency conditions (coherence axioms), which are known as the   <em>triangle equation</em> and <em>pentagon equation</em>.</li></ul><p>In abstract terms, <span>$⊗$</span> is a (bi)functor from the product category <span>$C × C$</span> to <span>$C$</span>.</p><p>For the category <span>$\mathbf{Vect}$</span>, the identity object <span>$I$</span> is just the scalar field <span>$𝕜$</span> over which the vector spaces are defined, and which can be identified with a one- dimensional vector space. Every monoidal category is equivalent to a strict tensor category, where the left and right unitor and associator act as the identity and their domain and codomain are truly identical. Nonetheless, for tensor maps, we do actually discriminate between <span>$V$</span>, <span>$I ⊗ V$</span> and <span>$V ⊗ I$</span> because this amounts to adding or removing an extra factor <code>I</code> to the tensor product structure of the (co)domain, i.e. the left and right unitor are analogous to removing extra dimensions of size 1 from an array, and an actual operation is required to do so (this has in fact led to some controversy in several programming languages that provide native support for multidimensional arrays). For what concerns the associator, the distinction between <span>$(V_1 ⊗ V_2) ⊗ V_3$</span> and <span>$V_1 ⊗ (V_2 ⊗ V_3)$</span> is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We return to this in <a href="../sectors/#s_sectorsrepfusion-1">the section on fusion trees</a>. However, we can already note that we will always represent tensor products using a canonical order <span>$(…((V_1 ⊗ V_2) ⊗ V_3) … ⊗ V_N)$</span>. A similar approach can be followed to map any tensor category into a strict tensor category (see Section XI.5 of <sup class="footnote-reference"><a id="citeref-kassel" href="#footnote-kassel">[kassel]</a></sup>).</p><p>With these definitions, we have the minimal requirements for defining tensor maps. In principle, we could use a more general definition and define tensor maps as morphism of any tensor category where the hom-sets are themselves vector spaces, such that we can add morphisms and multiply them with scalars. Furthermore, the composition of morphisms and the tensor product of morphisms are bilinear operations. Such categories are called linear or <span>$\mathbf{Vect}$</span>-enriched.</p><p>In order to make tensor (maps) useful and to define operations with them, we can now introduce additional structure or quantifiers to the tensor category for which they are the morphisms.</p><h3 id="sss_braiding-1"><a class="docs-heading-anchor" href="#sss_braiding-1">Braiding</a><a class="docs-heading-anchor-permalink" href="#sss_braiding-1" title="Permalink"></a></h3><p>To reorder tensor indices, or, equivalently, to reorder objects in the tensor product <span>$V_1 ⊗ V_2 ⁠⊗ … V_N$</span>, we need at the very least a <strong>braided tensor category</strong> which has, <span>$∀ V, W ∈ |C|$</span>, a braiding <span>$σ_{V,W}: V⊗W → W⊗V$</span>. A valid braiding needs to satisfy consistency condition with the associator <span>$α$</span> known as the <em>hexagon equation</em>.</p><p>However, for general braidings, there is no unique choice to identify a tensor in <span>$V⊗W$</span> and <span>$W⊗V$</span>, as any of the maps <span>$σ_{V,W}$</span>, <span>$σ_{W,V}^{-1}$</span>, <span>$σ_{V,W} ∘ σ_{W,V} ∘ σ_{V,W}$</span>, …  mapping from <span>$V⊗W$</span> to <span>$W⊗V$</span> are all different. In order for there to be a unique map from <span>$V_1 ⊗ V_2 ⁠⊗ … V_N$</span> to any permutation of the objects in this tensor product, the braiding needs to be <em>symmetric</em>, i.e. <span>$σ_{V,W} = σ_{W,V}^{-1}$</span> or, equivalently <span>$σ_{W,V} ∘ σ_{V,W} = \mathrm{id}_{V⊗W}$</span>. The resulting category is then referred to as a <strong>symmetric tensor category</strong>. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross.</p><p>For a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia&#39;s function <code>permutedims</code> on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered) or in the case of fermions (described using so-called super vector spaces where the braiding is given by the Koszul sign rule).</p><h3 id="sss_dual-1"><a class="docs-heading-anchor" href="#sss_dual-1">Duals and pivotal structure</a><a class="docs-heading-anchor-permalink" href="#sss_dual-1" title="Permalink"></a></h3><p>For tensor maps, the braiding structure only allows to reorder the objects within the domain or within the codomain separately. An <strong>autonomous</strong> or <strong>rigid</strong> monoidal category is one where objects have duals, defined via an exact pairing, i.e. two families of canonical maps, the unit <span>$η_V: I → V ⊗ V^*$</span> and the co-unit <span>$ϵ_V: V^* ⊗ V → I$</span> that satisfy the &quot;snake rules&quot;:</p><p><span>$ρ_V ∘ (\mathrm{id}_V ⊗ ϵ_V) ∘ (η_V ⊗ \mathrm{id}_V) ∘ λ_V^{-1} = \mathrm{id}_V$</span></p><p><span>$λ_{V^*}^{-1} ∘ (ϵ_V ⊗ \mathrm{id}_{V^*}) ∘ (\mathrm{id}_{V^*} ⊗ η_V) ∘ ρ_{V^*}^{-1} = \mathrm{id}_{V^*}$</span></p><p>Given a morphism <span>$t:W→V$</span>, we can now identify it with <span>$(t ⊗ \mathrm{id}_{W^*}) ∘ η_W$</span> to obtain a morphism <span>$I→V⊗W^*$</span>. For the category <span>$\mathbf{Vect}$</span>, this is the identification between linear maps <span>$W→V$</span> and tensors in <span>$V⊗W^*$</span>. In particular, for complex vector spaces, using a bra-ket notation and a generic basis <span>${|n⟩}$</span> for <span>$V$</span> and dual basis <span>${⟨m|}$</span> for <span>$V^*$</span> (such that <span>$⟨m|n⟩ = δ_{m,n}$</span>), the unit is <span>$η_V:ℂ → V ⊗ V^*:α → α ∑_n |n⟩ ⊗ ⟨n|$</span> and the co-unit is <span>$⁠ϵ_V:V^* ⊗ V → ℂ: ⟨m| ⊗ |n⟩ → δ_{m,n}$</span>. Note that this does not require an inner product, i.e. no mapping from <span>$|n⟩$</span> to <span>$⟨n|$</span> was defined.</p><p>For a general tensor map <span>$t:W_1 ⊗ W_2 ⊗ … ⊗ W_{N_2} → V_1 ⊗ V_2 ⊗ … ⊗ V_{N_1}$</span>, by successively applying <span>$η_{W_{N_2}}$</span>, <span>$η_{W_{N_2-1}}$</span>, …, <span>$η_{W_{1}}$</span> (and the left or right unitor) but no braiding, we obtain a tensor in <span>$V_1 ⊗ V_2 ⊗ … ⊗ V_{N_1} ⊗ W_{N_2}^* ⊗ … ⊗ W_{1}^*$</span>. It does makes sense to define or identify <span>$(W_1 ⊗ W_2 ⊗ … ⊗ W_{N_2})^* = W_{N_2}^* ⊗ … ⊗ W_{1}^*$</span>. Indeed, it can be shown that an exact pairing between <span>$V ⊗ W$</span> and <span>$W^* ⊗ V^*$</span> can be constructed out of the unit and counit of <span>$V$</span> and <span>$W$</span>.</p><p>These exact pairings are known as the right unit and co-unit, and <span>$V^*$</span> is the right dual of <span>$V$</span>. Likewise, then, <span>$V$</span> is a left dual of <span>$V^*$</span>, and we can also define a left dual <span>$^*V$</span> of <span>$V$</span> and associated pairings, the left unit <span>$η&#39;_V: I → {^*V} ⊗ V$</span> and the left co-unit <span>$ϵ&#39;_V: V ⊗ {^*V} → I$</span>. An autonomous category <span>$\mathbf{C}$</span> is one where every object <span>$V$</span> has both a left and right dual. If we have a natural isomorphism between both, typically expressed via a pivotal structure <span>$δ_V : {^*V} → V^*$</span> which satisfies <span>$δ_{V ⊗ W} = δ_W ⊗ δ_V$</span>, we do not have to distinguish between both. The resulting category is known as a <em>pivotal category</em>. Indeed, in TensorKit.jl we assume to be working with <strong>pivotal categories</strong> and simply refer to <code>dual(V)</code> for the dual of a vector space.</p><p>For a pivotal category, there is a well defined notion of a transpose <span>$f^*:V^* → W^*$</span> (also called adjoint mate) of a morphism <span>$f:W→V$</span>, namely as as</p><p><span>$f^* = λ_{W^*} ∘ (ϵ_V ⊗ \mathrm{id}_{W^*}) ∘ (\mathrm{id}_{V^*} ⊗ f ⊗ \mathrm{id}_{W^*}) ∘ (\mathrm{id}_{V^*} ⊗ η_{W}) ∘ ρ_{V^*}^{-1}$</span></p><p><span>${^*f} = ρ_{W^*} ∘ (\mathrm{id}_{W^*} ⊗ ϵ_{V^*}) ∘ (\mathrm{id}_{V^*} ⊗ f ⊗ \mathrm{id}_{W^*}) ∘ (η_{W^*} ⊗ \mathrm{id}_{V^*}) ∘ λ_{V^*}^{-1}$</span></p><p>and both definitions coincide (which is not the case if the category is not pivotal). In a graphical representation, this means that boxes (representing tensor maps or morphisms more generally) can be rotated. The transpose corresponds to a 180˚ rotation (either way).</p><p>Furthermore, in a pivotal category, we can define a map from endomorphisms of an object <span>$V$</span>, i.e. a morphism <span>$f:V→V$</span> to endomorphisms of the identity object <span>$I$</span>, i.e. scalars, known as the trace of <span>$f$</span>. In fact, we can define both a left trace as</p><p><span>$tr(f) = ϵ&#39;_V ∘ (f ⊗ \mathrm{id}_{V^*}) ∘ η_V$</span></p><p>and a right trace as</p><p><span>$tr&#39;(f) = ϵ_V ∘ (\mathrm{id}_{V^*} ⊗ f) ∘ η&#39;_V$</span></p><p>In a <strong>spherical</strong> category, both definitions coincide for all <span>$V$</span> and we simply refer to the trace of an endomorphism. The particular value <span>$d_V = tr(\mathrm{id}_V)$</span> is known as the (quantum) dimension of the object <span>$V$</span>, referred to as <code>dim(V)</code> in TensorKit.jl.</p><h3 id="sss_twists-1"><a class="docs-heading-anchor" href="#sss_twists-1">Twists and ribbons</a><a class="docs-heading-anchor-permalink" href="#sss_twists-1" title="Permalink"></a></h3><p>The braiding of a space and a dual space also follows naturally, it is given by <span>$σ_{V^*,W} = λ_{W ⊗ V^*} ∘ (ϵ_V ⊗ \mathrm{id}_{W ⊗ V^*}) ∘ (\mathrm{id}_{V^*} ⊗ σ_{V,W}^{-1} ⊗ \mathrm{id}_{V^*}) ∘ (\mathrm{id}_{V^*⊗ W} ⊗ η_V) ∘ ρ_{V^* ⊗ W}^{-1}$</span></p><p>Furthermore, in a braided pivotal category, we can define a family of natural isomorphisms <span>$θ_V:V→V$</span> (i.e. for <span>$f:W→V$</span>, <span>$θ_V ∘ f = f ∘ θ_W$</span>) as</p><p><span>$θ_V = ρ_V ∘ (\mathrm{id}_V ⊗ ϵ&#39;_V) ∘ (σ_{V,V} ⊗ \mathrm{id}_{V^*}) ∘ (\mathrm{id}_V ⊗ η_V) ∘ ρ_V^{-1}$</span></p><p>which satisfy</p><p><span>$θ_{V⊗W} = σ_{W,V} ∘ (θ_W ⊗ θ_V) ∘ σ_{V,W} = (θ_V ⊗ θ_W) ∘ σ_{W,V} ∘ σ_{V,W}$</span></p><p>A family of natural isomorphisms satisfying this relation is called a <strong>twist</strong>, and the resulting category is called a <strong>balanced</strong> monoidal category.  Here, we defined the twist via the exact pairings, and ultimately via the pivotal structure, i.e. the <span>$\mathrm{id}_{V^*}$</span> in the definition of <span>$θ_V$</span> should have been a <span>$δ_V^{-1}$</span>. The interaction between the twist and the braiding is consistent with the graphical rules of a ribbon. However, for the graphical rules of ribbons to also be compatible with the exact pairing, we furthermore need the condition <span>$θ_{V^*} = θ_V^*$</span> (i.e. the transpose), in which case the category is said to be <strong>tortile</strong> or also a <strong>ribbon category</strong>.</p><p>Alternatively, we can start with a balanced and autonomous category and use the twist to define the pivotal structure. In particular, we can express the left unit and counit in terms of the right unit and counit, the braiding and the twist, as</p><p><span>$η&#39;_V = (\mathrm{id}_{V^*} ⊗ θ_V) ∘ σ_{V,V^*} ∘ η_V$</span></p><p><span>$ϵ&#39;_V = ϵ_V ∘ σ_{V,V^*} ∘ (θ_V ⊗ \mathrm{id}_{V^*})$</span></p><p>The trace of an endomorphism <span>$f:V→V$</span> is then given by</p><p><span>$tr(f) = ϵ_V ∘ σ_{V,V^*} ∘ (( θ_V ∘ f) ⊗ \mathrm{id}_{V^*}) ∘ η_V$</span></p><p>and it can be verified using the naturality of the braiding that the resulting category is spherical, i.e. that this is equal to</p><p><span>$tr(f) = ϵ_V ∘ (\mathrm{id}_{V^*} ⊗ (f ∘ θ_V)) ∘ σ_{V,V^*} ∘ η_V$</span></p><p>Note finally, that a ribbon category where the braiding is symmetric, is known as a <strong>compact closed category</strong>. For a symmetric braiding, the trivial twist <span>$θ_V = \mathrm{id}_V$</span> is always a valid choice, but it might not be the choice that one necessarily want to use. This brings us to the final paragraph.</p><h3 id="sss_adjoints-1"><a class="docs-heading-anchor" href="#sss_adjoints-1">Adjoints</a><a class="docs-heading-anchor-permalink" href="#sss_adjoints-1" title="Permalink"></a></h3><p>A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A <strong>dagger category</strong> <span>$C$</span> is a category together with an involutive functor <span>$†:C→C$</span> that acts as the identity on objects, whereas on morphisms <span>$f:W→V$</span> it defines a morphism <span>$f^†:V→W$</span> such that</p><ul><li><span>$\mathrm{id}_V^† = \mathrm{id}_V$</span></li><li><span>$(g ∘ f)^† = f^† ∘ g^†$</span></li><li><span>$(f^†)^† = f$</span></li></ul><p>In a dagger category, a morphism <span>$f:W→V$</span> is said to be unitary if it is an isomorphism and <span>$f^{-1} = f^†$</span>. Furthermore, an endomorphism <span>$f:V→V$</span> is hermitian or self-adjoint if <span>$f^† = f$</span>.</p><p>A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.</p><p>There is more to be said about the interplay between the dagger and duals. Given a right unit <span>$η_V: I → V ⊗ V^*$</span> and co-unit <span>$ϵ_V: V^* ⊗ V → I$</span>, we can define a left unit and co-unit <span>$η&#39;_V = (ϵ_V)^†$</span> and <span>$ϵ&#39;_V = (η_V)^†$</span>, and from this, a unitary pivotal structure. Hence, right autonomous dagger categories are automatically pivotal dagger categories.</p><p>The twist defined via the pivotal structure now becomes</p><p><span>$θ_V = ρ_V ∘ (\mathrm{id}_V ⊗ (η_V)^†) ∘ (σ_{V,V} ⊗ \mathrm{id}_{V^*}) ∘ (\mathrm{id}_V ⊗ η_V) ∘ ρ_V^{-1}$</span></p><p>and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity. We will return to this in the discussion of fermions.</p><h2 id="Bibliography-1"><a class="docs-heading-anchor" href="#Bibliography-1">Bibliography</a><a class="docs-heading-anchor-permalink" href="#Bibliography-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-tung"><a class="tag is-link" href="#citeref-tung">tung</a><pre><code class="language-none">    Tung, W. K. (1985). Group theory in physics: an introduction to symmetry
        principles, group representations, and special functions in classical and
        quantum physics.
        World Scientific Publishing Company.</code></pre></li><li class="footnote" id="footnote-selinger"><a class="tag is-link" href="#citeref-selinger">selinger</a><pre><code class="language-none">Selinger, P. (2010). A survey of graphical languages for monoidal
        categories.
        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.</code></pre></li><li class="footnote" id="footnote-beer"><a class="tag is-link" href="#citeref-beer">beer</a><pre><code class="language-none">    From categories to anyons: a travelogue
        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole
        Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan
        Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf
        [https://arxiv.org/pdf/1811.06670.pdf](https://arxiv.org/pdf/1811.06670.pdf)</code></pre></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../spaces/">Vector spaces »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 28 December 2019 02:50">Saturday 28 December 2019</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
