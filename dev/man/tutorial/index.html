<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · TensorKit.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TensorKit.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Cartesian-tensors-1"><span>Cartesian tensors</span></a></li><li><a class="tocitem" href="#Complex-tensors-1"><span>Complex tensors</span></a></li><li><a class="tocitem" href="#Symmetries-1"><span>Symmetries</span></a></li></ul></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../lib/sectors/">Symmetry sectors an fusion trees</a></li><li><a class="tocitem" href="../../lib/spaces/">Vector spaces</a></li><li><a class="tocitem" href="../../lib/tensors/">Tensors</a></li></ul></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Jutho/TensorKit.jl/blob/master/docs/src/man/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_tutorial-1"><a class="docs-heading-anchor" href="#s_tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#s_tutorial-1" title="Permalink"></a></h1><p>Before discussing at length all aspects of this package, both its usage and implementation, we start with a short tutorial to sketch the main capabilities. Thereto, we start by loading TensorKit.jl</p><pre><code class="language-julia-repl">julia&gt; using TensorKit</code></pre><h2 id="Cartesian-tensors-1"><a class="docs-heading-anchor" href="#Cartesian-tensors-1">Cartesian tensors</a><a class="docs-heading-anchor-permalink" href="#Cartesian-tensors-1" title="Permalink"></a></h2><p>The most important objects in TensorKit.jl are tensors, which we now create with random (normally distributed) entries in the following manner</p><pre><code class="language-julia-repl">julia&gt; A = Tensor(randn, ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)
TensorMap((ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4) ← ProductSpace{CartesianSpace,0}()):
[:, :, 1] =
 0.8135283366003037     0.41264469149974947
 0.035976272065243994  -0.43244516521994397
 0.8368417145727446     0.7315268800773407

[:, :, 2] =
  0.5337764523813969  -0.002113251464269584
 -1.0001872893380352   1.2033081032213149
  0.4097721146128895  -0.30307074099520714

[:, :, 3] =
  0.08512471962293493   2.068429897017294
 -1.3127158525986737   -1.3572643491409364
 -1.3395289805560167   -1.701216441652953

[:, :, 4] =
 -0.7777121975427408    0.26308131564737197
  0.40039816386876637  -1.4610163848090416
  1.7310463877431563   -1.0012235512936454

julia&gt; space(A)
(ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)</code></pre><p>Note that we entered the tensor size not as plain dimensions, by specifying the vector space associated with these tensor indices, in this case <code>ℝ^n</code>, which can be obtained by typing <code>\bbR+TAB</code>. The tensor then lives in the tensor product of the different spaces, which we can obtain by typing <code>⊗</code> (i.e. <code>\otimes+TAB</code>), although for simplicity also the usual multiplication sign <code>*</code> does the job. Note also that <code>A</code> is printed as an instance of a parametric type <code>TensorMap</code>, which we will discuss below and contains <code>Tensor</code>.</p><p>Briefly sidetracking into the nature of <code>ℝ^n</code>:</p><pre><code class="language-julia-repl">julia&gt; V = ℝ^3
ℝ^3

julia&gt; typeof(V)
CartesianSpace

julia&gt; V == CartesianSpace(3)
true

julia&gt; supertype(CartesianSpace)
EuclideanSpace{ℝ}

julia&gt; supertype(EuclideanSpace)
InnerProductSpace

julia&gt; supertype(InnerProductSpace)
ElementarySpace

julia&gt; supertype(ElementarySpace)
VectorSpace</code></pre><p>i.e. <code>ℝ^n</code> can also be created without Unicode using the longer syntax <code>CartesianSpace(n)</code>. It is subtype of <code>EuclideanSpace{ℝ}</code>, a space with a standard (Euclidean) inner product over the real numbers. Furthermore,</p><pre><code class="language-julia-repl">julia&gt; W = ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4
(ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)

julia&gt; typeof(W)
ProductSpace{CartesianSpace,3}

julia&gt; supertype(ProductSpace)
CompositeSpace

julia&gt; supertype(CompositeSpace)
VectorSpace</code></pre><p>i.e. the tensor product of a number of <code>CartesianSpace</code>s is some generic parametric <code>ProductSpace</code> type, specifically <code>ProductSpace{CartesianSpace,N}</code> for the tensor product of <code>N</code> instances of <code>CartesianSpace</code>.</p><p>Tensors are itself vectors (but not <code>Vector</code>s), so we can compute linear combinations, provided they live in the same space.</p><pre><code class="language-julia-repl">julia&gt; B = Tensor(randn, ℝ^3 * ℝ^2 * ℝ^4);

julia&gt; C = 0.5*A + 2.5*B
TensorMap((ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4) ← ProductSpace{CartesianSpace,0}()):
[:, :, 1] =
 -1.8041849001433303  -4.011892303199329
 -6.573777102043514   -0.7829702409258998
 -0.6691865511468518  -2.035379016778553

[:, :, 2] =
  4.133397673998083   -0.43565781609408755
  1.2040962495532794   2.4135317136537773
 -2.157936491444717    0.3989264401236542

[:, :, 3] =
 -3.9573491504773632   2.2543095097565122
  0.729400445174375    0.7398522898903372
 -0.2588730849047051  -4.027496452094168

[:, :, 4] =
 -0.1515773512471228   2.7281557074344884
 -0.8291347197746638  -7.512274325968416
  3.2221513950300666  -0.6432430451483326</code></pre><p>Given that they are behave as vectors, they also have a scalar product and norm, which they inherit from the Euclidean inner product on the individual <code>ℝ^n</code> spaces:</p><pre><code class="language-julia-repl">julia&gt; scalarBA = dot(B,A)
5.086960528523854

julia&gt; scalarAA = dot(A,A)
24.756273526736535

julia&gt; normA² = norm(A)^2
24.756273526736532</code></pre><p>If two tensors live on different spaces, these operations have no meaning and are thus not allowed</p><pre><code class="language-julia-repl">julia&gt; B′ = Tensor(randn, ℝ^4 * ℝ^2 * ℝ^3);

julia&gt; space(B′) == space(A)
false

julia&gt; C′ = 0.5*A + 2.5*B′
ERROR: SpaceMismatch()

julia&gt; scalarBA′ = dot(B′,A)
ERROR: SpaceMismatch()</code></pre><p>However, in this particular case, we can reorder the indices of <code>B′</code> to match space of <code>A</code>, using the routine <code>permute</code> (we deliberately choose not to overload <code>permutedims</code> from Julia Base, for reasons that become clear below):</p><pre><code class="language-julia-repl">julia&gt; space(permute(B′,(3,2,1))) == space(A)
true</code></pre><p>We can contract two tensors using Einstein summation convention, which takes the interface from <a href="https://github.com/Jutho/TensorOperations.jl">TensorOperations.jl</a>. TensorKit.jl reexports the <code>@tensor</code> macro</p><pre><code class="language-julia-repl">julia&gt; @tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]
TensorMap((ℝ^3 ⊗ ℝ^2 ⊗ ℝ^2 ⊗ ℝ^3) ← ProductSpace{CartesianSpace,0}()):
[:, :, 1, 1] =
 -0.10393757752247851  -3.652648100501154
  0.5595911657482997    4.276394215863174
  2.2011644999244138    1.5111806395028806

[:, :, 2, 1] =
 -2.231670406936197     0.5868382041044783
 -0.11161225015612576  -1.6594002345278982
 -0.3390225399489651   -3.0517838264488066

[:, :, 1, 2] =
 -1.4137774510802306  -0.05124510403590528
 -1.669162622692776    1.8097102528905245
 -3.382409074041114   -2.666170093658471

[:, :, 2, 2] =
  2.3604330744536925  0.36487414086725717
 -2.5640320904751857  4.163338961271046
 -5.348589583103322   1.3652786508851003

[:, :, 1, 3] =
 -1.5775279859889204   0.41043309185570204
  1.0913371853325493  -2.5494534498516734
  0.6602630995192257  -1.2552154178990276

[:, :, 2, 3] =
 -0.7276318073231042  -3.0402704686548034
  1.3905172736629348   2.4884005451688984
  0.8899280958304732   1.4496204638443582

julia&gt; @tensor d = A[a,b,c]*A[a,b,c]
24.756273526736535

julia&gt; d ≈ scalarAA ≈ normA²
true</code></pre><p>We hope that the index convention is clear. The <code>:=</code> is to create a new tensor <code>D</code>, without the <code>:</code> the result would be written in an existing tensor <code>D</code>, which in this case would yield an error as no tensor <code>D</code> exists. If the contraction yields a scalar, regular assignment with <code>=</code> can be used.</p><p>Finally, we can factorize a tensor, creating a bipartition of a subset of its indices and its complement. With a plain Julia <code>Array</code>, one would apply <code>permutedims</code> and <code>reshape</code> to cast the array into a matrix before applying e.g. the singular value decomposition. With TensorKit.jl, one just specifies which indices go to the left (rows) and right (columns)</p><pre><code class="language-julia-repl">julia&gt; U, S, Vd = tsvd(A, (1,3), (2,));

julia&gt; @tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];

julia&gt; A ≈ A′
true

julia&gt; U
TensorMap((ℝ^3 ⊗ ℝ^4) ← ProductSpace(ℝ^2)):
[:, :, 1] =
  0.15735317495411      0.03521930663461847   …   0.013504167479494256
 -0.10539949939431904   0.23300432821992023      -0.33741801988183623
  0.23841190527662617  -0.048113898117824426     -0.13368011409358202

[:, :, 2] =
 0.2173417845546473    0.1652744399815432   …  -0.26240755633283386
 0.04705801141509661  -0.4093401662344239       0.24523549004326428
 0.19805783152652262   0.15192503598038512      0.618606817626525</code></pre><p>Note that the <code>tsvd</code> routine returns the decomposition of the linear map as three factors, <code>U</code>, <code>S</code> and <code>Vd</code>, each of them a <code>TensorMap</code>, such that <code>Vd</code> is already what is commonly called <code>V&#39;</code>. Furthermore, observe that <code>U</code> is printed differently then <code>A</code>, i.e. as a <code>TensorMap((ℝ^3 ⊗ ℝ^4) ← ProductSpace(ℝ^2))</code>. What this means is that tensors (or more appropriately, <code>TensorMap</code> instances) in TensorKit.jl are always considered to be linear maps between two <code>ProductSpace</code> instances, with</p><pre><code class="language-julia-repl">julia&gt; codomain(U)
(ℝ^3 ⊗ ℝ^4)

julia&gt; domain(U)
ProductSpace(ℝ^2)

julia&gt; codomain(A)
(ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)

julia&gt; domain(A)
ProductSpace{CartesianSpace,0}()</code></pre><p>Hence, a <code>Tensor</code> instance such as <code>A</code> is just a specific case of <code>TensorMap</code> with an empty domain, i.e. a <code>ProductSpace{CartesianSpace,0}</code> instance. In particular, we can represent a vector <code>v</code> and matrix <code>m</code> as</p><pre><code class="language-julia-repl">julia&gt; v = Tensor(randn, ℝ^3)
TensorMap(ProductSpace(ℝ^3) ← ProductSpace{CartesianSpace,0}()):
 -0.01637839109252872
  1.30969555683987
  1.4335767505528245

julia&gt; m1 = TensorMap(randn, ℝ^4, ℝ^3)
TensorMap(ProductSpace(ℝ^4) ← ProductSpace(ℝ^3)):
  0.8224665880049566   -0.7633271011353439   1.282746290770911
 -2.56895346785978     -0.09001466010136339  1.5543845461295958
  0.7776397129962046   -1.3345629194224433   0.5103486562595593
 -0.05574763386196614   0.9102572735039351   0.4330642798832241

julia&gt; m2 = TensorMap(randn, ℝ^4 → ℝ^2) # alternative syntax for TensorMap(randn, ℝ^2, ℝ^4)
TensorMap(ProductSpace(ℝ^2) ← ProductSpace(ℝ^4)):
 -0.9573040782809118   -1.0703443160250958   …  -1.1830374453068568
 -0.33054022803473987  -0.12931813837130363      0.25160549092568946

julia&gt; w = m1 * v # matrix vector product
TensorMap(ProductSpace(ℝ^4) ← ProductSpace{CartesianSpace,0}()):
  0.8257184670957505
  2.1525130709599014
 -1.0289836449497738
  1.813903846374644

julia&gt; m3 = m2*m1 # matrix matrix product
TensorMap(ProductSpace(ℝ^2) ← ProductSpace(ℝ^3)):
 2.601978985728331   -1.2343759256389548   -3.0275201405069545
 0.5813397585329373  -0.42519595685157485  -0.1649307265734922</code></pre><p>Note that for the construction of <code>m1</code>, in accordance with how one specifies the dimensions of a matrix (e.g. <code>randn(4,3)</code>), the first space is the codomain and the second the domain. This is somewhat opposite to the general notation for a function <code>f:domain→codomain</code>, so that we also support this more mathemical notation, as illustrated in the construction of <code>m2</code>. In fact, there is a third syntax which mixes both and reads as <code>TensorMap(randn, codomain←domain)</code>.</p><p>This &#39;matrix vector&#39; or &#39;matrix matrix&#39; product can be computed between any two <code>TensorMap</code> instances for which the domain of the first matches with the codomain of the second, e.g.</p><pre><code class="language-julia-repl">julia&gt; v′ = v ⊗ v
TensorMap((ℝ^3 ⊗ ℝ^3) ← ProductSpace{CartesianSpace,0}()):
  0.0002682516947798241  -0.02145070604207057  -0.02347968068171065
 -0.02145070604207057     1.7153024516060973    1.877549100587973
 -0.02347968068171065     1.877549100587973     2.055142299725595

julia&gt; m1′ = m1 ⊗ m1
TensorMap((ℝ^4 ⊗ ℝ^4) ← (ℝ^3 ⊗ ℝ^3)):
[:, :, 1, 1] =
  0.6764512883845151   -2.112878393454134    …  -0.04585056621180088
 -2.112878393454134     6.599521920028789        0.14321307733467523
  0.6395826814451422   -1.9977202374470837      -0.04335157399663685
 -0.04585056621180088   0.14321307733467523      0.0031077986812078342

[:, :, 2, 1] =
 -0.6278110364025007    1.9609518035729945   …   0.04255367975100915
 -0.07403405036399426   0.23124347322561684      0.005018104313540138
 -1.0976334108153107    3.4284300399273575       0.07439872499771899
  0.7486561939454762   -2.3384085794125222      -0.05074468920348895

[:, :, 3, 1] =
 1.0550159650463653  -3.2953155320602017  …  -0.0715100705556919
 1.2784293541028418  -3.993141570167275      -0.08665326055833113
 0.4197447180067142  -1.3110619503155736     -0.028450730031104324
 0.3561809006623789  -1.1125219836122069     -0.024142308913626006

[:, :, 1, 2] =
 -0.6278110364025007   -0.07403405036399426   …   0.7486561939454762
  1.9609518035729945    0.23124347322561684      -2.3384085794125222
 -0.5935934678491136   -0.06999897444667513       0.7078522049203079
  0.04255367975100915   0.005018104313540138     -0.05074468920348895

[:, :, 2, 2] =
  0.5826682633276875    0.06871062955485702   …  -0.6948240458711207
  0.06871062955485702   0.008102639033163982     -0.08193649907925049
  1.018708044565455     0.12013022757569444      -1.214795604352925
 -0.6948240458711207   -0.08193649907925049       0.8285683039668178

[:, :, 3, 2] =
 -0.9791550076262744   -0.1154659713600282    …  1.1676291412344155
 -1.1865038496466815   -0.13991739658666755      1.4148898389365776
 -0.3895629603509274   -0.045938860826391766     0.46454857638322344
 -0.33056970136852665  -0.03898213395573012      0.3941999106584486

[:, :, 1, 3] =
  1.0550159650463653   1.2784293541028418   …   0.3561809006623789
 -3.2953155320602017  -3.993141570167275       -1.1125219836122069
  0.9975144574020373   1.2087511523379546       0.33676798231729843
 -0.0715100705556919  -0.08665326055833113     -0.024142308913626006

[:, :, 2, 3] =
 -0.9791550076262744  -1.1865038496466815   …  -0.33056970136852665
 -0.1154659713600282  -0.13991739658666755     -0.03898213395573012
 -1.7119056346895374  -2.074423977787843       -0.5779515296585337
  1.1676291412344155   1.4148898389365776       0.3941999106584486

[:, :, 3, 3] =
 1.6454380464865308  1.993881010979365   …  0.5555115986855814
 1.993881010979365   2.4161113172465094     0.6731484241312256
 0.6546478458168684  0.7932780644278641     0.22101377331241712
 0.5555115986855814  0.6731484241312256     0.18754467051077545

julia&gt; w′ = m1′ * v′
TensorMap((ℝ^4 ⊗ ℝ^4) ← ProductSpace{CartesianSpace,0}()):
  0.6818109869029565   1.7773697933565757  …   1.4977739034875568
  1.7773697933565757   4.6333125206532255      3.904451738785862
 -0.8496507979745251  -2.214900745558351      -1.8664773914309958
  1.4977739034875568   3.9044517387858626      3.2902471638927273

julia&gt; w′ ≈ w ⊗ w
true</code></pre><p>Another example involves checking that <code>U</code> from the singular value decomposition is a unitary, or at least a left isometric tensor</p><pre><code class="language-julia-repl">julia&gt; codomain(U)
(ℝ^3 ⊗ ℝ^4)

julia&gt; domain(U)
ProductSpace(ℝ^2)

julia&gt; U&#39;*U # should be the identity on the corresponding domain = codomain
TensorMap(ProductSpace(ℝ^2) ← ProductSpace(ℝ^2)):
  1.0000000000000002      -1.2845051849098208e-16
 -1.2845051849098208e-16   1.0

julia&gt; U&#39;*U ≈ one(U&#39;*U)
true

julia&gt; P = U*U&#39; # should be a projector
TensorMap((ℝ^3 ⊗ ℝ^4) ← (ℝ^3 ⊗ ℝ^4)):
[:, :, 1, 1] =
  0.07199747298153748    0.041462911445498116  …  -0.054907202945991794
 -0.006357273689719833  -0.052302751395831695      0.00020612232700055892
  0.08056111279113377    0.025448783810247653      0.11341411929976741

[:, :, 2, 1] =
 -0.006357273689719833   0.004065389194971353  …  -0.01377171027339384
  0.013323510910916422  -0.04382127376640626       0.047103984872010674
 -0.015808287768977827   0.012220470852931889      0.0432002237897646

[:, :, 3, 1] =
  0.08056111279113377    0.041130599186785965  …  -0.04875231728549402
 -0.015808287768977827  -0.025522019852484753     -0.03187366362338206
  0.0960671412066194     0.018619017060308007      0.09064899416798494

[:, :, 1, 2] =
 0.041462911445498116   0.028556040071036008  …  -0.04289365450452882
 0.004065389194971353  -0.05944721585357555       0.028647529574235636
 0.041130599186785965   0.0234147871096355        0.09753177442277591

[:, :, 2, 2] =
 -0.052302751395831695  -0.05944721585357555  …   0.11056048220218001
 -0.04382127376640626    0.2218503886620421      -0.17900459531275315
 -0.025522019852484753  -0.07339976599236704     -0.28436866274172706

[:, :, 3, 2] =
 0.025448783810247653   0.0234147871096355   …  -0.04051601557566514
 0.012220470852931889  -0.07339976599236704      0.05349190688020303
 0.018619017060308007   0.0253961637497337       0.1004137344154991

[:, :, 1, 3] =
  0.050408172194449215  -0.005690343263143158  …   0.04522861279813076
 -0.061799538064886674   0.1810505131154932       -0.2116056696985797
  0.09547543138095994   -0.04719430595804141      -0.15972121621894483

[:, :, 2, 3] =
 -0.13081301768706147   -0.06348104619464362   …   0.07119630041304148
  0.031129302986108272   0.020717415480015787      0.07191656789495512
 -0.1597113426664863    -0.024043209010552343     -0.12442593060490637

[:, :, 3, 3] =
 -0.14017953601605967  -0.06321175137681026   …   0.06469131329720934
  0.04131084126097008  -0.007983729435411254      0.10642963289085917
 -0.17656515300790812  -0.016749457255861473     -0.10017507189862922

[:, :, 1, 4] =
 -0.054907202945991794  -0.04289365450452882  …   0.0690400881598836
 -0.01377171027339384    0.11056048220218001     -0.06890819511942163
 -0.04875231728549402   -0.04051601557566514     -0.16413234199360507

[:, :, 2, 4] =
  0.00020612232700055892   0.028647529574235636  …  -0.06890819511942163
  0.047103984872010674    -0.17900459531275315       0.1739913657177392
 -0.03187366362338206      0.05349190688020303       0.19681042545977948

[:, :, 3, 4] =
 0.11341411929976741   0.09753177442277591  …  -0.16413234199360507
 0.0432002237897646   -0.28436866274172706      0.19681042545977948
 0.09064899416798494   0.1004137344154991       0.4005447677180899

julia&gt; P*P ≈ P
true</code></pre><p>Here, the adjoint of a <code>TensorMap</code> results in a new tensor map (actually a simple wrapper of type <code>AdjointTensorMap &lt;: AbstractTensorMap</code>) with domain and codomain interchanged.</p><p>Our original tensor <code>A</code> living in <code>ℝ^4 * ℝ^2 * ℝ^3</code> is isomorphic to e.g. a linear map <code>ℝ^3 → ℝ^4 * ℝ^2</code>. This is where the full power of <code>permute</code> emerges. It allows to specify a permutation where some indices go to the codomain, and others go to the domain, as in</p><pre><code class="language-julia-repl">julia&gt; A2 = permute(A,(1,2),(3,))
TensorMap((ℝ^3 ⊗ ℝ^2) ← ProductSpace(ℝ^4)):
[:, :, 1] =
 0.8135283366003037     0.41264469149974947
 0.035976272065243994  -0.43244516521994397
 0.8368417145727446     0.7315268800773407

[:, :, 2] =
  0.5337764523813969  -0.002113251464269584
 -1.0001872893380352   1.2033081032213149
  0.4097721146128895  -0.30307074099520714

[:, :, 3] =
  0.08512471962293493   2.068429897017294
 -1.3127158525986737   -1.3572643491409364
 -1.3395289805560167   -1.701216441652953

[:, :, 4] =
 -0.7777121975427408    0.26308131564737197
  0.40039816386876637  -1.4610163848090416
  1.7310463877431563   -1.0012235512936454

julia&gt; codomain(A2)
(ℝ^3 ⊗ ℝ^2)

julia&gt; domain(A2)
ProductSpace(ℝ^4)</code></pre><p>In fact, <code>tsvd(A, (1,3),(2,))</code> is a shorthand for <code>tsvd(permute(A,(1,3),(2,)))</code>, where <code>tsvd(A::TensorMap)</code> will just compute the singular value decomposition according to the given codomain and domain of <code>A</code>.</p><p>Note, finally, that the <code>@tensor</code> macro treats all indices at the same footing and thus does not distinguish between codomain and domain. The linear numbering is first all indices in the codomain, followed by all indices in the domain. However, when <code>@tensor</code> creates a new tensor (i.e. when using <code>:=</code>), the default syntax always creates a <code>Tensor</code>, i.e. with all indices in the codomain.</p><pre><code class="language-julia-repl">julia&gt; @tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];

julia&gt; codomain(A′)
(ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)

julia&gt; domain(A′)
ProductSpace{CartesianSpace,0}()

julia&gt; @tensor A2′[(a,b);(c,)] := U[a,c,d]*S[d,e]*Vd[e,b];

julia&gt; codomain(A2′)
(ℝ^3 ⊗ ℝ^2)

julia&gt; domain(A2′)
ProductSpace(ℝ^4)

julia&gt; @tensor A2′′[a b; c] := U[a,c,d]*S[d,e]*Vd[e,b];

julia&gt; A2 ≈ A2′ == A2′′
true</code></pre><p>As illustrated for <code>A2′</code> and <code>A2′′</code>, additional syntax is available that enables one to immediately specify the desired codomain and domain indices.</p><h2 id="Complex-tensors-1"><a class="docs-heading-anchor" href="#Complex-tensors-1">Complex tensors</a><a class="docs-heading-anchor-permalink" href="#Complex-tensors-1" title="Permalink"></a></h2><p>For applications in e.g. quantum physics, we of course want to work with complex tensors. Trying to create a complex-valued tensor with <code>CartesianSpace</code> indices is of course somewhat contrived and prints a (one-time) warning</p><pre><code class="language-julia-repl">julia&gt; A = Tensor(randn, ComplexF64, ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)
┌ Warning: eltype(data) = Complex{Float64} ⊈ ℝ)
└ @ TensorKit ~/build/Jutho/TensorKit.jl/src/tensors/tensor.jl:30
TensorMap((ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4) ← ProductSpace{CartesianSpace,0}()):
[:, :, 1] =
  -1.5506655748593592 - 0.07889049147525605im  …   -0.7857501080464367 + 0.36081921935457384im
  0.37755706059928257 + 0.7489821708266768im         1.185264656148187 - 0.15878165085396231im
 -0.21644970520050938 + 0.18291488632791472im     -0.05124854355234553 + 0.7895366780642167im

[:, :, 2] =
   -0.146711595339337 - 0.28604272757664956im  …   0.49951417524027003 + 0.06404421558659554im
 -0.49891280496595675 + 0.02382142145020242im      0.47143144229787093 + 0.36373033020627016im
    0.949888568302484 - 0.00974020116631556im     -0.19496195394221988 - 0.6144711217779657im

[:, :, 3] =
  -0.6685148449737206 + 0.2181727306374178im   …    -1.1017413679744368 - 0.04005808691654481im
   0.3141353722778035 + 0.16001203945422718im     0.0035612003960369303 - 0.4113296174602802im
 -0.30860136264767446 + 0.32876055972537005im        0.8379035676568788 + 0.45859146890421904im

[:, :, 4] =
 -0.4022921935600513 + 1.061728658429958im   …   -0.3661526920014125 - 0.16978530699941302im
  0.3572716241393003 + 0.4117591971631516im       0.4459891605269683 - 0.4727699790431535im
 -0.3846251696611418 - 1.0367326192592736im     -0.20206508449840255 - 0.6295162251233128im</code></pre><p>although most of the above operations will work in the expected way (at your own risk). Indeed, we instead want to work with complex vector spaces</p><pre><code class="language-julia-repl">julia&gt; A = Tensor(randn, ComplexF64, ℂ^3 ⊗ ℂ^2 ⊗ ℂ^4)
TensorMap((ℂ^3 ⊗ ℂ^2 ⊗ ℂ^4) ← ProductSpace{ComplexSpace,0}()):
[:, :, 1] =
 -0.5533515556417652 - 0.12569020140860557im  …  -0.39321566373626193 + 1.0659055580956336im
 -0.5386013026917288 + 1.2747064712953207im        0.7558026040878334 + 0.06994751714486508im
 -1.1373239146930814 + 0.19371848210418582im      -0.2725597228837363 + 0.4148992719942941im

[:, :, 2] =
  -0.7522883090808733 - 0.7205885598277713im  …   0.6312817181920745 - 0.2809984890233486im
 -0.16950425607491318 + 1.0567781368661295im     -0.8971106257505755 + 0.37471671305938337im
  0.05810306881071732 - 0.2608174343197373im     -1.2822456444607824 - 0.3210566284460966im

[:, :, 3] =
   -0.570907644778549 + 0.10558444404420832im  …  -0.5941873211074532 + 0.06899219386622098im
 -0.27371046436957974 + 0.9121583367463229im       0.4913136894128952 + 0.24066850387782193im
  -0.2046267294367595 + 0.16845549486364012im     -0.2410363174287602 + 0.21819604174897245im

[:, :, 4] =
 0.05316061216594098 - 0.8647839977916958im  …  -0.20198706500298677 + 0.6771263489527499im
 -0.4740532637573812 - 0.3262936730231401im      0.23694212145507867 + 1.057706165562583im
  1.1614949102484573 - 0.1969995202087092im     -0.12293300605050446 + 0.22952163073276727im</code></pre><p>where <code>ℂ</code> is obtained as <code>\bbC+TAB</code> and we also have the non-Unicode alternative <code>ℂ^n == ComplexSpace(n)</code>. Most functionality works exactly the same</p><pre><code class="language-julia-repl">julia&gt; B = Tensor(randn, ℂ^3 * ℂ^2 * ℂ^4);

julia&gt; C = im*A + (2.5-0.8im)*B
TensorMap((ℂ^3 ⊗ ℂ^2 ⊗ ℂ^4) ← ProductSpace{ComplexSpace,0}()):
[:, :, 1] =
   4.156813448898991 - 1.8433109948386888im  …   0.8186923625495679 - 0.9962869983427265im
  2.8545739055125474 - 1.8599710232702464im       2.263922597923597 + 0.008964167265925527im
 -0.0724056798132417 - 1.1761440114261834im     -1.2294062557076237 - 0.01191748809547083im

[:, :, 2] =
 -0.09083705857953073 - 0.4926321111905367im   …    1.5744222491243682 + 0.2173861149597482im
  -0.6490624394508037 - 0.29997327924781747im     -0.10371244708896582 - 0.9838319908611092im
  0.24598112701312894 + 0.062850687148832im          -1.14774722284688 - 0.8122284120470298im

[:, :, 3] =
 0.9489051922444133 - 0.9083443283909081im  …  -0.14346281075580464 - 0.5703567237027865im
 -5.177274534679084 + 1.0911267189689038im       4.8558640142296285 - 1.1395767163814892im
 -4.500448602710974 + 1.1816110650743876im       -3.834013763086826 + 0.916025353399353im

[:, :, 4] =
 -0.8897269481156191 + 0.6146041148562817im   …  0.20663520813087866 - 0.4847907632697479im
  -1.957164341940758 + 0.2566533010310662im       -5.823320173853938 + 1.7619386041083125im
   4.971549762676838 - 0.36636116734134405im     -3.3989940971370474 + 0.8912981831988651im

julia&gt; scalarBA = dot(B,A)
4.055147957978904 - 0.032247725696594565im

julia&gt; scalarAA = dot(A,A)
17.442203592974366 + 0.0im

julia&gt; normA² = norm(A)^2
17.44220359297436

julia&gt; U,S,Vd = tsvd(A,(1,3),(2,));

julia&gt; @tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];

julia&gt; A′ ≈ A
true

julia&gt; permute(A,(1,3),(2,)) ≈ U*S*Vd
true</code></pre><p>However, trying the following</p><pre><code class="language-julia-repl">julia&gt; @tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]
ERROR: SpaceMismatch()

julia&gt; @tensor d = A[a,b,c]*A[a,b,c]
ERROR: SpaceMismatch()</code></pre><p>we obtain <code>SpaceMismatch</code> errors. The reason for this is that, with <code>ComplexSpace</code>, an index in a space <code>ℂ^n</code> can only be contracted with an index in the dual space <code>dual(ℂ^n) == (ℂ^n)&#39;</code>. Because of the complex Euclidean inner product, the dual space is equivalent to the complex conjugate space, but not the the space itself.</p><pre><code class="language-julia-repl">julia&gt; dual(ℂ^3) == conj(ℂ^3) == (ℂ^3)&#39;
true

julia&gt; (ℂ^3)&#39; == ℂ^3
false

julia&gt; @tensor d = conj(A[a,b,c])*A[a,b,c]
17.44220359297436 + 0.0im

julia&gt; d ≈ normA²
true</code></pre><p>This might seem overly strict or puristic, but we believe that it can help to catch errors, e.g. unintended contractions. In particular, contracting two indices both living in <code>ℂ^n</code> would represent an operation that is not invariant under arbitrary unitary basis changes.</p><p>It also makes clear the isomorphism between linear maps <code>ℂ^n → ℂ^m</code> and tensors in <code>ℂ^m ⊗ (ℂ^n)&#39;</code>:</p><pre><code class="language-julia-repl">julia&gt; m = TensorMap(randn, ComplexF64, ℂ^3, ℂ^4)
TensorMap(ProductSpace(ℂ^3) ← ProductSpace(ℂ^4)):
 -0.038812326522601345 + 0.17468982668923944im  …   -0.03515832033062683 + 0.27763660863113937im
    0.9164024673546062 - 0.47137106293240183im     0.0021351624494740417 - 0.47056096136753917im
  -0.05093726100583313 + 0.4107621603223372im       -0.31853094321391007 - 0.10883123241922463im

julia&gt; m2 = permute(m, (1,2), ())
TensorMap((ℂ^3 ⊗ (ℂ^4)&#39;) ← ProductSpace{ComplexSpace,0}()):
 -0.038812326522601345 + 0.17468982668923944im  …   -0.03515832033062683 + 0.27763660863113937im
    0.9164024673546062 - 0.47137106293240183im     0.0021351624494740417 - 0.47056096136753917im
  -0.05093726100583313 + 0.4107621603223372im       -0.31853094321391007 - 0.10883123241922463im

julia&gt; codomain(m2)
(ℂ^3 ⊗ (ℂ^4)&#39;)

julia&gt; space(m, 1)
ℂ^3

julia&gt; space(m, 2)
(ℂ^4)&#39;</code></pre><p>Hence, spaces become their corresponding dual space if they are &#39;permuted&#39; from the domain to the codomain or vice versa. Also, spaces in the domain are reported as their dual when probing them with <code>space(A, i)</code>. Generalizing matrix vector and matrix matrix multiplication to arbitrary tensor contractions require that the two indices to be contracted have spaces which are each others dual. Knowing this, all the other functionality of tensors with <code>CartesianSpace</code> indices remains the same for tensors with <code>ComplexSpace</code> indices.</p><h2 id="Symmetries-1"><a class="docs-heading-anchor" href="#Symmetries-1">Symmetries</a><a class="docs-heading-anchor-permalink" href="#Symmetries-1" title="Permalink"></a></h2><p>So far, the functionality that we have illustrated seems to be just a convenience (or inconvenience?) wrapper around dense multidimensional arrays, e.g. Julia&#39;s Base <code>Array</code>. More power becomes visible when involving symmetries. With symmetries, we imply that there is some symmetry action defined on every vector space associated with each of the indices of a <code>TensorMap</code>, and the <code>TensorMap</code> is then required to be equivariant, i.e. it acts as an intertwiner between the tensor product representation on the domain and that on the codomain. By Schur&#39;s lemma, this means that the tensor is block diagonal in some basis corresponding to the so-called irreducible representations that can be coupled to by combining the different representations on the different spaces in the domain or codomain. For Abelian symmetries, this does not require a basis change and it just imposes that the tensor has some block sparsity. Let&#39;s clarify all of this with some examples.</p><p>We start with a simple <span>$ℤ₂$</span> symmetry:</p><pre><code class="language-julia-repl">julia&gt; V1 = ℤ₂Space(0=&gt;3,1=&gt;2)
ℤ₂Space(0=&gt;3, 1=&gt;2)

julia&gt; dim(V1)
5

julia&gt; V2 = ℤ₂Space(0=&gt;1,1=&gt;1)
ℤ₂Space(0=&gt;1, 1=&gt;1)

julia&gt; dim(V2)
2

julia&gt; A = Tensor(randn, V1*V1*V2&#39;)
TensorMap((ℤ₂Space(0=&gt;3, 1=&gt;2) ⊗ ℤ₂Space(0=&gt;3, 1=&gt;2) ⊗ ℤ₂Space(0=&gt;1, 1=&gt;1)&#39;) ← ProductSpace{ℤ₂Space,0}()):
* Data for sector (ℤ₂(1), ℤ₂(1), ℤ₂(0)) ← ():
[:, :, 1] =
 0.08646321606889258  -0.7889230252899841
 0.41301415298799987  -1.1499189483440977
* Data for sector (ℤ₂(0), ℤ₂(1), ℤ₂(1)) ← ():
[:, :, 1] =
 0.8962712234986719   0.22341478607341625
 0.8130800697803418   0.4935209959464218
 2.0278002745507386  -1.376941286872427
* Data for sector (ℤ₂(0), ℤ₂(0), ℤ₂(0)) ← ():
[:, :, 1] =
 -1.1701695180167533  -0.8797713222815626      0.9547155059187267
  0.8393811627999189  -0.12146793858946282    -0.5962323395502742
 -0.820648273096578   -0.0026545452580563496   0.5420390700820151
* Data for sector (ℤ₂(1), ℤ₂(0), ℤ₂(1)) ← ():
[:, :, 1] =
  1.4141270889837054   0.705490838183059   0.5698324253178383
 -0.14090481581103134  1.3230236455007516  1.0420966073549849

julia&gt; convert(Array, A)
5×5×2 Array{Float64,3}:
[:, :, 1] =
 -1.17017   -0.879771     0.954716  0.0         0.0
  0.839381  -0.121468    -0.596232  0.0         0.0
 -0.820648  -0.00265455   0.542039  0.0         0.0
  0.0        0.0          0.0       0.0864632  -0.788923
  0.0        0.0          0.0       0.413014   -1.14992

[:, :, 2] =
  0.0       0.0       0.0       0.896271   0.223415
  0.0       0.0       0.0       0.81308    0.493521
  0.0       0.0       0.0       2.0278    -1.37694
  1.41413   0.705491  0.569832  0.0        0.0
 -0.140905  1.32302   1.0421    0.0        0.0</code></pre><p>Here, we create a space 5-dimensional space <code>V1</code>, which has a three-dimensional subspace associated with charge 0 (the trivial irrep of <span>$ℤ₂$</span>) and a two-dimensional subspace with charge 1 (the non-trivial irrep). Similar for <code>V2</code>, where both subspaces are one- dimensional. Representing the tensor as a dense <code>Array</code>, we see that it is zero in those regions where the charges don&#39;t add to zero (modulo 2). Of course, the <code>Tensor(Map)</code> type in TensorKit.jl won&#39;t store these zero blocks, and only stores the non-zero information, which we can recognize also in the full <code>Array</code> representation.</p><p>From there on, the resulting tensors support all of the same operations as the ones we encountered in the previous examples.</p><pre><code class="language-julia-repl">julia&gt; B = Tensor(randn, V1&#39;*V1*V2);

julia&gt; @tensor C[a,b] := A[a,c,d]*B[c,b,d]
TensorMap((ℤ₂Space(0=&gt;3, 1=&gt;2) ⊗ ℤ₂Space(0=&gt;3, 1=&gt;2)) ← ProductSpace{ℤ₂Space,0}()):
* Data for sector (ℤ₂(1), ℤ₂(1)) ← ():
  0.6040939778409857  -0.4277109690535779
 -0.7023403240673884   1.4334214598077937
* Data for sector (ℤ₂(0), ℤ₂(0)) ← ():
 3.1765400592927686  -0.10727050529257268   1.487732950993209
 1.073476102685183   -0.8177740289465926   -0.03283560917368566
 3.332609025223469   -0.3399832751200449    2.8830072028203384

julia&gt; U,S,V = tsvd(A,(1,3),(2,));

julia&gt; U&#39;*U # should be the identity on the corresponding domain = codomain
TensorMap(ProductSpace(ℤ₂Space(0=&gt;3, 1=&gt;2)) ← ProductSpace(ℤ₂Space(0=&gt;3, 1=&gt;2))):
* Data for sector (ℤ₂(0),) ← (ℤ₂(0),):
  1.0000000000000009      -1.8953803278250054e-16   2.647329851860778e-16
 -1.8953803278250054e-16   1.0000000000000007      -3.6099092170741356e-16
  2.647329851860778e-16   -3.6099092170741356e-16   1.0000000000000004
* Data for sector (ℤ₂(1),) ← (ℤ₂(1),):
  1.0                    -1.670983519503687e-18
 -1.670983519503687e-18   1.0000000000000002

julia&gt; U&#39;*U ≈ one(U&#39;*U)
true

julia&gt; P = U*U&#39; # should be a projector
TensorMap((ℤ₂Space(0=&gt;3, 1=&gt;2) ⊗ ℤ₂Space(0=&gt;1, 1=&gt;1)&#39;) ← (ℤ₂Space(0=&gt;3, 1=&gt;2) ⊗ ℤ₂Space(0=&gt;1, 1=&gt;1)&#39;)):
* Data for sector (ℤ₂(0), ℤ₂(0)) ← (ℤ₂(0), ℤ₂(0)):
[:, :, 1, 1] =
  0.8788520403169653
 -0.1690526074397229
  0.208578215616615

[:, :, 2, 1] =
 -0.1690526074397229
  0.22786481261746577
 -0.20289682064643616

[:, :, 3, 1] =
  0.208578215616615
 -0.20289682064643616
  0.18589269203536612
* Data for sector (ℤ₂(1), ℤ₂(1)) ← (ℤ₂(0), ℤ₂(0)):
[:, :, 1, 1] =
  0.10597589627386077
 -0.15217287815062552

[:, :, 2, 1] =
  0.17317462969215505
 -0.27605630496088474

[:, :, 3, 1] =
 -0.15915775488670578
  0.20330621309834795
* Data for sector (ℤ₂(0), ℤ₂(0)) ← (ℤ₂(1), ℤ₂(1)):
[:, :, 1, 1] =
  0.10597589627386077
  0.17317462969215505
 -0.15915775488670578

[:, :, 2, 1] =
 -0.15217287815062552
 -0.27605630496088474
  0.20330621309834795
* Data for sector (ℤ₂(1), ℤ₂(1)) ← (ℤ₂(1), ℤ₂(1)):
[:, :, 1, 1] =
 0.9061030245173163
 0.13612053326830847

[:, :, 2, 1] =
 0.13612053326830847
 0.8012874305128886
* Data for sector (ℤ₂(1), ℤ₂(0)) ← (ℤ₂(1), ℤ₂(0)):
[:, :, 1, 1] =
 0.19854647247214263
 0.25774922231069364

[:, :, 2, 1] =
 0.25774922231069364
 0.35042906921228395
* Data for sector (ℤ₂(0), ℤ₂(1)) ← (ℤ₂(1), ℤ₂(0)):
[:, :, 1, 1] =
 -0.15776524592944538
 -0.21983265190468557
  0.13955228938508668

[:, :, 2, 1] =
 -0.1540388726276074
 -0.23756836388772498
  0.2846527239652805
* Data for sector (ℤ₂(1), ℤ₂(0)) ← (ℤ₂(0), ℤ₂(1)):
[:, :, 1, 1] =
 -0.15776524592944538
 -0.1540388726276074

[:, :, 2, 1] =
 -0.21983265190468557
 -0.23756836388772498

[:, :, 3, 1] =
 0.13955228938508668
 0.2846527239652805
* Data for sector (ℤ₂(0), ℤ₂(1)) ← (ℤ₂(0), ℤ₂(1)):
[:, :, 1, 1] =
 0.2882453028307709
 0.3280841597879327
 0.221139967485418

[:, :, 2, 1] =
 0.3280841597879327
 0.38787758252736376
 0.15819047137106906

[:, :, 3, 1] =
 0.221139967485418
 0.15819047137106906
 0.774901572957439

julia&gt; P*P ≈ P
true</code></pre><p>We also support other abelian symmetries, e.g.</p><pre><code class="language-julia-repl">julia&gt; V = U₁Space(0=&gt;2,1=&gt;1,-1=&gt;1)
U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1)

julia&gt; dim(V)
4

julia&gt; A = TensorMap(randn, V*V, V)
TensorMap((U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1) ⊗ U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1)) ← ProductSpace(U₁Space(0=&gt;2, 1=&gt;1, -1=&gt;1))):
* Data for sector (U₁(1), U₁(-1)) ← (U₁(0),):
[:, :, 1] =
 0.9647536779345111

[:, :, 2] =
 -1.4472349543217773
* Data for sector (U₁(-1), U₁(1)) ← (U₁(0),):
[:, :, 1] =
 0.06455880280942182

[:, :, 2] =
 -0.6766971810358078
* Data for sector (U₁(0), U₁(0)) ← (U₁(0),):
[:, :, 1] =
 -1.7748725454799967   0.8736989899657203
 -1.5258920329077872  -1.340078579652218

[:, :, 2] =
  0.7195317827261184  -0.6826004955429656
 -1.0195720131254316   0.9761817639870202
* Data for sector (U₁(1), U₁(0)) ← (U₁(1),):
[:, :, 1] =
 -0.16103348500081113  -1.1058581956305424
* Data for sector (U₁(0), U₁(1)) ← (U₁(1),):
[:, :, 1] =
  0.23628796162869034
 -1.2197014146397476
* Data for sector (U₁(-1), U₁(0)) ← (U₁(-1),):
[:, :, 1] =
 -0.3970428258702469  -0.4328394109792085
* Data for sector (U₁(0), U₁(-1)) ← (U₁(-1),):
[:, :, 1] =
 -0.93635035827048
 -2.539444763397372

julia&gt; dim(A)
20

julia&gt; convert(Array, A)
4×4×4 Array{Float64,3}:
[:, :, 1] =
 -1.77487   0.873699  0.0        0.0
 -1.52589  -1.34008   0.0        0.0
  0.0       0.0       0.0        0.964754
  0.0       0.0       0.0645588  0.0

[:, :, 2] =
  0.719532  -0.6826     0.0        0.0
 -1.01957    0.976182   0.0        0.0
  0.0        0.0        0.0       -1.44723
  0.0        0.0       -0.676697   0.0

[:, :, 3] =
  0.0        0.0       0.236288  0.0
  0.0        0.0      -1.2197    0.0
 -0.161033  -1.10586   0.0       0.0
  0.0        0.0       0.0       0.0

[:, :, 4] =
  0.0        0.0       0.0  -0.93635
  0.0        0.0       0.0  -2.53944
  0.0        0.0       0.0   0.0
 -0.397043  -0.432839  0.0   0.0

julia&gt; V = RepresentationSpace{U₁×ℤ₂}((0,0)=&gt;2,(1,1)=&gt;1,(-1,0)=&gt;1)
TensorKit.GenericRepresentationSpace{(U₁ × ℤ₂)}((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1)

julia&gt; dim(V)
4

julia&gt; A = TensorMap(randn, V*V, V)
TensorMap((TensorKit.GenericRepresentationSpace{(U₁ × ℤ₂)}((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1) ⊗ TensorKit.GenericRepresentationSpace{(U₁ × ℤ₂)}((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1)) ← ProductSpace(TensorKit.GenericRepresentationSpace{(U₁ × ℤ₂)}((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1))):
* Data for sector ((U₁(0) × ℤ₂(0)), (U₁(0) × ℤ₂(0))) ← ((U₁(0) × ℤ₂(0)),):
[:, :, 1] =
 -0.37469145297819034  -1.1022108573295164
 -0.9364378194798476   -1.6779899321373608

[:, :, 2] =
 -0.6606656493037198  -0.3090097269754397
 -0.6116145788986054   0.5594071258678165
* Data for sector ((U₁(-1) × ℤ₂(0)), (U₁(0) × ℤ₂(0))) ← ((U₁(-1) × ℤ₂(0)),):
[:, :, 1] =
 0.7324160920588202  -1.2324268257678161
* Data for sector ((U₁(0) × ℤ₂(0)), (U₁(-1) × ℤ₂(0))) ← ((U₁(-1) × ℤ₂(0)),):
[:, :, 1] =
  1.136630667344161
 -0.004823756791366827
* Data for sector ((U₁(1) × ℤ₂(1)), (U₁(0) × ℤ₂(0))) ← ((U₁(1) × ℤ₂(1)),):
[:, :, 1] =
 0.5354920397493369  -0.16308585094597822
* Data for sector ((U₁(0) × ℤ₂(0)), (U₁(1) × ℤ₂(1))) ← ((U₁(1) × ℤ₂(1)),):
[:, :, 1] =
  0.660563243826645
 -1.482960070197329

julia&gt; dim(A)
16

julia&gt; convert(Array, A)
4×4×4 Array{Float64,3}:
[:, :, 1] =
 -0.374691  -1.10221  0.0  0.0
 -0.936438  -1.67799  0.0  0.0
  0.0        0.0      0.0  0.0
  0.0        0.0      0.0  0.0

[:, :, 2] =
 -0.660666  -0.30901   0.0  0.0
 -0.611615   0.559407  0.0  0.0
  0.0        0.0       0.0  0.0
  0.0        0.0       0.0  0.0

[:, :, 3] =
 0.0        0.0       1.13663     0.0
 0.0        0.0      -0.00482376  0.0
 0.732416  -1.23243   0.0         0.0
 0.0        0.0       0.0         0.0

[:, :, 4] =
 0.0        0.0       0.0   0.660563
 0.0        0.0       0.0  -1.48296
 0.0        0.0       0.0   0.0
 0.535492  -0.163086  0.0   0.0</code></pre><p>Here, the <code>dim</code> of a <code>TensorMap</code> returns the number of linearly independent components, i.e. the number of non-zero entries in the case of an abelian symmetry. Also note that we can use <code>×</code> (obtained as <code>\times+TAB</code>) to combine different symmetries. The general space associated with symmetries is a <code>RepresentationSpace</code>. Although this is actually an abstract type, it is the access point for users to construct spaces with arbitrary symmetries, and <code>ℤ₂Space</code> (also <code>Z2Space</code> as non-Unicode alternative) and <code>U₁Space</code> (or <code>U1Space</code>) are just convenient synonyms, e.g.</p><pre><code class="language-julia-repl">julia&gt; RepresentationSpace{U₁}(0=&gt;3,1=&gt;2,-1=&gt;1) == U1Space(-1=&gt;1,1=&gt;2,0=&gt;3)
true

julia&gt; V = U₁Space(1=&gt;2,0=&gt;3,-1=&gt;1)
U₁Space(0=&gt;3, 1=&gt;2, -1=&gt;1)

julia&gt; for s in sectors(V)
         @show s, dim(V, s)
       end
(s, dim(V, s)) = (U₁(0), 3)
(s, dim(V, s)) = (U₁(1), 2)
(s, dim(V, s)) = (U₁(-1), 1)

julia&gt; U₁Space(-1=&gt;1,0=&gt;3,1=&gt;2) == RepresentationSpace(U₁(1)=&gt;2, U₁(0)=&gt;3, U₁(-1)=&gt;1)
true

julia&gt; supertype(RepresentationSpace)
EuclideanSpace{ℂ}</code></pre><p>Note also that the order in which the charges and their corresponding subspace dimensionality are specified is irrelevant, and that the charges, henceforth called sectors (which is a more general name for charges or quantum numbers) are of a specific type, in this case <code>U₁</code>. However, the <code>RepresentationSpace{G}</code> constructor automatically converts the keys in the list of <code>Pair</code>s it receives to the correct type. Alternatively, we can directly create the sectors of the correct type and use the generic <code>RepresentationSpace</code> constructor. We can probe the subspace dimension of a certain sector <code>s</code> in a space <code>V</code> with <code>dim(V, s)</code>. Finally, note that <code>RepresentationSpace</code> is also a subtype of <code>EuclideanSpace{ℂ}</code>, which implies that it still has the standard Euclidean inner product and we assume all representations to be unitary.</p><p>TensorKit.jl also allows for non-abelian symmetries such as <code>SU₂</code>. In this case, the vector space is characterized via the spin quantum number (i.e. the irrep label of <code>SU₂</code>) for each of its subspaces, and is created using <code>SU₂Space</code> (or <code>SU2Space</code> or <code>RepresentationSpace{SU₂}</code>)</p><pre><code class="language-julia-repl">julia&gt; V = SU₂Space(0=&gt;2,1/2=&gt;1,1=&gt;1)
SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1)

julia&gt; dim(V)
7

julia&gt; V == RepresentationSpace{SU₂}(0=&gt;2, 1=&gt;1, 1//2=&gt;1)
true</code></pre><p>Note that now <code>V</code> has a two-dimensional subspace with spin zero, and two one-dimensional subspaces with spin 1/2 and spin 1. However, a subspace with spin <code>j</code> has an additional <code>2j+1</code> dimensional degeneracy on which the irreducible representation acts. This brings the total dimension to <code>2*1 + 1*2 + 1*3</code>. Creating a tensor with <code>SU₂</code> symmetry yields</p><pre><code class="language-julia-repl">julia&gt; A = TensorMap(randn, V*V, V)
TensorMap((SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1) ⊗ SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1)) ← ProductSpace(SU₂Space(0=&gt;2, 1/2=&gt;1, 1=&gt;1))):
* Data for fusiontree FusionTree{SU₂}((1/2, 1/2), 0, (false, false), ()) ← FusionTree{SU₂}((0,), 0, (false,), ()):
[:, :, 1] =
 0.09201318512679975

[:, :, 2] =
 0.8994484277211257
* Data for fusiontree FusionTree{SU₂}((1, 1), 0, (false, false), ()) ← FusionTree{SU₂}((0,), 0, (false,), ()):
[:, :, 1] =
 1.3194180545277858

[:, :, 2] =
 -1.0931807088735634
* Data for fusiontree FusionTree{SU₂}((0, 0), 0, (false, false), ()) ← FusionTree{SU₂}((0,), 0, (false,), ()):
[:, :, 1] =
 -1.465802920184966   0.3873821075954746
 -0.947425604972511  -2.270915266147345

[:, :, 2] =
  2.5111441585885754  -0.18908944359063387
 -0.6981453207690251   0.7362551163858664
* Data for fusiontree FusionTree{SU₂}((1/2, 0), 1/2, (false, false), ()) ← FusionTree{SU₂}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 2.0231026079182906  -0.913841312662592
* Data for fusiontree FusionTree{SU₂}((1/2, 1), 1/2, (false, false), ()) ← FusionTree{SU₂}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 -0.9300991583662284
* Data for fusiontree FusionTree{SU₂}((0, 1/2), 1/2, (false, false), ()) ← FusionTree{SU₂}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 -0.8168138688344211
  1.9454326627972074
* Data for fusiontree FusionTree{SU₂}((1, 1/2), 1/2, (false, false), ()) ← FusionTree{SU₂}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 -0.07105199074404155
* Data for fusiontree FusionTree{SU₂}((1, 0), 1, (false, false), ()) ← FusionTree{SU₂}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.20772320373665917  1.1382451798187962
* Data for fusiontree FusionTree{SU₂}((0, 1), 1, (false, false), ()) ← FusionTree{SU₂}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.3365615313759156
 -2.361634337529672
* Data for fusiontree FusionTree{SU₂}((1, 1), 1, (false, false), ()) ← FusionTree{SU₂}((1,), 1, (false,), ()):
[:, :, 1] =
 1.5808199339342315
* Data for fusiontree FusionTree{SU₂}((1/2, 1/2), 1, (false, false), ()) ← FusionTree{SU₂}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.6917525495533209

julia&gt; dim(A)
24

julia&gt; convert(Array, A)
7×7×7 Array{Float64,3}:
[:, :, 1] =
 -1.4658     0.387382   0.0        0.0        0.0        0.0       0.0
 -0.947426  -2.27092    0.0        0.0        0.0        0.0       0.0
  0.0        0.0        0.0        0.0650631  0.0        0.0       0.0
  0.0        0.0       -0.0650631  0.0        0.0        0.0       0.0
  0.0        0.0        0.0        0.0        0.0        0.0       0.761766
  0.0        0.0        0.0        0.0        0.0       -0.761766  0.0
  0.0        0.0        0.0        0.0        0.761766   0.0       0.0

[:, :, 2] =
  2.51114   -0.189089   0.0       0.0        0.0       0.0        0.0
 -0.698145   0.736255   0.0       0.0        0.0       0.0        0.0
  0.0        0.0        0.0       0.636006   0.0       0.0        0.0
  0.0        0.0       -0.636006  0.0        0.0       0.0        0.0
  0.0        0.0        0.0       0.0        0.0       0.0       -0.631148
  0.0        0.0        0.0       0.0        0.0       0.631148   0.0
  0.0        0.0        0.0       0.0       -0.631148  0.0        0.0

[:, :, 3] =
 0.0      0.0       -0.816814    0.0        0.0        0.0       0.0
 0.0      0.0        1.94543     0.0        0.0        0.0       0.0
 2.0231  -0.913841   0.0         0.0        0.0       -0.536993  0.0
 0.0      0.0        0.0         0.0        0.759423   0.0       0.0
 0.0      0.0        0.0        -0.0580137  0.0        0.0       0.0
 0.0      0.0        0.0410219   0.0        0.0        0.0       0.0
 0.0      0.0        0.0         0.0        0.0        0.0       0.0

[:, :, 4] =
 0.0      0.0       0.0        -0.816814   0.0  0.0        0.0
 0.0      0.0       0.0         1.94543    0.0  0.0        0.0
 0.0      0.0       0.0         0.0        0.0  0.0       -0.759423
 2.0231  -0.913841  0.0         0.0        0.0  0.536993   0.0
 0.0      0.0       0.0         0.0        0.0  0.0        0.0
 0.0      0.0       0.0        -0.0410219  0.0  0.0        0.0
 0.0      0.0       0.0580137   0.0        0.0  0.0        0.0

[:, :, 5] =
  0.0       0.0       0.0       0.0  -0.336562  0.0      0.0
  0.0       0.0       0.0       0.0  -2.36163   0.0      0.0
  0.0       0.0      -0.691753  0.0   0.0       0.0      0.0
  0.0       0.0       0.0       0.0   0.0       0.0      0.0
 -0.207723  1.13825   0.0       0.0   0.0       1.11781  0.0
  0.0       0.0       0.0       0.0  -1.11781   0.0      0.0
  0.0       0.0       0.0       0.0   0.0       0.0      0.0

[:, :, 6] =
  0.0       0.0       0.0        0.0        0.0      -0.336562  0.0
  0.0       0.0       0.0        0.0        0.0      -2.36163   0.0
  0.0       0.0       0.0       -0.489143   0.0       0.0       0.0
  0.0       0.0      -0.489143   0.0        0.0       0.0       0.0
  0.0       0.0       0.0        0.0        0.0       0.0       1.11781
 -0.207723  1.13825   0.0        0.0        0.0       0.0       0.0
  0.0       0.0       0.0        0.0       -1.11781   0.0       0.0

[:, :, 7] =
  0.0       0.0      0.0   0.0       0.0   0.0      -0.336562
  0.0       0.0      0.0   0.0       0.0   0.0      -2.36163
  0.0       0.0      0.0   0.0       0.0   0.0       0.0
  0.0       0.0      0.0  -0.691753  0.0   0.0       0.0
  0.0       0.0      0.0   0.0       0.0   0.0       0.0
  0.0       0.0      0.0   0.0       0.0   0.0       1.11781
 -0.207723  1.13825  0.0   0.0       0.0  -1.11781   0.0

julia&gt; norm(A) ≈ norm(convert(Array, A))
true</code></pre><p>In this case, the full <code>Array</code> representation of the tensor has again many zeros, but it is less obvious to recognize the dense blocks, as there are additional zeros and the numbers in the original tensor data do not match with those in the <code>Array</code>. The reason is of course that the original tensor data now needs to be transformed with a construction known as fusion trees, which are made up out of the Clebsch-Gordan coefficients of the group. Indeed, note that the non-zero blocks are also no longer labeled by a list of sectors, but by pair of fusion trees. This will be explained further in the manual. However, the Clebsch-Gordan coefficients of the group are only needed to actually convert a tensor to an <code>Array</code>. For working with tensors with <code>SU₂Space</code> indices, e.g. contracting or factorizing them, the Clebsch-Gordan coefficients are never needed explicitly. Instead, recoupling relations are used to symbolically manipulate the basis of fusion trees, and this only requires what is known as the topological data of the group (or its representation theory).</p><p>In fact, this formalism extends beyond the case of group representations on vector spaces, and can also deal with super vector spaces (to describe fermions) and more general (unitary) fusion categories. Preliminary support for these generalizations is present in TensorKit.jl and will be extended in the near future.</p><p>All of these concepts will be explained throughout the remainder of this manual, including several details regarding their implementation. However, to just use tensors and their manipulations (contractions, factorizations, ...) in higher level algorithms (e.g. tensoer network algorithms), one does not need to know or understand most of these details, and one can immediately refer to the general interface of the <code>TensorMap</code> type, discussed on the <a href="../tensors/#s_tensors-1">last page</a>. Adhering to this interface should yield code and algorithms that are oblivious to the underlying symmetries and can thus work with arbitrary symmetric tensors.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../categories/">Optional introduction to category theory »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 18 February 2020 21:45">Tuesday 18 February 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
