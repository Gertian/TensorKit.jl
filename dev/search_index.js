var documenterSearchIndex = {"docs":
[{"location":"man/tensors/#Tensors-and-the-TensorMap-type-1","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Defining-and-constructing-tensor-maps-1","page":"Tensors and the TensorMap type","title":"Defining and constructing tensor maps","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Linear-algebra-operations-1","page":"Tensors and the TensorMap type","title":"Linear algebra operations","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Index-manipulations-1","page":"Tensors and the TensorMap type","title":"Index manipulations","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Tensor-contractions-and-tensor-networks-1","page":"Tensors and the TensorMap type","title":"Tensor contractions and tensor networks","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"lib/spaces/#Vector-spaces-1","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"CurrentModule = TensorKit","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The type hierarchy for representing vector spaces","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace\nElementarySpace\nGeneralSpace\nInnerProductSpace\nEuclideanSpace\nCartesianSpace\nComplexSpace\nRepresentationSpace\nGenericRepresentationSpace\nZNSpace\nCompositeSpace\nProductSpace","category":"page"},{"location":"lib/spaces/#TensorKit.VectorSpace","page":"Vector spaces","title":"TensorKit.VectorSpace","text":"abstract type VectorSpace end\n\nAbstract type at the top of the type hierarchy for denoting vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ElementarySpace","page":"Vector spaces","title":"TensorKit.ElementarySpace","text":"abstract type ElementarySpace{ùïú} <: VectorSpace end\n\nElementary finite-dimensional vector space over a field ùïú that can be used as the index space corresponding to the indices of a tensor.\n\nEvery elementary vector space should respond to the methods conj and dual, returning the complex conjugate space and the dual space respectively. The complex conjugate of the dual space is obtained as dual(conj(V)) === conj(dual(V)). These different spaces should be of the same type, so that a tensor can be defined as an element of a homogeneous tensor product of these spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GeneralSpace","page":"Vector spaces","title":"TensorKit.GeneralSpace","text":"struct GeneralSpace{ùïú} <: ElementarySpace{ùïú}\n\nA finite-dimensional space over an arbitrary field ùïú without additional structure. It is thus characterized by its dimension, and whether or not it is the dual and/or conjugate space. For a real field ùïú, the space and its conjugate are the same.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.InnerProductSpace","page":"Vector spaces","title":"TensorKit.InnerProductSpace","text":"abstract type InnerProductSpace{ùïú} <: ElementarySpace{ùïú} end\n\nAbstract type for denoting vector with an inner product and a corresponding metric, which can be used to raise or lower indices of tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.EuclideanSpace","page":"Vector spaces","title":"TensorKit.EuclideanSpace","text":"abstract type EuclideanSpace{ùïú} <: InnerProductSpace{ùïú} end\n\nAbstract type for denoting real or complex spaces with a standard (Euclidean) inner product (i.e. orthonormal basis), such that the dual space is naturally isomorphic to the conjugate space (in the complex case) or even to the space itself (in the real case), also known as the category of finite-dimensional Hilbert spaces FdHilb.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CartesianSpace","page":"Vector spaces","title":"TensorKit.CartesianSpace","text":"struct CartesianSpace <: EuclideanSpace{‚Ñù}\n\nA real euclidean space ‚Ñù^d, which is therefore self-dual. CartesianSpace has no additonal structure and is completely characterised by its dimension d. This is the vector space that is implicitly assumed in most of matrix algebra.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ComplexSpace","page":"Vector spaces","title":"TensorKit.ComplexSpace","text":"struct ComplexSpace <: EuclideanSpace{‚ÑÇ}\n\nA standard complex vector space ‚ÑÇ^d with Euclidean inner product and no additional structure. It is completely characterised by its dimension and whether its the normal space or its dual (which is canonically isomorphic to the conjugate space).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.RepresentationSpace","page":"Vector spaces","title":"TensorKit.RepresentationSpace","text":"abstract type RepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ} end\n\nComplex Euclidean space with a direct sum structure corresponding to different superselection sectors of type G<:Sector, e.g. the elements or irreps of a compact or finite group, or the labels of a unitary fusion category.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GenericRepresentationSpace","page":"Vector spaces","title":"TensorKit.GenericRepresentationSpace","text":"struct GenericRepresentationSpace{G<:Sector} <: RepresentationSpace{G}\n\nGeneric implementation of a representation space, i.e. a complex Euclidean space with a direct sum structure corresponding to different superselection sectors of type G<:Sector, e.g. the irreps of a compact or finite group, or the labels of a unitary fusion category.\n\nThis fallback is used when IteratorSize(values(G)) == IsInfinite().\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CompositeSpace","page":"Vector spaces","title":"TensorKit.CompositeSpace","text":"abstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\n\nAbstract type for composite spaces that are defined in terms of a number of elementary vector spaces of a homogeneous type S<:ElementarySpace{ùïú}.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ProductSpace","page":"Vector spaces","title":"TensorKit.ProductSpace","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n\nA ProductSpace is a tensor product space of N vector spaces of type S<:ElementarySpace. Only tensor products between ElementarySpace objects of the same type are allowed.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The type hierarchy for representing sectors","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Sector\nAbelianIrrep\nZNIrrep{N}\nU1Irrep\nSU2Irrep\nCU1Irrep\nFusionStyle\nAbelian\nNonAbelian\nSimpleNonAbelian\nDegenerateNonAbelian","category":"page"},{"location":"lib/spaces/#TensorKit.Sector","page":"Vector spaces","title":"TensorKit.Sector","text":"abstract type Sector end\n\nAbstract type for representing the label sets of graded vector spaces, which should correspond to (unitary) fusion categories.\n\nEvery new G<:Sector should implement the following methods:\n\none(::Type{G}) -> unit element of G\nconj(a::G) -> aÃÖ: conjugate or dual label of a\n‚äó(a::G, b::G) -> iterable with unique fusion outputs of a ‚äó b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::G, b::G, c::G) -> number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{G}) -> Abelian(), SimpleNonAbelian() or   DegenerateNonAbelian()\nBraidingStyle(::Type{G}) -> Bosonic(), Fermionic(), Anyonic(), ...\n\nand, if FusionStyle(G) == NonAbelian(),\n\nFsymbol(a::G, b::G, c::G, d::G, e::G, f::G) -> F-symbol: scalar (in case of   SimpleNonAbelian) or matrix (in case of DegenerateNonAbelian)\n... can all other information (quantum dimension, cups and caps) be extracted from F?\n\nand if BraidingStyle(G) == Fermionic()\n\nfermionparity(a::G) -> Bool representing the fermion parity of sector a   and optionally, if if FusionStyle(G) isa DegenerateNonAbelian\nvertex_ind2label(i::Int, a::G, b::G, c::G) -> a custom label for the ith copy of c appearing in a ‚äó b\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.FusionStyle","page":"Vector spaces","title":"TensorKit.FusionStyle","text":"function FusionStyle(G::Type{<:Sector}) -> ::FusionStyle\n\nReturn the type of fusion behavior of sectors of type G, which can be either\n\nAbelian(): single fusion output when fusing two sectors;\nSimpleNonAbelian(): multiple outputs, but every output occurs at most one,   also known as multiplicity free (e.g. irreps of SU(2));\nDegenerateNonAbelian(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Methods often apply similar to e.g. spaces and corresponding tensors or tensor maps, e.g.:","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"field\nsectortype\nsectors\nhassector\ndim\ndims\nblocksectors\nblockdim","category":"page"},{"location":"lib/spaces/#TensorKit.field","page":"Vector spaces","title":"TensorKit.field","text":"function field(V::VectorSpace) -> Field\n\nReturn the field type over which a vector space is defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectortype","page":"Vector spaces","title":"TensorKit.sectortype","text":"function sectortype(a) -> Sector\n\nReturn the type of sector over which object a (e.g. a representation space or a tensor) is defined. Also works in type domain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectors","page":"Vector spaces","title":"TensorKit.sectors","text":"sectors(V::ElementarySpace) -> sectortype(V)\nsectors(V::ProductSpace{S,N}) -> NTuple{N,sectortype{V}}\n\nReturn the different sectors of object a (e.g. a representation space or a tensor).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dim","page":"Vector spaces","title":"TensorKit.dim","text":"dim(V::VectorSpace) -> Int\n\nReturn the total dimension of the vector space V as an Int.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dims","page":"Vector spaces","title":"TensorKit.dims","text":"dims(::ProductSpace{S,N}) -> Dims{N} = NTuple{N,Int}\n\nReturn the dimensions of the spaces in the tensor product space as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blocksectors","page":"Vector spaces","title":"TensorKit.blocksectors","text":"dims(::ProductSpace{S,N}) -> Dims{N} = NTuple{N,Int}\n\nReturn the dimensions of the spaces in the tensor product space as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The following methods act specifically ElementarySpace spaces","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"isdual\ndual\nconj\nflip\n:‚äï\noneunit","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"or also on ProductSpace","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"fuse\n:‚äó\none","category":"page"},{"location":"man/intro/#s_intro-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Before providing a typical \"user guide\" and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.","category":"page"},{"location":"man/intro/#ss_tensor-1","page":"Introduction","title":"What is a tensor?","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor t is an element from the   tensor product of N vector spaces   V_1  V_2  V_N, where N is referred to as the rank or order of the   tensor, i.e.\nt  V_1  V_2    V_N","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"If you think of a tensor as an object with indices, a rank N tensor has N indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"As the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field, i.e. there is no meaning in ‚Ñù^5  ‚ÑÇ^3. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on Vector spaces.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Aside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term \"tensor map\" as follows:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor map t is a linear map from a source or domain   W_1  W_2    W_N_2 to a target or codomain V_1  V_2    V_N_1, i.e.\ntW_1  W_2    W_N_2  V_1  V_2    V_N_1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor of rank N is then just a special case of a tensor map with N_1 = N and N_2 = 0. A contraction between two tensors is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map W  V is often denoted as a rank 2 tensor in V  W^*, where W^* corresponds to the dual space of W. This simple example introduces two new concepts.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Typical vector spaces can appear in the domain and codomain in different variants, e.g.  as normal space or dual space. In fact, the most generic case is that every vector  space V has associated with it  a dual space V^*,  a conjugate space  overlineV and a conjugate dual space overlineV^*. The four different  vector spaces V, V^*, overlineV and overlineV^* correspond to the  representation spaces of respectively the fundamental, dual or contragredient, complex  conjugate and dual complex conjugate representation of the general linear group  mathsfGL(V) [tung]. In index notation these spaces are denoted with  respectively contravariant (upper), covariant (lower), dotted contravariant  and dotted covariant indices.\nFor real vector spaces, the conjugate (dual) space is identical to the normal (dual)  space and we only have upper and lower indices, i.e. this is the setting of e.g.  general relativity. For (complex) vector spaces with a sesquilinear inner product  overlineV  V  ‚ÑÇ, the inner product allows to define an isomorphism from the  conjugate space to the dual space (known as  Riesz representation theorem  in the more general context of Hilbert spaces).\nIn particular, in spaces with a Euclidean inner product (the setting of e.g. quantum  mechanics), the conjugate and dual space are naturally isomorphic (because the dual and  conjugate representation of the unitary group are the same). Again we only need upper  and lower indices (or kets and bras).\nFinally, in ‚Ñù^d with a Euclidean inner product, these four different spaces are  equivalent and we only need one type of index. The space is completely characterized by  its dimension d. This is the setting of much of classical mechanics and we refer to  such tensors as cartesian tensors and the corresponding space as cartesian space. These  are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some AbstractArray{<:Real,N} in Julia) without loss of structure.\nThe implementation of all of this is discussed in Vector spaces.\nIn the generic case, the identification between maps W  V and tensors in  V  W^* is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between V  W and W  V that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories. Nonetheless, we try to hide these  canonical isomorphisms from the user wherever possible.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"This brings us to our final (yet formal) definition","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor (map) is a homorphism between two objects from the category mathbfVect   (or some subcategory thereof). In practice, this will be mathbfFinVect, the   category of finite dimensional vector spaces. More generally, our concept of a tensor   makes sense, in principle, for any linear (a.k.a. mathbfVect-enriched) monoidal   category. We refer to the section   \"Monoidal categories and their properties (optional)\".","category":"page"},{"location":"man/intro/#ss_symmetries-1","page":"Introduction","title":"Symmetries and block sparsity","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group mathsfG which acts on the vector spaces V in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space V can be specified as the number of times every irreducible representation (irrep) a of mathsfG appears, i.e.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"V = bigoplus_a ‚ÑÇ^n_a  R_a","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"with R_a the space associated with irrep a of mathsfG, which itself has dimension d_a (often called the quantum dimension), and n_a the number of times this irrep appears in V. If the unitary irrep a for g  mathsfG is given by u_a(g), then the group action of mathsfG on V is given by the unitary representation","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"u(g) = bigoplus_a  ùüô_n_a  u_a(g)","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"with ùüô_n_a the n_a  n_a identity matrix. The total dimension of V is given by _a n_a d_a.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps tW_1  W_2    W_N_2  V_1  V_2    V_N_1 that are invariant under the symmetry (i.e. that act as intertwiners between the symmetry action on the domain and the codomain). Indeed, such tensors should be block diagonal because of Schur's lemma, but only after we couple the individual irreps in the spaces W_i to a joint irrep, which is then again split into the individual irreps of the spaces V_i. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebsch‚ÄìGordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups mathsfG. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, discussed below and only requires the topological data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah's W-symbol in the case of mathsfSU_2). In particular, we don't actually need the Clebsch‚ÄìGordan coefficients themselves (but they can be useful for checking purposes).","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Further details are provided in Sectors, representation spaces and fusion trees.","category":"page"},{"location":"man/intro/#ss_categories-1","page":"Introduction","title":"Monoidal categories and their properties (optional)","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The purpose of this final introductory section (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors.  In the end, identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following definitions are mostly based on [selinger], [kassel] and nLab, to which we refer for further information. Furthermore, we recommend the nice introduction of Beer et al.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"To start, a category C consists of","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"a class C of objects V, W, ‚Ä¶\nfor each pair of objects V and W, a set hom(WV) of morphisms fWV;   for a given map f, W is called the domain or source, and V the   codomain or target.\ncomposition of morphisms fWV and gXW into (f  g)XV that is   associative, such that for hYX we have f  (g  h) = (f  g)  h\nfor each object V, an identity morphism mathrmid_VVV such that   f  mathrmid_W = f = mathrmid_V  f.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In our case, i.e. the category mathbfVect (or some subcategory thereof), the objects are vector spaces, and the morphisms are linear maps between these vector spaces with \"matrix multiplication\" as composition. We refer to these morphisms as tensor maps exactly because there is a binary operation , the tensor product, that allows to combine objects into new objects. This makes mathbfVect into a tensor category, a.k.a a monoidal category, which has","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"a binary operation on objects  C  C  C\na binary operation on morphisms, also denoted as , such that    hom(W_1V_1)  hom(W_2V_2)  hom(W_1  W_2 V_1  V_2)\nan identity object I\nthree families of natural isomorphisms:\n V  C, a left unitor Œª_V I  V  V\n V  C, a right unitor œÅ_V V  I  V\n V_1 V_2 V_3  C, an associator   Œ±_V_1V_2V_3(V_1  V_2)  V_3  V_1  (V_2  V_3)\nthat satisfy certain consistency conditions (coherence axioms), which are known as the   triangle equation and pentagon equation.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In abstract terms,  is a (bi)functor from the product category C  C to C.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For the category mathbfVect, the identity object I is just the scalar field ùïú over which the vector spaces are defined, and which can be identified with a one- dimensional vector space. Every monoidal category is equivalent to a strict tensor category, where the left and right unitor and associator act as the identity and their domain and codomain are truly identical. Nonetheless, for tensor maps, we do actually discriminate between V, I  V and V  I because this amounts to adding or removing an extra factor I to the tensor product structure of the (co)domain, i.e. the left and right unitor are analogous to removing extra dimensions of size 1 from an array, and an actual operation is required to do so (this has in fact led to some controversy in several programming languages that provide native support for multidimensional arrays). For what concerns the associator, the distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3) is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We return to this in the section on fusion trees. However, we can already note that we will always represent tensor products using a canonical order (((V_1  V_2)  V_3)   V_N). A similar approach can be followed to map any tensor category into a strict tensor category (see Section XI.5 of [kassel]).","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"With these definitions, we have the minimal requirements for defining tensor maps. In principle, we could use a more general definition and define tensor maps as morphism of any tensor category where the hom-sets are themselves vector spaces, such that we can add morphisms and multiply them with scalars. Furthermore, the composition of morphisms and the tensor product of morphisms are bilinear operations. Such categories are called linear or mathbfVect-enriched.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In order to make tensor (maps) useful and to define operations with them, we can now introduce additional structure or quantifiers to the tensor category for which they are the morphisms.","category":"page"},{"location":"man/intro/#sss_braiding-1","page":"Introduction","title":"Braiding","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"To reorder tensor indices, or, equivalently, to reorder objects in the tensor product V_1  V_2   V_N, we need at the very least a braided tensor category which has,  V W  C, a braiding œÉ_VW VW  WV. A valid braiding needs to satisfy consistency condition with the associator Œ± known as the hexagon equation.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"However, for general braidings, there is no unique choice to identify a tensor in VW and WV, as any of the maps œÉ_VW, œÉ_WV^-1, œÉ_VW  œÉ_WV  œÉ_VW, ‚Ä¶  mapping from VW to WV are all different. In order for there to be a unique map from V_1  V_2   V_N to any permutation of the objects in this tensor product, the braiding needs to be symmetric, i.e. œÉ_VW = œÉ_WV^-1 or, equivalently œÉ_WV  œÉ_VW = mathrmid_VW. The resulting category is then referred to as a symmetric tensor category. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia's function permutedims on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered) or in the case of fermions (described using so-called super vector spaces where the braiding is given by the Koszul sign rule).","category":"page"},{"location":"man/intro/#sss_dual-1","page":"Introduction","title":"Duals and pivotal structure","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For tensor maps, the braiding structure only allows to reorder the objects within the domain or within the codomain separately. An autonomous or rigid monoidal category is one where objects have duals, defined via an exact pairing, i.e. two families of canonical maps, the unit Œ∑_V I  V  V^* and the co-unit œµ_V V^*  V  I that satisfy the \"snake rules\":","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"œÅ_V  (mathrmid_V  œµ_V)  (Œ∑_V  mathrmid_V)  Œª_V^-1 = mathrmid_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Œª_V^*^-1  (œµ_V  mathrmid_V^*)  (mathrmid_V^*  Œ∑_V)  œÅ_V^*^-1 = mathrmid_V^*","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Given a morphism tWV, we can now identify it with (t  mathrmid_W^*)  Œ∑_W to obtain a morphism IVW^*. For the category mathbfVect, this is the identification between linear maps WV and tensors in VW^*. In particular, for complex vector spaces, using a bra-ket notation and a generic basis n for V and dual basis m for V^* (such that mn = Œ¥_mn), the unit is Œ∑_V‚ÑÇ  V  V^*Œ±  Œ± _n n  n and the co-unit is œµ_VV^*  V  ‚ÑÇ m  n  Œ¥_mn. Note that this does not require an inner product, i.e. no mapping from n to n was defined.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For a general tensor map tW_1  W_2    W_N_2  V_1  V_2    V_N_1, by successively applying Œ∑_W_N_2, Œ∑_W_N_2-1, ‚Ä¶, Œ∑_W_1 (and the left or right unitor) but no braiding, we obtain a tensor in V_1  V_2    V_N_1  W_N_2^*    W_1^*. It does makes sense to define or identify (W_1  W_2    W_N_2)^* = W_N_2^*    W_1^*. Indeed, it can be shown that an exact pairing between V  W and W^*  V^* can be constructed out of the unit and counit of V and W.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"These exact pairings are known as the right unit and co-unit, and V^* is the right dual of V. Likewise, then, V is a left dual of V^*, and we can also define a left dual ^*V of V and associated pairings, the left unit Œ∑_V I  ^*V  V and the left co-unit œµ_V V  ^*V  I. An autonomous category mathbfC is one where every object V has both a left and right dual. If we have a natural isomorphism between both, typically expressed via a pivotal structure Œ¥_V  ^*V  V^* which satisfies Œ¥_V  W = Œ¥_W  Œ¥_V, we do not have to distinguish between both. The resulting category is known as a pivotal category. Indeed, in TensorKit.jl we assume to be working with pivotal categories and simply refer to dual(V) for the dual of a vector space.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For a pivotal category, there is a well defined notion of a transpose f^*V^*  W^* (also called adjoint mate) of a morphism fWV, namely as as","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"f^* = Œª_W^*  (œµ_V  mathrmid_W^*)  (mathrmid_V^*  f  mathrmid_W^*)  (mathrmid_V^*  Œ∑_W)  œÅ_V^*^-1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"^*f = œÅ_W^*  (mathrmid_W^*  œµ_V^*)  (mathrmid_V^*  f  mathrmid_W^*)  (Œ∑_W^*  mathrmid_V^*)  Œª_V^*^-1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"and both definitions coincide (which is not the case if the category is not pivotal). In a graphical representation, this means that boxes (representing tensor maps or morphisms more generally) can be rotated. The transpose corresponds to a 180Àö rotation (either way).","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Furthermore, in a pivotal category, we can define a map from endomorphisms of an object V, i.e. a morphism fVV to endomorphisms of the identity object I, i.e. scalars, known as the trace of f. In fact, we can define both a left trace as","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"tr(f) = œµ_V  (f  mathrmid_V^*)  Œ∑_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"and a right trace as","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"tr(f) = œµ_V  (mathrmid_V^*  f)  Œ∑_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In a spherical category, both definitions coincide for all V and we simply refer to the trace of an endomorphism. The particular value d_V = tr(mathrmid_V) is known as the (quantum) dimension of the object V, referred to as dim(V) in TensorKit.jl.","category":"page"},{"location":"man/intro/#sss_twists-1","page":"Introduction","title":"Twists and ribbons","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The braiding of a space and a dual space also follows naturally, it is given by œÉ_V^*W = Œª_W  V^*  (œµ_V  mathrmid_W  V^*)  (mathrmid_V^*  œÉ_VW^-1  mathrmid_V^*)  (mathrmid_V^* W  Œ∑_V)  œÅ_V^*  W^-1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Furthermore, in a braided pivotal category, we can define a family of natural isomorphisms Œ∏_VVV (i.e. for fWV, Œ∏_V  f = f  Œ∏_W) as","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Œ∏_V = œÅ_V  (mathrmid_V  œµ_V)  (œÉ_VV  mathrmid_V^*)  (mathrmid_V  Œ∑_V)  œÅ_V^-1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"which satisfy","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Œ∏_VW = œÉ_WV  (Œ∏_W  Œ∏_V)  œÉ_VW = (Œ∏_V  Œ∏_W)  œÉ_WV  œÉ_VW","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A family of natural isomorphisms satisfying this relation is called a twist, and the resulting category is called a balanced monoidal category.  Here, we defined the twist via the exact pairings, and ultimately via the pivotal structure, i.e. the mathrmid_V^* in the definition of Œ∏_V should have been a Œ¥_V^-1. The interaction between the twist and the braiding is consistent with the graphical rules of a ribbon. However, for the graphical rules of ribbons to also be compatible with the exact pairing, we furthermore need the condition Œ∏_V^* = Œ∏_V^* (i.e. the transpose), in which case the category is said to be tortile or also a ribbon category.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Alternatively, we can start with a balanced and autonomous category and use the twist to define the pivotal structure. In particular, we can express the left unit and counit in terms of the right unit and counit, the braiding and the twist, as","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Œ∑_V = (mathrmid_V^*  Œ∏_V)  œÉ_VV^*  Œ∑_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"œµ_V = œµ_V  œÉ_VV^*  (Œ∏_V  mathrmid_V^*)","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The trace of an endomorphism fVV is then given by","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"tr(f) = œµ_V  œÉ_VV^*  (( Œ∏_V  f)  mathrmid_V^*)  Œ∑_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"and it can be verified using the naturality of the braiding that the resulting category is spherical, i.e. that this is equal to","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"tr(f) = œµ_V  (mathrmid_V^*  (f  Œ∏_V))  œÉ_VV^*  Œ∑_V","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Note finally, that a ribbon category where the braiding is symmetric, is known as a compact closed category. For a symmetric braiding, the trivial twist Œ∏_V = mathrmid_V is always a valid choice, but it might not be the choice that one necessarily want to use. This brings us to the final paragraph.","category":"page"},{"location":"man/intro/#sss_adjoints-1","page":"Introduction","title":"Adjoints","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A dagger category C is a category together with an involutive functor CC that acts as the identity on objects, whereas on morphisms fWV it defines a morphism f^VW such that","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"mathrmid_V^ = mathrmid_V\n(g  f)^ = f^  g^\n(f^)^ = f","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In a dagger category, a morphism fWV is said to be unitary if it is an isomorphism and f^-1 = f^. Furthermore, an endomorphism fVV is hermitian or self-adjoint if f^ = f.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"There is more to be said about the interplay between the dagger and duals. Given a right unit Œ∑_V I  V  V^* and co-unit œµ_V V^*  V  I, we can define a left unit and co-unit Œ∑_V = (œµ_V)^ and œµ_V = (Œ∑_V)^, and from this, a unitary pivotal structure. Hence, right autonomous dagger categories are automatically pivotal dagger categories.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The twist defined via the pivotal structure now becomes","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Œ∏_V = œÅ_V  (mathrmid_V  (Œ∑_V)^)  (œÉ_VV  mathrmid_V^*)  (mathrmid_V  Œ∑_V)  œÅ_V^-1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity. We will return to this in the discussion of fermions.","category":"page"},{"location":"man/intro/#Bibliography-1","page":"Introduction","title":"Bibliography","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"[tung]:     Tung, W. K. (1985). Group theory in physics: an introduction to symmetry\n        principles, group representations, and special functions in classical and\n        quantum physics.\n        World Scientific Publishing Company.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"[selinger]: Selinger, P. (2010). A survey of graphical languages for monoidal\n        categories.\n        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"[beer]:     From categories to anyons: a travelogue\n        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole\n        Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan\n        Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf\n        [https://arxiv.org/pdf/1811.06670.pdf](https://arxiv.org/pdf/1811.06670.pdf)","category":"page"},{"location":"man/spaces/#s_spaces-1","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"using TensorKit","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"From the Introduction, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type VectorSpace","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type VectorSpace end","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"which serves in a sense as the category mathbfVect. All instances of subtypes of VectorSpace will represent vector spaces. In particular, we define two abstract subtypes","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type ElementarySpace{ùïú} <: VectorSpace end\nconst IndexSpace = ElementarySpace\n\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Here, ElementarySpace is a super type for all vector spaces that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace. It is parametrically dependent on ùïú, the field of scalars (see the next section on Fields).","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"On the other hand, subtypes of CompositeSpace{S} where S<:ElementarySpace are composed of a number of elementary spaces of type S. So far, there is a single concrete type ProductSpace{S,N} that represents the homogeneous tensor product of N vector spaces of type S. Its properties are discussed in the section on Composite spaces, together with possible extensions for the future.","category":"page"},{"location":"man/spaces/#ss_fields-1","page":"Vector spaces","title":"Fields","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces are defined over a field of scalars. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type Field end\n\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\n\nconst ‚Ñù = RealNumbers()\nconst ‚ÑÇ = ComplexNumbers()","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Note that ‚Ñù and ‚ÑÇ can be typed as \\bbR+TAB and \\bbC+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia's Number hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"3 ‚àà ‚Ñù\n5.0 ‚àà ‚ÑÇ\n5.0+1.0*im ‚àà ‚Ñù\nFloat64 ‚äÜ ‚Ñù\nComplexF64 ‚äÜ ‚ÑÇ\n‚Ñù ‚äÜ ‚ÑÇ\n‚ÑÇ ‚äÜ ‚Ñù","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"and furthermore‚Äîprobably more usefully‚Äî‚Ñù^n and ‚ÑÇ^n create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor a can be obtained with field(a).","category":"page"},{"location":"man/spaces/#ss_elementaryspaces-1","page":"Vector spaces","title":"Elementary vector spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of ElementarySpace. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every ElementarySpace should implement the following methods","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"dim(::ElementarySpace) -> ::Int returns the dimension of the space as an Int\ndual(::S) where {S<:ElementarySpace} -> ::S returns the   dual space dual(V), using an instance of   the same concrete type (i.e. not via type parameters); this should satisfy   dual(dual(V)==V\nconj(::S) where {S<:ElementarySpace} -> ::S returns the   complex conjugate space   conj(V), using an instance of the same concrete type (i.e. not via type parameters);   this should satisfy conj(conj(V))==V and we automatically have   conj(V::ElementarySpace{‚Ñù}) = V.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"For convenience, the dual of a space V can also be obtained as V'.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"There is concrete type GeneralSpace which is completely characterized by its field ùïú, its dimension and whether its the dual and/or complex conjugate of ùïú^d.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"struct GeneralSpace{ùïú} <: ElementarySpace{ùïú}\n    d::Int\n    dual::Bool\n    conj::Bool\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We furthermore define the abstract type","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract InnerProductSpace{ùïú} <: ElementarySpace{ùïú}","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to contain all vector spaces V which have an inner product and thus a canonical mapping from dual(V) to V (for ùïú ‚äÜ ‚Ñù) or from dual(V) to conj(V) (otherwise). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Finally there is","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract EuclideanSpace{ùïú} <: InnerProductSpace{ùïú}","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to contain all spaces V with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms dual(V) == V (for ùïú == ‚Ñù) or dual(V) == conj(V) (for ùïú == ‚ÑÇ). In particular, we have two concrete types","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"immutable CartesianSpace <: EuclideanSpace{‚Ñù}\n    d::Int\nend\nimmutable ComplexSpace <: EuclideanSpace{‚ÑÇ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to represent the Euclidean spaces ‚Ñù^d or ‚ÑÇ^d without further inner structure. They can be created using the syntax ‚Ñù^d and ‚ÑÇ^d, or (‚ÑÇ^d)'for the dual space of the latter. Note that the brackets are required because of the precedence rules, since d' == d for d::Integer. Some examples:","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"dim(‚Ñù^10)\n(‚Ñù^10)' == ‚Ñù^10\nisdual((‚ÑÇ^5))\nisdual((‚ÑÇ^5)')\nisdual((‚Ñù^5)')\ndual(‚ÑÇ^5) == (‚ÑÇ^5)' == conj(‚ÑÇ^5)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We refer to the next section on Sectors, representation spaces and fusion trees for further information about RepresentationSpace, which is another subtype of EuclideanSpace{‚ÑÇ} with an inner structure corresponding to the irreducible representations of a group.","category":"page"},{"location":"man/spaces/#ss_compositespaces-1","page":"Vector spaces","title":"Composite spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Composite spaces are vector spaces that are built up out of individual elementary vector spaces. The most prominent (and currently only) example is a tensor product of N elementary spaces of the same type S, which is implemented as","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Given some V1::S, V2::S, V3::S of the same type S<:ElementarySpace, we can easily construct ProductSpace{S,3}((V1,V2,V3)) as ProductSpace(V1,V2,V3) or using V1 ‚äó V2 ‚äó V3, where ‚äó is simply obtained by typing \\otimes+TAB. In fact, for convenience, also the regular multiplication operator * acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"V1 = ‚ÑÇ^2\nV2 = ‚ÑÇ^3\nV1 ‚äó V2 ‚äó V1' == V1 * V2 * V1' == ProductSpace(V1,V2,V1') == ProductSpace(V1,V2) ‚äó V1'\nV1^3\ndim(V1 ‚äó V2)\ndims(V1 ‚äó V2)\ndual(V1 ‚äó V2)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Here, the new function dims maps dim to the individual spaces in a ProductSpace and returns the result as a tuple. Note that the rationale for the last result was explained in the subsection Duals of Monoidal categories and their properties (optional).","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Following Julia's Base library, the function one applied to a ProductSpace{S,N} returns the multiplicative identity, which is ProductSpace{S,0}. The same result is obtained when acting on an instance V of S::ElementarySpace directly, however note that V ‚äó one(V) will yield a ProductSpace{S,1}(V) and not V itself. Similar to Julia Base, one also works in the type domain.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"In the future, other CompositeSpace types could be added. For example, the wave function of an N-particle quantum system in first quantization would require the introduction of a SymmetricSpace{S,N} or a AntiSymmetricSpace{S,N} for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of V^N, where V::S represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.","category":"page"},{"location":"man/spaces/#Some-more-functionality-1","page":"Vector spaces","title":"Some more functionality","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Some more convenience functions are provided for the euclidean spaces CartesianSpace and ComplexSpace, as well as for RepresentationSpace discussed in the next section. All functions below that act on more than a single elementary space, are only defined when the different spaces are of the same concrete subtype S<:ElementarySpace","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The function fuse(V1, V2, ...) or fuse(V1 ‚äó V2 ‚äó ...) returns an elementary space that is isomorphic to V1 ‚äó V2 ‚äó ..., in the sense that a unitary tensor map can be constructed between those spaces, e.g. from W = V1 ‚äó V2 ‚äó ... to V = fuse(V1 ‚äó V2 ‚äó ...). The function flip(V1) returns a space that is isomorphic to V1 but has isdual(flip(V1)) == isdual(V1'), i.e. if V1 is a normal space than flip(V1) is a dual space. Again, isomorphism here implies that a unitary map (but there is no canonical choice) can be constructed between both spaces. flip(V1) is different from dual(V1) in the case of RepresentationSpace. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from V1 to flip(V1). We refer to [Index operations](@ref) for further information. Some examples:","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"fuse(‚Ñù^5, ‚Ñù^3)\nfuse(‚ÑÇ^3, (‚ÑÇ^5)', ‚ÑÇ^2)\nflip(‚ÑÇ^4)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We also define the direct sum V1 and V2 as V1 ‚äï V2, where ‚äï is obtained by typing \\oplus+TAB. This is possible only if isdual(V1) == isdual(V2). With a little pun on Julia Base, oneunit applied to an elementary space (in the value or type domain) returns the one-dimensional space, which is isomorphic to the scalar field of the space itself. Some examples illustrate this better","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"‚Ñù^5 ‚äï ‚Ñù^3\n‚ÑÇ^5 ‚äï ‚ÑÇ^3\n‚ÑÇ^5 ‚äï (‚ÑÇ^3)'\noneunit(‚Ñù^3)\n‚ÑÇ^5 ‚äï oneunit(ComplexSpace)\noneunit((‚ÑÇ^3)')\n(‚ÑÇ^5) ‚äï oneunit((‚ÑÇ^5))\n(‚ÑÇ^5)' ‚äï oneunit((‚ÑÇ^5)')","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"For two spaces V1 and V2, min(V1,V2) returns the space with the smallest dimension, whereas max(V1,V2) returns the space with the largest dimension, as illustrated by","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"min(‚Ñù^5, ‚Ñù^3)\nmax(‚ÑÇ^5, ‚ÑÇ^3)\nmax(‚ÑÇ^5, (‚ÑÇ^3)')","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Again, we impose isdual(V1) == isdual(V2). As before, the use of these methods is to construct unitary or isometric tensors that map between different spaces, which will be elaborated upon in the section on Tensors.","category":"page"},{"location":"man/sectors/#s_sectorsrepfusion-1","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"using TensorKit","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The corresponding vector spaces will be canonically represented as V = _a ‚ÑÇ^n_a  R_a, where a labels the different irreps, n_a is the number of times irrep a appears and R_a is the vector space associated with irrep a. Irreps are also known as spin sectors (in the case of mathsfSU_2) or charge sectors (in the case of mathsfU_1), and we henceforth refer to a as a sector. As is briefly discussed below, the approach we follow does in fact go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a (ribbon) fusion category. Nonetheless, every step can be appreciated by using the representation theory of mathsfSU_2 or mathsfSU_3 as example. The vector space V is completely specified by the values of n_a.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group's Clebsch‚ÄìGordan (CG) coefficients. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or 6j-symbols (more accurately, it's actually Racah's W-coefficients) in the case of mathsfSU_2.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space V composed of a direct sum of different sectors. In the third section, we explain the details of fusion trees, i.e. their construction and manipulation. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists. But first, we provide a quick theoretical overview of the required data of the representation theory of a group.","category":"page"},{"location":"man/sectors/#ss_representationtheory-1","page":"Sectors, representation spaces and fusion trees","title":"Representation theory and unitary fusion categories","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let the different irreps or sectors be labeled as a, b, c, ‚Ä¶ First and foremost, we need to specify the fusion rules a  b =  N_ab^c c with N_ab^c some non-negative integers. There should always exists a unique trivial sector u such that a  u = a = u  a. Furthermore, there should exist a unique sector overlinea such that N_aoverlinea^u = 1, whereas for all b neq overlinea, N_ab^u = 0. For unitary irreps of groups, overlinea corresponds to the complex conjugate of the representation a, or a representation isomorphic to it. For example, for the representations of mathsfSU_2, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. a = overlinea), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The meaning of the fusion rules is that the space of transformations R_a  R_b  R_c (or vice versa) has dimension N_ab^c. In particular, we assume the existence of a basis consisting of unitary tensor maps X_ab^cŒº  R_c  R_a  R_b with Œº = 1  N_ab^c such that","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X_ab^cŒº)^ X_ab^cŒº = mathrmid_R_c","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_Œº = 1^N_ab^c X_ab^cŒº (X_ab^cŒº)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X_ab^cŒº are the splitting tensors, their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e. acting on the multiplicity label Œº = 1  N_ab^c. For mathsfSU_2, where N_ab^c is zero or one and the multiplicity labels are absent, the entries of X_ab^c are precisely given by the CG coefficients. The point is that we do not need to know the tensors X_ab^cŒº, the topological data of (the representation category of) the group describes the following transformation:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation between (a  b)  c to a  (b  c):\n(X_ab^eŒº  mathrmid_c)  X_ec^dŒΩ = _fŒ∫Œª F^abc_d^eŒºŒΩ_fŒ∫Œª (X_ab^eŒº  mathrmid_c) X_ec^dŒΩ (mathrmid_a  X_bc^fŒ∫)  X_af^dŒª\nBraiding or permuting as defined by œÉ_ab R_a  R_b  R_b  R_a:\nœÉ_R_aR_b  X_ab^cŒº = _ŒΩ R_ab^c^Œº_ŒΩ X_ba^cŒΩ","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The dimensions of the spaces R_a on which representation a acts are denoted as d_a and referred to as quantum dimensions. In particular d_u = 1 and d_a = d_overlinea. This information is also encoded in the F-symbol as d_a =  F^a overlinea a_a^u_u ^-1. Note that there are no multiplicity labels in that particular F-symbol as N_aoverlinea^u = 1.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If, for every a and b, there is a unique c such that a  b = c (i.e. N_ab^c = 1 and N_ab^c = 0 for all other c), the category is abelian. Indeed, the representations of a group have this property if and only if the group multiplication law is commutative. In that case, all spaces R_a associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all N_ab^c equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of mathsfSU_2, and those where some N_ab^c are larger than one, e.g. the representations of mathsfSU_3.","category":"page"},{"location":"man/sectors/#ss_sectors-1","page":"Sectors, representation spaces and fusion trees","title":"Sectors","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We introduce a new abstract type to represent different possible sectors","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Sector end","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Any concrete subtype of Sector should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category. We refer to Appendix E of [kitaev] for a good reference.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The minimal data to completely specify a type of sector are","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"the fusion rules, i.e. a  b =  N_ab^c c; this is implemented by a function   Nsymbol(a,b,c)\nthe list of fusion outputs from a  b; while this information is contained in   N_ab^c, it might be costly or impossible to iterate over all possible values of   c and test Nsymbol(a,b,c); instead we implement for a ‚äó b to return an iterable   object (e.g. tuple, array or a custom Julia type that listens to Base.iterate) and   which generates all c for which N_ab^c  0\nthe identity object u, such that a  u = a = u  a; this is implemented by the   function one(a) (and also in type domain) from Julia Base\nthe dual or conjugate representation overlinea for which   N_aoverlinea^u = 1; this is implemented by conj(a) from Julia Base;   dual(a) also works as alias, but conj(a) is the method that should be defined\nthe F-symbol or recoupling coefficients F^abc_d^e_f, implemented as the   function Fsymbol(a,b,c,d,e,f)\nthe R-symbol R_ab^c, implemented as the function Rsymbol(a,b,c)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For practical reasons, we also require some additional methods to be defined:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"isreal(::Type{<:Sector}) returns whether the topological data of this type of sector   is real-valued or not (in which case it is complex-valued). Note that this does not   necessarily require that the representation itself, or the Clebsch-Gordan coefficients,   are real. There is a fallback implementation that checks whether the F-symbol and R-symbol evaluated with all sectors equal to the identity sector have real eltype.\nhash(a, h) creates a hash of sectors, because sectors and objects created from them   are used as keys in lookup tables (i.e. dictionaries)\nisless(a,b) associates a canonical order to sectors (of the same type), in order to   unambiguously represent representation spaces V = _a ‚ÑÇ^n_a  R_a.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Further information, such as the quantum dimensions d_a and Frobenius-Schur indicator œá_a (only if a == overlinea) are encoded in the F-symbol. They are obtained as dim(a) and frobeniusschur(a). These functions have default definitions which extract the requested data from Fsymbol(a,conj(a),a,a,one(a),one(a)), but they can be overloaded in case the value can be computed more efficiently.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We also define a parametric type to represent an indexable iterator over the different values of a sector as","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorValues{G<:Sector} end\nBase.IteratorEltype(::Type{<:SectorValues}) = HasEltype()\nBase.eltype(::Type{SectorValues{G}}) where {G<:Sector} = G\nBase.values(::Type{G}) where {G<:Sector} = SectorValues{G}()","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where new sectors G<:Sector should define","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.iterate(::SectorValues{G}[, state]) = ...\nBase.IteratorSize(::Type{SectorValues{G}}) = # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::SectorValues{G}) = ...\nBase.getindex(::SectorValues{G}, i::Int) = ...\nfindindex(::SectorValues{G}, c::G) = ...","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is useful to distinguish between three cases with respect to the fusion rules. For irreps of Abelian groups, we have that for every a and b, there exists a unique c such that a  b = c, i.e. there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. All other cases are referred to as non-abelian, i.e. the irreps of a non-abelian group or some more general fusion category. We still distinguish between the case where all entries of N_ab^c  1, i.e. they are zero or one. In that case, F^abc_d^e_f and R_ab^c are scalars. If some N_ab^c  1, it means that the same sector c can appear more than once in the fusion product of a and b, and we need to introduce some multiplicity label Œº for the different copies. We implement a \"trait\" (similar to IndexStyle for AbstractArrays in Julia Base), i.e. a type hierarchy","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type FusionStyle end\nstruct Abelian <: FusionStyle\nend\nabstract type NonAbelian <: FusionStyle end\nstruct SimpleNonAbelian <: NonAbelian # non-abelian fusion but multiplicity free\nend\nstruct DegenerateNonAbelian <: NonAbelian # non-abelian fusion with multiplicities\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types G<:Sector should then indicate which fusion style they have by defining FusionStyle(::Type{G}).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In the representation and manipulation of symmetric tensors, it will be important to couple or fuse different sectors together into a single block sector. The section on Fusion trees describes the details of this process, which consists of pairwise fusing two sectors into a single coupled sector, which is then fused with the next uncoupled sector. For this, we assume the existence of a basis of unitary tensor maps X_ab^cŒº  R_c  R_a  R_b such that","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X_ab^cŒº)^ X_ab^cŒº = mathrmid_R_c and\nsum_c sum_Œº = 1^N_ab^c X_ab^cŒº (X_ab^cŒº)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X_ab^cŒº are the splitting tensors, their hermitian conjugate are the fusion tensors. For mathsfSU_2, their entries are precisely given by the CG coefficients. The point is that we do not need to know the tensors X_ab^cŒº, the topological data of (the representation category of) the group describes the following transformation:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation between (a  b)  c to a  (b  c):\n(X_ab^eŒº  mathrmid_c)  X_ec^dŒΩ = _fŒ∫Œª F^abc_d^eŒºŒΩ_fŒ∫Œª (X_ab^eŒº  mathrmid_c) X_ec^dŒΩ (mathrmid_a  X_bc^fŒ∫)  X_af^dŒª\nBraiding or permuting as defined by œÉ_ab R_a  R_b  R_b  R_a:\nœÉ_ab  X_ab^cŒº = _ŒΩ R_ab^c^Œº_ŒΩ X_ba^cŒΩ","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Furthermore, there is a relation between splitting vertices and fusion vertices given by the B-symbol, but we refer to the section on Fusion trees for the precise definition and further information. The required data is completely encoded in the the F-symbol, and corresponding Julia function Bsymbol(a,b,c) is implemented as","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"function Bsymbol(a::G, b::G, c::G) where {G<:Sector}\n    if FusionStyle(G) isa Abelian || FusionStyle(G) isa SimpleNonAbelian\n        Fsymbol(a, b, dual(b), a, c, one(a))\n    else\n        reshape(Fsymbol(a,b,dual(b),a,c,one(a)), (Nsymbol(a,b,c), Nsymbol(c,dual(b),a)))\n    end\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"but a more efficient implementation may be provided.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Before discussing in more detail how a new sector type should be implemented, let us study the cases which have already been implemented. Currently, they all correspond to the irreps of groups.","category":"page"},{"location":"man/sectors/#sss_groups-1","page":"Sectors, representation spaces and fusion trees","title":"Existing group representations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first sector type is called Trivial, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct Trivial <: Sector\nend\nBase.one(a::Sector) = one(typeof(a))\nBase.one(::Type{Trivial}) = Trivial()\nBase.conj(::Trivial) = Trivial()\n‚äó(::Trivial, ::Trivial) = (Trivial(),)\nNsymbol(::Trivial, ::Trivial, ::Trivial) = true\nFusionStyle(::Type{Trivial}) = Abelian()\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The Trivial sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For all abelian groups, we gather a number of common definitions","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type AbelianIrrep <: Sector end\n\nBase.@pure FusionStyle(::Type{<:AbelianIrrep}) = Abelian()\nBase.@pure BraidingStyle(::Type{<:AbelianIrrep}) = Bosonic()\n\nNsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = c == first(a ‚äó b)\nFsymbol(a::G, b::G, c::G, d::G, e::G, f::G) where {G<:AbelianIrrep} =\n    Int(Nsymbol(a,b,e)*Nsymbol(e,c,d)*Nsymbol(b,c,f)*Nsymbol(a,f,d))\nfrobeniusschur(a::AbelianIrrep) = 1\nBsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = Float64(Nsymbol(a, b, c))\nRsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = Float64(Nsymbol(a, b, c))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With these common definition, we implement the representation theory of the two most common Abelian groups","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct ZNIrrep{N} <: AbelianIrrep\n    n::Int8\n    function ZNIrrep{N}(n::Integer) where {N}\n        new{N}(mod(n, N))\n    end\nend\nBase.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)\nBase.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)\n‚äó(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)\n\nstruct U1Irrep <: AbelianIrrep\n    charge::HalfInteger\nend\nBase.one(::Type{U1Irrep}) = U1Irrep(0)\nBase.conj(c::U1Irrep) = U1Irrep(-c.charge)\n‚äó(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"together with some abbreviated Unicode aliases","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const ‚Ñ§‚ÇÇ = ZNIrrep{2}\nconst ‚Ñ§‚ÇÉ = ZNIrrep{3}\nconst ‚Ñ§‚ÇÑ = ZNIrrep{4}\nconst U‚ÇÅ = U1Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In the definition of U1Irrep, HalfInteger<:Number is a Julia type defined in WignerSymbols.jl, which is also used for SU2Irrep below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of U‚ÇÅ can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of HalfInteger, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"U‚ÇÅ(0.5)\nU‚ÇÅ(0.4)\nU‚ÇÅ(1) ‚äó U‚ÇÅ(1//2)\nu = first(U‚ÇÅ(1) ‚äó U‚ÇÅ(1//2))\nNsymbol(u, conj(u), one(u))\nz = ‚Ñ§‚ÇÉ(1)\nz ‚äó z\nconj(z)\none(z)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For ZNIrrep{N}, we use an Int8 for compact storage, assuming that this type will not be used with N>64 (we need 2*(N-1) <= 127 in order for a ‚äó b to work correctly).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As a further remark, even in the abelian case where a ‚äó b is equivalent to a single new label c, we return it as an iterable container, in this case a one-element tuple (c,).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned above, we also provide the following definitions","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)\nBase.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)\nBase.isless(c1::U1Irrep, c2::U1Irrep) where {N} =\n    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInteger) < c1.charge == -c2.charge","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Since sectors or objects made out of tuples of sectors (see the section on Fusion Trees below) are often used as keys in look-up tables (i.e. subtypes of AbstractDictionary in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value. Note that hashes will only be used to compare sectors of the same type. The isless function provides a canonical order for sectors of a given type G<:Sector, which is useful to uniquely and unambiguously specify a representation space V = _a ‚ÑÇ^n_a  R_a, as described in the section on Representation spaces below.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first example of a non-abelian representation category is that of mathsfSU_2, the implementation of which is summarized by","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SU2Irrep <: Sector\n    j::HalfInteger\nend\nBase.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInteger))\nBase.conj(s::SU2Irrep) = s\n‚äó(s1::SU2Irrep, s2::SU2Irrep) =\n    SectorSet{SU2Irrep}(HalfInteger, abs(s1.j.num-s2.j.num):2:(s1.j.num+s2.j.num) )\ndim(s::SU2Irrep) = s.j.num+1\nBase.@pure FusionStyle(::Type{SU2Irrep}) = SimpleNonAbelian()\nNsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.Œ¥(sa.j, sb.j, sc.j)\nFsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,\n        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =\n    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return 0.\n    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0\nend\nBase.hash(s::SU2Irrep, h::UInt) = hash(s.j, h)\nBase.isless(s1::SU2Irrep, s2::SU2Irrep) = isless(s1.j, s2.j)\nconst SU‚ÇÇ = SU2Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and some methods for pretty printing and converting from real numbers to irrep labels. As one can notice, the topological data (i.e. Nsymbol and Fsymbol) are provided by the package WignerSymbols.jl. The iterable a ‚äó b is a custom type, that the user does not need to care about. Some examples","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = SU‚ÇÇ(3//2)\nconj(s)\ndim(s)\ncollect(s ‚äó s)\nfor s‚Ä≤ in s ‚äó s\n    @show Nsymbol(s, s, s‚Ä≤)\n    @show Rsymbol(s, s, s‚Ä≤)\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A final non-abelian representation theory is that of the semidirect product mathsfU‚ÇÅ  ‚Ñ§_2, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of ‚Ñ§_2 acts as charge conjugation C. It has the effect of interchaning mathsfU_1 irreps n and -n, and turns them together in a joint 2-dimensional index, except for the case n=0. Irreps are therefore labeled by integers n  0, however for n=0 the ‚Ñ§‚ÇÇ symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with mathsfU)_1 charge 0. Given mathsfU_1  mathsfSO_2, this group is also simply known as mathsfO_2, and the two representations with n = 0 are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as CU‚ÇÅ or CU1Irrep in full.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct CU1Irrep <: Sector\n    j::HalfInteger # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::HalfInteger, s::Int = ifelse(j>0, 2, 0))\n        if ((j > 0 && s == 2) || (j == 0 && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU‚ÇÅ irrep\")\n        end\n    end\nend\nBase.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInteger), 0)\nBase.conj(c::CU1Irrep) = c\ndim(c::CU1Irrep) = ifelse(c.j == zero(HalfInteger), 1, 2)\nBase.@pure FusionStyle(::Type{CU1Irrep}) = SimpleNonAbelian()\n...\nconst CU‚ÇÅ = CU1Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of Fsymbol.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"So far, no sectors have been implemented with FusionStyle(G) == DegenerateNonAbelian(), though an example would be the representation theory of mathsfSU_3. Such sectors are not yet fully supported; certain operations remain to be implemented.","category":"page"},{"location":"man/sectors/#sss_productsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Combining different sectors","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator √ó, which can be entered as \\times+TAB. Some examples","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = ‚Ñ§‚ÇÉ(1) √ó U‚ÇÅ(1)\ntypeof(a)\nconj(a)\none(a)\ndim(a)\ncollect(a ‚äó a)\nFusionStyle(a)\nb = ‚Ñ§‚ÇÉ(1) √ó SU‚ÇÇ(3//2)\ntypeof(b)\nconj(b)\none(b)\ndim(b)\ncollect(b ‚äó b)\nFusionStyle(c)\nc = SU‚ÇÇ(1) √ó SU‚ÇÇ(3//2)\ntypeof(c)\nconj(c)\none(c)\ndim(c)\ncollect(c ‚äó c)\nFusionStyle(c)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We refer to the source file of ProductSector for implementation details.","category":"page"},{"location":"man/sectors/#sss_newsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Defining a new type of sector","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"By know, it should be clear how to implement a new Sector subtype. Ideally, a new G<:Sector type is a struct G ... end (immutable) that has isbitstype(G) == true (see Julia's manual), and implements the following minimal set of methods","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.one(::Type{G}) = G(...)\nBase.conj(a::G) = G(...)\nTensorKit.FusionStyle(::Type{G}) = ...\n    # choose one: Abelian(), SimpleNonAbelian(), DegenerateNonAbelian()\nTensorKit.Nsymbol(a::G, b::G, c::G) = ...\n    # Bool or Integer if FusionStyle(G) == DegenerateNonAbelian()\nBase.:‚äó(a::G, b::G) = ... # some iterable object that generates all possible fusion outputs\nTensorKit.Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G)\nTensorKit.Rsymbol(a::G, b::G, c::G)\nBase.hash(a::G, h::UInt)\nBase.isless(a::G, b::G)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Additionally, suitable definitions can be given for","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.dim(a::G) = ...\nTensorKit.frobeniusschur(a::G) = ...\nTensorKit.Bsymbol(a::G, b::G, c::G) = ...","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If FusionStyle(G) == DegenerateNonAbelian(), then the multiple outputs c in the tensor product of a and b will be labeled as i=1, 2, ‚Ä¶, Nsymbol(a,b,c). Optionally, a different label can be provided by defining","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.vertex_ind2label(i::Int, a::G, b::G, c::G) = ...\n# some label, e.g. a `Char` or `Symbol`","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following function will then automatically determine the corresponding label type (which should not vary, i.e. vertex_ind2label should be type stable)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.@pure vertex_labeltype(G::Type{<:Sector}) =\n    typeof(vertex_ind2label(1, one(G), one(G), one(G)))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following type, which already appeared in the implementation of SU2Irrep above, can be useful for providing the return type of a ‚äó b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorSet{G<:Sector,F,S}\n    f::F\n    set::S\nend\n...\nfunction Base.iterate(s::SectorSet{G}, args...) where {G<:Sector}\n    next = iterate(s.set, args...)\n    next === nothing && return nothing\n    val, state = next\n    return convert(G, s.f(val)), state\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"That is, SectorSet(f, set) behaves as an iterator that applies x->convert(G, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.","category":"page"},{"location":"man/sectors/#sss_generalsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Generalizations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned before, the framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary fusion category. In fact, because we also need a braiding (corresponding to Rsymbol(a,b,c)) it is a so- called ribbon fusion category. However, the category does not need to be modular.  The category of representations of a finite group[1] corresponds to a typical example (which is not modular and which have a symmetric braiding). Other examples are the representation of quasi-triangular Hopf algebras, which are typically known as anyon theories in the physics literature, e.g. Fibonacci anyons, Ising anyons, ‚Ä¶ In those cases, quantum dimensions d_a are non-integer, and there is no vector space interpretation to objects R_a (which we can identify with just a) in the decomposition V = _a ‚ÑÇ^n_a  R_a. The different sectors a, ‚Ä¶ just represent abstract objects. However, there is still a vector space associated with the homomorphisms a  b  c, whose dimension is N_ab^c. The objects X_ab^cŒº for Œº = 1N_ab^c serve as an abstract basis for this space and from there on the discussion is completely equivalent.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"So far, none of these cases have been implemented, but it is a simple exercise to do so.","category":"page"},{"location":"man/sectors/#ss_rep-1","page":"Sectors, representation spaces and fusion trees","title":"Representation spaces","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We have introduced Sector subtypes as a way to label the irreps or sectors in the decomposition V = _a ‚ÑÇ^n_a  R_a. To actually represent such spaces, we now also introduce a corresponding type RepresentationSpace, which is a subtype of EuclideanSpace{‚ÑÇ}, i.e.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type RepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ} end","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that this is still an abstract type, nonetheless it will be the type name that the user calls to create specific instances.","category":"page"},{"location":"man/sectors/#Types-1","page":"Sectors, representation spaces and fusion trees","title":"Types","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The actual implementation comes in two flavors","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct GenericRepresentationSpace{G<:Sector} <: RepresentationSpace{G}\n    dims::SectorDict{G,Int}\n    dual::Bool\nend\nstruct ZNSpace{N} <: RepresentationSpace{ZNIrrep{N}}\n    dims::NTuple{N,Int}\n    dual::Bool\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The GenericRepresentationSpace is the default implementation and stores the different sectors a and their corresponding degeneracy n_a as key value pairs in an Associative array, i.e. a dictionary dims::SectorDict. SectorDict is a constant type alias for a specific dictionary implementation, either Julia's default Dict or the type SortedVectorDict implemented in TensorKit.jl. Note that only sectors a with non-zero n_a are stored. The second implementation ZNSpace{N} is a dedicated implementation for ZNIrrep{N} symmetries, and just stores all N different values n_a in a tuple.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned, creating instances of these types goes via RepresentationSpace, using a list of pairs a=>n_a, i.e. V = RepresentationSpace(a=>n_a, b=>n_b, c=>n_c). In this case, the sector type G is inferred from the sectors. However, it is often more convenient to specify the sector type explicitly, since then the sectors are automatically converted to the correct type, i.e. compare","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"RepresentationSpace{U1Irrep}(0=>3, 1=>2, -1=>1) ==\n    RepresentationSpace(U1Irrep(0)=>3, U1Irrep(1)=>2, U1Irrep(-1)=>1)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"or using Unicode","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"RepresentationSpace{U‚ÇÅ}(0=>3, 1=>2, -1=>1) ==\n    RepresentationSpace(U‚ÇÅ(0)=>3, U‚ÇÅ(-1)=>1, U‚ÇÅ(1)=>2)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"However, both are still to long for the most common cases. Therefore, we provide a number of type aliases, both in plain ASCII and in Unicode","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const ‚Ñ§‚ÇÇSpace = ZNSpace{2}\nconst ‚Ñ§‚ÇÉSpace = ZNSpace{3}\nconst ‚Ñ§‚ÇÑSpace = ZNSpace{4}\nconst U‚ÇÅSpace = GenericRepresentationSpace{U‚ÇÅ}\nconst CU‚ÇÅSpace = GenericRepresentationSpace{CU‚ÇÅ}\nconst SU‚ÇÇSpace = GenericRepresentationSpace{SU‚ÇÇ}\n\n# non-Unicode alternatives\nconst Z2Space = ‚Ñ§‚ÇÇSpace\nconst Z3Space = ‚Ñ§‚ÇÉSpace\nconst Z4Space = ‚Ñ§‚ÇÑSpace\nconst U1Space = U‚ÇÅSpace\nconst CU1Space = CU‚ÇÅSpace\nconst SU2Space = SU‚ÇÇSpace","category":"page"},{"location":"man/sectors/#Methods-1","page":"Sectors, representation spaces and fusion trees","title":"Methods","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There are a number of methods to work with instances V of RepresentationSpace. The function sectortype returns the type of the sector labels. It also works on other vector spaces, in which case it returns Trivial. The function sectors returns an iterator over the different sectors a with non-zero n_a, for other ElementarySpace types it returns (Trivial,). The degeneracy dimensions n_a can be extracted as dim(V, a), it properly returns 0 if sector a is not present in the decomposition of V. With hassector(V, a) one can check if V contains a sector a with dim(V,a)>0. Finally, dim(V) returns the total dimension of the space V, i.e. _a n_a d_a or thus dim(V) = sum(dim(V,a) * dim(a) for a in sectors(V)).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Other methods for ElementarySpace, such as dual, fuse and flip also work. In fact, RepresentationSpace is the reason flip exists, cause in this case it is different then dual. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In order for flip(V) to be isomorphic to V, it is such that, if V = RepresentationSpace(a=>n_a,...) then flip(V) = dual(RepresentationSpace(dual(a)=>n_a,....)). Furthermore, for two spaces V1 = RepresentationSpace(a=>n1_a, ...) and V2 = RepresentationSpace(a=>n2_a, ...), we have min(V1,V2) = RepresentationSpace(a=>min(n1_a,n2_a), ....) and similarly for max, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of min(V1,V2) or max(V1,V2) is neither equal to V1 or V2.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For W a ProductSpace{<:RepresentationSpace{G},N}, sectors(W) returns an iterator that generates all possible combinations of sectors as represented as NTuple{G,N}. The function dims(W, as) returns the corresponding tuple with degeneracy dimensions, while dim(W, as) returns the product of these dimensions. hassector(W, as) is equivalent to dim(W, as)>0. Finally, there is the function blocksectors(W) which returns a list (of type Vector) with all possible \"block sectors\" or total/coupled sectors that can result from fusing the individual uncoupled sectors in W. Correspondingly, blockdim(W, a) counts the total dimension of coupled sector a in W. The machinery for computing this is the topic of the next section on Fusion trees, but first, it's time for some examples.","category":"page"},{"location":"man/sectors/#Examples-1","page":"Sectors, representation spaces and fusion trees","title":"Examples","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let's start with an example involving mathsfU_1:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = RepresentationSpace{U‚ÇÅ}(0=>3, 1=>2, -1=>1)\nV1 == U1Space(0=>3, 1=>2, -1=>1) == U‚ÇÅSpace(0=>3, 1=>2, -1=>1)\n(sectors(V1)...,)\ndim(V1, U‚ÇÅ(1))\ndim(V1)\nhassector(V1, U‚ÇÅ(1))\nhassector(V1, U‚ÇÅ(2))\ndual(V1)\nflip(V1)\nV2 = U1Space(0=>2, 1=>1, -1=>1, 2=>1, -2=>1)\nmin(V1,V2)\nmax(V1,V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\n(sectors(W)...,)\ndims(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\ndim(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\nhassector(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\nhassector(W, (U‚ÇÅ(2), U‚ÇÅ(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, U‚ÇÅ(0))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and then with mathsfSU_2:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = RepresentationSpace{SU‚ÇÇ}(0=>3, 1//2=>2, 1=>1)\nV1 == SU2Space(0=>3, 1//2=>2, 1=>1) == SU‚ÇÇSpace(0=>3, 1//2=>2, 1=>1)\n(sectors(V1)...,)\ndim(V1, SU‚ÇÇ(1))\ndim(V1)\nhassector(V1, SU‚ÇÇ(1))\nhassector(V1, SU‚ÇÇ(2))\ndual(V1)\nflip(V1)\nV2 = SU2Space(0=>2, 1//2=>1, 1=>1, 3//2=>1, 2=>1)\nmin(V1,V2)\nmax(V1,V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\n(sectors(W)...,)\ndims(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\ndim(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\nhassector(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\nhassector(W, (SU‚ÇÇ(2), SU‚ÇÇ(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, SU‚ÇÇ(0))","category":"page"},{"location":"man/sectors/#ss_fusiontrees-1","page":"Sectors, representation spaces and fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Work in progress","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section blocksectors and blockdim defined on the type ProductSpace.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To couple or fuse the different sectors together into a single block sector, we sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector. For this, we assume the existence of unitary tensor maps X_ab^cŒº  R_c  R_a  R_b introduced in the section Sectors.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"such that (X_ab^cŒº)^ X_ab^cŒº = mathrmid_R_c and","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_Œº = 1^N_ab^c X_ab^cŒº (X_ab^cŒº)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X_ab^cŒº are the splitting tensors, their hermitian conjugate are the fusion tensors. For mathsfSU_2, their entries are given by the Clebsch‚ÄìGordan coefficients","category":"page"},{"location":"man/sectors/#Canonical-representation-1","page":"Sectors, representation spaces and fusion trees","title":"Canonical representation","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Possible-manipulations-1","page":"Sectors, representation spaces and fusion trees","title":"Possible manipulations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Fermions-1","page":"Sectors, representation spaces and fusion trees","title":"Fermions","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Bibliography-1","page":"Sectors, representation spaces and fusion trees","title":"Bibliography","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"[kitaev]: Kitaev, A. (2006). Anyons in an exactly solved model and beyond. Annals of Physics, 321(1), 2-111.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"[1]: Strictly speaking the number of sectors, i.e. simple objects, in a fusion category needs to be finite, so that RepmathsfG is only a fusion category for a finite group mathsfG. It is clear our formalism also works for compact Lie groups with an infinite number of irreps, since any finite-dimensional vector space will only have a finite number of all possible irreps in its decomposition.","category":"page"},{"location":"index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"#TensorKit.jl-1","page":"Home","title":"TensorKit.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for large-scale tensor computations, with a hint of category theory.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = TensorKit","category":"page"},{"location":"#Package-summary-1","page":"Home","title":"Package summary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"TensorKit.jl aims to be a generic package for working with tensors as they appear throughout the physical sciences. TensorKit implements a parametric type Tensor (which is actually a specific case of the type TensorMap) and defines for these types a number of vector space operations (scalar multiplication, addition, norms and inner products), index operations (permutations) and linear algebra operations (multiplication, factorizations). Finally, tensor contractions can be performed using the @tensor macro from TensorOperations.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Currently, most effort is oriented towards tensors as they appear in the context of quantum many body physics and in particular the field of tensor networks. Such tensors often have large dimensions and take on a specific structure when symmetries are present. To deal with generic symmetries, we employ notations and concepts from category theory all the way down to the definition of a tensor.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At the same time, TensorKit.jl focusses on computational efficiency and performance. The underlying storage of a tensor's data can be any DenseArray. Currently, certain operations are already multithreaded, either by distributing the different blocks in case of a structured tensor (i.e. with symmetries) or by using multithreading provided by the package Strided.jl. In the future, we also plan to investigate using GPUArrays as underlying storage for the tensors data, so as to leverage GPUs for the different operations defined on tensors.","category":"page"},{"location":"#Contents-of-the-manual-1","page":"Home","title":"Contents of the manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\", \"man/spaces.md\", \"man/sectors.md\", \"man/tensors.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/spaces.md\"]\nDepth = 2","category":"page"},{"location":"man/old/#TensorKit.jl-1","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A Julia tensor package with a hint of category theory. ***","category":"page"},{"location":"man/old/#Introduction-1","page":"TensorKit.jl","title":"Introduction","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"TensorKit.jl is a Julia package for working with tensors, which are consistently treated as the elements of a tensor product of vector spaces or, more generally, as linear maps between pairs of such tensor product spaces. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction.","category":"page"},{"location":"man/old/#What-is-a-tensor?-1","page":"TensorKit.jl","title":"What is a tensor?","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In abstract sense, tensors (and tensor maps; see below) correspond to the morphisms in the category Vect, i.e. the category with vector spaces as objects, or some subcategory thereof.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"some subspace thereof. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction. Henceforth, we represent a tensor using index notation and refer to the different \"dimensons\" as indices. The tensor T^i_1overlineimath_4_i_2overlineimath_3 represents a an element of the tensor product space V_1 \\otimes V_2^{\\ast} \\otimes \\overline{V}_3 \\otimes \\overline{V}_4^{\\ast} where general complex vector spaces V can appear in four different ways:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"contravariant index i_1 : normal vector space V_1\ncontravariant index i_2 : dual space V_2^ast\nbarred or dotted covariant index overlineimath_3 : complex conjugate space overlineV_3\nbarred or dotted contravariant index overlineimath_4 : complex conjugate of the dual space overlineV_4^ast , which is equivalent to the dual of the complex conjugate space","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The four different vector spaces V , V^ast , overlineV and overlineV^ast correspond to the representation spaces of respectively the fundamental, dual or contragredient, complex conjugate and dual complex conjugate representation of the general linear group mathsfGL(V) [tung]. Simplifications will occur for certain types of vector spaces.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Vector-spaces-1","page":"TensorKit.jl","title":"Vector spaces","text":"","category":"section"},{"location":"man/old/#Elementary-vector-spaces-1","page":"TensorKit.jl","title":"Elementary vector spaces","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Tensors in TensorToolbox.jl are treated as elements of a tensor product of a homogeneous family of elementary vector spaces, which we also refer to as index spaces and can be user defined. We thus define a type hierarchy for representing a hierarchy of common vector spaces:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract VectorSpace\nabstract ElementarySpace{F} <: VectorSpace\nconst IndexSpace = ElementarySpace","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"where the parameter F can be used to represent a field over which the vector space is defined. In particular, we define a unicode shorthand for two common fields, which we take from the Julia Number type hierarchy:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"const ‚Ñù=Real\nconst ‚ÑÇ=Complex{Real}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Every ElementarySpace should implement the following methods","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"dim(::ElementarySpace) -> ::Int   returns the dimension of the space as an Int\ndual{S<:ElementarySpace}(::S) -> ::S   returns the dual space dual(V), preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy dual(dual(V)==V\nconj{S<:ElementarySpace}(::S) -> ::S   returns the complex conjugate space conj(V), preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy conj(conj(V))==V and we automatically have conj{F<:Real}(V::ElementarySpace{F}) = V.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In particular, there is concrete type GeneralSpace which is completely characterized by its field F, its dimension and whether its the dual and/or complex conjugate of mathbbF^d .","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We furthermore define the abstract type","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract InnerProductSpace{F} <: ElementarySpace{F}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to contain all vector spaces V which have an inner product and thus a natural mapping from dual(V) to V (for F<:Real) or from dual(V) to conj(V) (for F<:Complex). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Finally there is","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract EuclideanSpace{F} <: InnerProductSpace{F}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to contain all spaces V with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms dual(V)==V (for F<:Real) or dual(V)==conj(V) (for F<:Complex). In particular, we have two concrete types","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"immutable CartesianSpace <: EuclideanSpace{‚Ñù}\n    d::Int\nend\nimmutable ComplexSpace <: EuclideanSpace{‚ÑÇ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to represent the Euclidean spaces ‚Ñù^d or ‚ÑÇ^d without further inner structure. They can be created using the syntax ‚Ñù^d and ‚ÑÇ^d.","category":"page"},{"location":"man/old/#WIP:-Graded-spaces,-superselection-sectors-and-braiding-1","page":"TensorKit.jl","title":"WIP: Graded spaces, superselection sectors and braiding","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"If tensors are used to describe system with a certain symmetry corresponding to a group mathsfG , this implies that the vector spaces V involved carry a corresponding representation rho_V mathsfG to V . For compact groups and an otherwise complex euclidean space V , these representations can be chosen unitary and it makes sense to decompose V according to the irreducible representations of mathsfG as","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"V=bigoplus_lambda R_lambda otimes mathbbC^d_lambda","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"V","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"thus becomes a graded vector space with the different sectors labelled by the irreducible representations lambda of mathsfG , and where every sector decomposes as the tensor product of the irrep space R_lambda and a part mathbbC^d_lambda that transforms trivially. More generally, a vector space can be graded by the representations of a Hopf algebra, corresponding to a set of labels constituting a unitary fusion category.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The implementation of graded vector spaces is currently limited to those cases where V represents a complex Euclidean space, which would be the typical case for unitary representations of groups. This amounts to the definition","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract UnitaryRepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Here, Sector is an abstract type. A subtype of Sector corresponds to a particular fusion category and the possible objects correspond to the different labels, i.e. the different charges or superselection sectors. Sector objects should support the functionality to map objects (labels) to the corresponding conjugate label (anticharge), to create the trivial object (identity, zero charge) and to determine the outcome of the fusion product. So far, only abelian categories are implemented, corresponding to the representations of abelian groups:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract Sector\nabstract Abelian <: Sector\nabstract NonAbelian <: Sector\nimmutable Parity <: Abelian\n    charge::Bool\nend\nimmutable ZNCharge{N} <: Abelian\n    charge::Int\n    ZNCharge(charge::Int)=new(mod(charge,N))\nend\nimmutable U1Charge <: Abelian\n    charge::Int\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"***TODO: Braiding***","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"When the different superselection sectors correspond to e.g. different fermion or anyon occupation numbers, a natural action will arise when changing the order of the corresponding vectors in a tensor product. The graded vector space thus becomes a braided vector space. The simplest example is that of a vector space V graded by fermion parity. An element of V1‚äóV2 can be mapped to one of V2‚äóV1 by permuting the two tensor indices and adding a phase -1 in the sector where both indices have an odd fermion number. More generally, a complete braiding tensor R_alphabeta^gamma needs to be specified.","category":"page"},{"location":"man/old/#ElementarySpace-methods-1","page":"TensorKit.jl","title":"ElementarySpace methods","text":"","category":"section"},{"location":"man/old/#Composite-spaces-1","page":"TensorKit.jl","title":"Composite spaces","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Composite spaces are built out of elementary vector spaces of a homogeneous type S. The most relevant case is the abstract family TensorSpace{S,N} used to denote certain subspaces in the tensor product space of N vector spaces of type S. These spaces will be used to define rank-N tensors, where the different tensor indices i_j correspond to the elements of a basis in V_j for j=12N . We start with the definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract CompositeSpace{S<:ElementarySpace} <: VectorSpace\nabstract TensorSpace{S<:ElementarySpace,N} <: CompositeSpace{S}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The homogenity restriction is the only sensible way of defining tensor product spaces, since there is no point in defining i.e. a tensor with a group action on some indices and not on other indices and it is even impossible to define the tensor product space of vector spaces over different fields. It is thus not possible to construct tensor product spaces of e.g. mathbbR^d_1 and mathbbC^d_2 , but it is possible to construct tensor product spaces of mathbbC^d_1 and mathbbC^d_2 , or even the dual of the latter. Therefore, for new vector spaces, it is important that any related vector space (e.g. the dual or conjugated space) with which one wants to construct tensor product spaces are of the same concrete type (e.g. no type parameters to denote dual spaces).","category":"page"},{"location":"man/old/#ProductSpace-1","page":"TensorKit.jl","title":"ProductSpace","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The complete tensor product space is represented by the concrete type ProductSpace{S,N}. This corresponds to the definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"immutable ProductSpace{S<:ElementarySpace,N} <: TensorSpace{S,N}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The ProductSpace of a set of elementary spaces V1, V2, ... of type S can be created as  V1 ‚äó V2 ‚äó .... Product spaces can be iterated over and indexed in order to extract the elementary spaces, or the tensor product of a subset of them. The dual and conjugate spaces are defined by mapping these actions to the respective elementary vector spaces V1, V2, ... For convience, we also define the transpose of a ProductSpace by reversing the factors V1 to VN, and the ctranspose by reversing the conjugated spaces. While there is no such thing as the transpose of a vector space, this definition is convenient because it is compatible with the way (c)transpose is defined for tensors. Finally, the dim of a ProductSpace is given by the product of the dim of its constituents.","category":"page"},{"location":"man/old/#WIP:-InvariantSpace-1","page":"TensorKit.jl","title":"WIP: InvariantSpace","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A InvariantSpace corresponds to the subspace of the tensor product of some UnitaryRepresentationSpaces that fuses to the identity (i.e. total 'charge' zero). In the case of irreducible representations of groups, it corresponds to the invariant subspace, i.e. the subspace of the tensor product that couples to the trivial representation. The different sectors of an InvariantSpace are labelled not only by the set of sectors of the individual elementary spaces (under the constraint that they have a fusion channel to trivial charge), but also by the intermediate fusion sectors. This gives rise to the concept of a fusion tree.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In order to describe and manipulate the trivial sector in the tensor product of UnitaryRepresentationSpaces, one thus needs to be able to store and manipulate fusion trees using recouplings (F-moves) or braidings (R-moves). So far, this has only been implemented for spaces with Abelian fusion rules and trivial braiding.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"TODO: develop interface to work with fusion trees and braidings\nTODO: implement some non-trivial cases (SU(2) symmetry, fermions, ...)","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"References:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"General theory of anyons and unitary fusion categoies\nGeneral treatment of symmetries in tensors\nU1 symmetric tensors\nSU2 symmetric tensors\nAnyonic tensors 1 , Anyonic tensors 2","category":"page"},{"location":"man/old/#TODO:-Symmetric-and-antisymmetric-vector-spaces-(Fock-space)-1","page":"TensorKit.jl","title":"TODO: Symmetric and antisymmetric vector spaces (Fock space)","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"For the tensor product of N identical copies of a given vector space V, we can also consider the symmetric or antisymmetric subspace of V^otimes N , corresponding to e.g. the N particle boson or fermion Fock space corresponding to a single particle Hilbert Space V. This has of course also other applications and can be extended to tensors with (anti)symmetry in subsets of indices.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensors-1","page":"TensorKit.jl","title":"Tensors","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The most important elements in TensorToolbox.jl are of course tensors. A rank N tensor is interpreted as the element of (a subspace of) the tensor product of some N elementary vector spaces, represented as a TensorSpace{S,N} object V. A tensor needs to store its components as a list of numbers of type T<:Number. The following observations are in order:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The element type T must not be the same as the field of the vector space, i.e. a tensor in a (tensor product) of ComplexSpaces can have real components, but a tensor in the product space of CartesianSpaces should not have complex entries. However, this is not strictly enforced.\nThe components represent the tensor with respect to a canonical choice of basis in V; so far there is no support to represent different basis choices and the transformations between them. This might change in the future.\nThe number of (independent) components of a tensor is given by dim V. When V is a proper subspace of V1 ‚äó V2 ‚äó ... ‚äó VN, then dim V is not just the product of the dimensions of the elementary spaces and the independent components cannot simply be represent as a N-dimensional array.","category":"page"},{"location":"man/old/#Different-tensor-types-1","page":"TensorKit.jl","title":"Different tensor types","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The only difference between tensors (so far) is how their independent components are stored. All other characteristics are encoded in the type of vector space.","category":"page"},{"location":"man/old/#DenseTensor-1","page":"TensorKit.jl","title":"DenseTensor","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We start the type hierarchy with an abstract type and currently have a single concrete tensor type, DenseTensor, that stores its components using a Vector{T}, corresponding to the following definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract AbstractTensor{S,T,N}\nimmutable DenseTensor{S,T,N,P} <: AbstractTensor{S,T,N}\n    data::Vector{T}\n    space::P\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Here, we should have P<:TensorSpace{S,N}. With the current Julia type system, this cannot be enforced in the type but only in its constructor (which also checks that length(data)=dim(space). This might change with the type system redesign.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We can then define some useful type aliasses for e.g. the standard tensor living in the full tensor product space","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"typealias Tensor{S,T,N} DenseTensor{S,T,N,ProductSpace{S,N}}\ntypealias CartesianTensor{T,N} Tensor{CartesianSpace,T,N}\ntypealias ComplexTensor{T,N} Tensor{ComplexSpace,T,N}\ntypealias InvariantTensor{S,T,N} DenseTensor{S,T,N,InvariantSpace{S,N}}\ntypealias U1Tensor{T,N} ...","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"and so on.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A tensor can be created from a set of components as","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"tensor(data, space)","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"where data can be an arbitrary Vector{T}.","category":"page"},{"location":"man/old/#TODO:-DiagonalTensor-1","page":"TensorKit.jl","title":"TODO: DiagonalTensor","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"For the specific case of a rank N=2 tensor in V ‚äó dual(V), it is often useful to have an explicit diagonal representation, e.g. to store the eigenvalues or singular values corresponding to a given tensor factorization (see below).","category":"page"},{"location":"man/old/#Other-tensors-?-1","page":"TensorKit.jl","title":"Other tensors ?","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Should there be sparse tensors?","category":"page"},{"location":"man/old/#Tensor-properties-1","page":"TensorKit.jl","title":"Tensor properties","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The basic tensor methods allow to construct tensors and query their characteristics","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"space(t) returns the vector space of a tensor t.\neltype(t) returns the element type T of the coefficient vector.\nnumind(t)=order(t) returns the number of tensor indices N, i.e. the number of elementary vector spaces in space(t).\nin(t,V) can be used to check if space(t) is a subspace of V.\nvec(t) returns the coefficient vector data which allows to modify the tensor components\nfull(t) returns an Array{T,N} representation of a rank N tensor. Only when space(t) is a ProductSpace is this isomorphic to the vector of coefficients, otherwise zeros or repeated coefficients might appear. Therefore, full(t) does not share data with the tensor and cannot be used to modified its contens.","category":"page"},{"location":"man/old/#Constructing-and-converting-tensors-1","page":"TensorKit.jl","title":"Constructing and converting tensors","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"tensor(data,V) can be used to construct a DenseTensor. Here, data represents an arbitrary Array{T,N}. If the vector space V is provided, the multidimensional characteristics of data are ignored. Only vec(data) is used and the only requirement is that length(data) equals dim(V). If V is absent, then tensor(data) creates a CartesianTensor if T<:Real with V=ProductSpace(map(CartesianSpace,size(data))). If T<:Complex, a ComplexTensor is constructed, even though there it is already ambiguous whether the normal complex Euclidean space or the dual space should be constructed for every index.\nzeros(T,V) creates a tensor in V filled with zero coefficients, which is equivalent to the zero vector. If T is omitted, it is given the default value T=Float64.\nrand(T,V) creates a tensor in V filled with random coefficients. A default value of T=Float64 is asssumed when T is omitted.\nsimilar(t,T,V) constructs an unitialized tensor similar to t, but with element type T and for different space V (of the same type of space(t)).\ncomplex(t) converts t to a tensor with complex-valued coefficients; it does nothing if  eltype(t)<:Complex.\nreal(t) and imag(t) returns a tensor with the real and imaginary parts of the coefficients; this is a basis-dependent operations and refers to the canonical basis with respect to which the coefficients are stored.\nfloat32, float64, complex64 and complex128 can be used to cast the tensor coefficients into a specific format.","category":"page"},{"location":"man/old/#Basic-linear-algebra-methods-1","page":"TensorKit.jl","title":"Basic linear algebra methods","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The following methods allow to  perform basic linear algebra (corresponding to their interpretation as elements in a vector space):","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"arithmetic: tensors in the same vector space can be added, subtracted en multiplied with scalars. There are also mutating methods such as scale! and axpy!.\nconj(t) conjugates the tensor in the canonical basis. Note that this also maps the tensor to the space conj(V) which is different from V. Therefore, conj! is not an inplace operation but can be used to store the result of conjugating the tensor src in a preallocated tensor dst in conj(V) using conj!(dst,src).\ntranspose(t) implements an isomorphism from V=V1 ‚äó V2 ‚äó ... ‚äó VN to reverse(V) = VN ‚äó ... ‚äó V2 ‚äó V1, i.e. it reverses the order of the indices. For a tensor with N=1, this has no effect. For a tensor with N=2, this corresponds to the most general definition of the transpose of a linear map. A linear map fVto W can be identified with a tensor in W ‚äó dual(V). The transpose of this tensor lives in dual(V) ‚äó W, which can be identified with a linear map from dual(W) to dual(V), in accordance with the aforementioned definition. Only for real Euclidean vector spaces is dual(V) == V and does this correspond to a map from W to V.  For N>2, there is no standard definition of transpose, but reversing all indices corresponds to the convention used in the Penrose graphical notation, where transposing corresponds to mirroring the diagrammatic representation of the tensor. There is again a mutating version transpose!(dst,src) that allows to store the result of transposing src in the preallocated tensor dst.\nctranspose(t) is equivalent to conj(transpose(t)) but performs this operation in a single step. In particular, for N=2, it maps a tensor in W ‚äó dual(V) to a tensor in dual(conj(V)) ‚äó conj(W). For complex Euclidean spaces (where dual(V)=conj(V)) or real Euclidean spaces (where dual(V)=V and conj(V)=V), the conjugate transpose of a tensor in W ‚äó dual(V) is a tensor in V ‚äó dual(W), which can be interpreted as a linear map from W to V, according to the definition of the adjoint map. As before, ctranpose!(dst,src) stores the result in the preallocated destination tensor.\ndot(t1,t2) computers the inner product between two tensors t1 and t2. This is only possible if space(t1)==space(t2) and if this space is the tensor product of elementary vector spaces with an inner product, i.e. S<:InnerProductSpace. However, the interface for specifying general inner products still needs to be developed, and thus so far dot(t1,t2) only works if S<:EuclideanSpace. We choose the canonical basis of euclidean spaces orthonormal, such that dot(t1,t2) = dot(vec(t1),vec(t2)), i.e. the inner product corresponds to the normal scalar product of the coefficient vectors.\nvecnorm(t) computes the norm of tensor t; it is essentially equivalent to sqrt(dot(t,t)) and is therefore subject to the same restrictions (S<:EuclideanSpace) and satisfies vecnorm(t)=norm(vec(t)).","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Currently, conj, transpose and ctranspose allocate new tensors for storing the result. This might change in the future such that they return a simple view over the same data, although this is not entirely trivial for tensors which do not live in a simple ProductSpace{S,N}.","category":"page"},{"location":"man/old/#TODO:-Indexing-1","page":"TensorKit.jl","title":"TODO: Indexing","text":"","category":"section"},{"location":"man/old/#Tensor-operations-1","page":"TensorKit.jl","title":"Tensor operations","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"scalar(t) can be applied to a rank N=0 tensor to construct the single scalar component, since in that case space(t) is an empty tensor product space and thus equivalent to the corresponding number field.","category":"page"},{"location":"man/old/#Tensor-factorizations-1","page":"TensorKit.jl","title":"Tensor factorizations","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensor-Maps-1","page":"TensorKit.jl","title":"Tensor Maps","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Linear maps between tensor spaces with possible efficient implementation.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensor-Networks-1","page":"TensorKit.jl","title":"Tensor Networks","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Bibliography-1","page":"TensorKit.jl","title":"Bibliography","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"[tung]: Wu-Ki Tung. Group Theory in Physics: Introduction to Symmetry Principles, Group Representations, and Special Functions in Classical and Quantum Physics. World Scientific Publishing Company, 1985.  ","category":"page"}]
}
