var documenterSearchIndex = {"docs":
[{"location":"man/tensors/#Tensors-and-the-TensorMap-type-1","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Defining-and-constructing-tensor-maps-1","page":"Tensors and the TensorMap type","title":"Defining and constructing tensor maps","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Linear-algebra-operations-1","page":"Tensors and the TensorMap type","title":"Linear algebra operations","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Index-manipulations-1","page":"Tensors and the TensorMap type","title":"Index manipulations","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Tensor-contractions-and-tensor-networks-1","page":"Tensors and the TensorMap type","title":"Tensor contractions and tensor networks","text":"","category":"section"},{"location":"man/tensors/#","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"lib/spaces/#Vector-spaces-1","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"CurrentModule = TensorKit","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The type hierarchy for representing vector spaces","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"VectorSpace\nElementarySpace\nGeneralSpace\nInnerProductSpace\nEuclideanSpace\nCartesianSpace\nComplexSpace\nRepresentationSpace\nGenericRepresentationSpace\nFiniteRepresentationSpace\nCompositeSpace\nProductSpace","category":"page"},{"location":"lib/spaces/#TensorKit.VectorSpace","page":"Vector spaces","title":"TensorKit.VectorSpace","text":"abstract type VectorSpace end\n\nAbstract type at the top of the type hierarchy for denoting vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ElementarySpace","page":"Vector spaces","title":"TensorKit.ElementarySpace","text":"abstract type ElementarySpace{ùïú} <: VectorSpace end\n\nElementary finite-dimensional vector space over a field ùïú that can be used as the index space corresponding to the indices of a tensor.\n\nEvery elementary vector space should respond to the methods conj and dual, returning the complex conjugate space and the dual space respectively. The complex conjugate of the dual space is obtained as dual(conj(V)) === conj(dual(V)). These different spaces should be of the same type, so that a tensor can be defined as an element of a homogeneous tensor product of these spaces.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GeneralSpace","page":"Vector spaces","title":"TensorKit.GeneralSpace","text":"struct GeneralSpace{ùïú} <: ElementarySpace{ùïú}\n\nA finite-dimensional space over an arbitrary field ùïú without additional structure. It is thus characterized by its dimension, and whether or not it is the dual and/or conjugate space. For a real field ùïú, the space and its conjugate are the same.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.InnerProductSpace","page":"Vector spaces","title":"TensorKit.InnerProductSpace","text":"abstract type InnerProductSpace{ùïú} <: ElementarySpace{ùïú} end\n\nAbstract type for denoting vector with an inner product and a corresponding metric, which can be used to raise or lower indices of tensors.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.EuclideanSpace","page":"Vector spaces","title":"TensorKit.EuclideanSpace","text":"abstract type EuclideanSpace{ùïú} <: InnerProductSpace{ùïú} end\n\nAbstract type for denoting real or complex spaces with a standard (Euclidean) inner product (i.e. orthonormal basis), such that the dual space is naturally isomorphic to the conjugate space (in the complex case) or even to the space itself (in the real case), also known as the category of finite-dimensional Hilbert spaces FdHilb.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CartesianSpace","page":"Vector spaces","title":"TensorKit.CartesianSpace","text":"struct CartesianSpace <: EuclideanSpace{‚Ñù}\n\nA real euclidean space ‚Ñù^d, which is therefore self-dual. CartesianSpace has no additonal structure and is completely characterised by its dimension d. This is the vector space that is implicitly assumed in most of matrix algebra.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ComplexSpace","page":"Vector spaces","title":"TensorKit.ComplexSpace","text":"struct ComplexSpace <: EuclideanSpace{‚ÑÇ}\n\nA standard complex vector space ‚ÑÇ^d with Euclidean inner product and no additional structure. It is completely characterised by its dimension and whether its the normal space or its dual (which is canonically isomorphic to the conjugate space).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.RepresentationSpace","page":"Vector spaces","title":"TensorKit.RepresentationSpace","text":"abstract type RepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ} end\n\nComplex Euclidean space with a direct sum structure corresponding to different superselection sectors of type G<:Sector, e.g. the elements or irreps of a compact or finite group, or the labels of a unitary fusion category.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.GenericRepresentationSpace","page":"Vector spaces","title":"TensorKit.GenericRepresentationSpace","text":"struct GenericRepresentationSpace{G<:Sector} <: RepresentationSpace{G}\n\nGeneric implementation of a representation space, i.e. a complex Euclidean space with a direct sum structure corresponding to different superselection sectors of type G<:Sector, e.g. the irreps of a compact or finite group, or the labels of a unitary fusion category.\n\nThis fallback is used when IteratorSize(values(G)) == IsInfinite().\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.FiniteRepresentationSpace","page":"Vector spaces","title":"TensorKit.FiniteRepresentationSpace","text":"struct FiniteRepresentationSpace{G<:Sector,N} <: AbstractRepresentationSpace{G}\n\nOptimized implementation for a representation space (fusion category) with a finite number of labels (simple objects), i.e. a complex Euclidean space with a direct sum structure corresponding to different superselection sectors of type G<:Sector, e.g. the irreps of a finite group, or the labels of a unitary fusion category.\n\nThis fallback is used when IteratorSize(values(G)) is of type HasLength or HasShape.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CompositeSpace","page":"Vector spaces","title":"TensorKit.CompositeSpace","text":"abstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\n\nAbstract type for composite spaces that are defined in terms of a number of elementary vector spaces of a homogeneous type S<:ElementarySpace{ùïú}.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ProductSpace","page":"Vector spaces","title":"TensorKit.ProductSpace","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n\nA ProductSpace is a tensor product space of N vector spaces of type S<:ElementarySpace. Only tensor products between ElementarySpace objects of the same type are allowed.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The type hierarchy for representing sectors","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Sector\nFusionStyle\nBraidingStyle\nIrrep\nAbelianIrrep\nZNIrrep\nU1Irrep\nSU2Irrep\nCU1Irrep","category":"page"},{"location":"lib/spaces/#TensorKit.Sector","page":"Vector spaces","title":"TensorKit.Sector","text":"abstract type Sector end\n\nAbstract type for representing the label sets of graded vector spaces, which should correspond to (unitary) fusion categories.\n\nEvery new G<:Sector should implement the following methods:\n\none(::Type{G}) -> unit element of G\nconj(a::G) -> aÃÖ: conjugate or dual label of a\n‚äó(a::G, b::G) -> iterable with unique fusion outputs of a ‚äó b   (i.e. don't repeat in case of multiplicities)\nNsymbol(a::G, b::G, c::G) -> number of times c appears in a ‚äó b, i.e. the   multiplicity\nFusionStyle(::Type{G}) -> Abelian(), SimpleNonAbelian() or   DegenerateNonAbelian()\nBraidingStyle(::Type{G}) -> Bosonic(), Fermionic(), Anyonic(), ...\n\nand, if FusionStyle(G) == NonAbelian(),\n\nFsymbol(a::G, b::G, c::G, d::G, e::G, f::G) -> F-symbol: scalar (in case of   SimpleNonAbelian) or matrix (in case of DegenerateNonAbelian)\n... can all other information (quantum dimension, cups and caps) be extracted from F?\n\nand if BraidingStyle(G) == Fermionic()\n\nfermionparity(a::G) -> Bool representing the fermion parity of sector a   and optionally, if if FusionStyle(G) isa DegenerateNonAbelian\nvertex_ind2label(i::Int, a::G, b::G, c::G) -> a custom label for the ith copy of c appearing in a ‚äó b\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.FusionStyle","page":"Vector spaces","title":"TensorKit.FusionStyle","text":"function FusionStyle(G::Type{<:Sector}) -> ::FusionStyle\n\nReturn the type of fusion behavior of sectors of type G, which can be either\n\nAbelian(): single fusion output when fusing two sectors;\nSimpleNonAbelian(): multiple outputs, but every output occurs at most one,   also known as multiplicity free (e.g. irreps of SU(2));\nDegenerateNonAbelian(): multiple outputs that can occur more than once (e.g. irreps   of SU(3)).\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.BraidingStyle","page":"Vector spaces","title":"TensorKit.BraidingStyle","text":"function BraidingStyle(G::Type{<:Sector}) -> ::BraidingStyle\n\nReturn the type of braiding behavior of sectors of type G, which can be either\n\nBosonic(): trivial exchange\nFermionic(): fermionic exchange depending on fermionparity\nAnyonic(): requires general R_(a,b)^c phase or matrix   (depending on SimpleNonAbelian or DegenerateNonAbelian fusion)\n\nNote that Bosonic and Fermionic are subtypes of SymmetricBraiding, which means that braids are in fact equivalent to crossings (i.e. braiding twice is an identity: Rsymbol(b,a,c)*Rsymbol(a,b,c) = I) and permutations are uniquely defined.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.Irrep","page":"Vector spaces","title":"TensorKit.Irrep","text":"abstract type Irrep <: Sector end\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of groups. As we assume unitary representations, these would be finite groups or compact Lie groups. Note that this could also include projective rather than linear representations.\n\nAll irreps have BraidingStyle equal to Bosonic() and thus trivial twists. A fermionic sector can be created using Fermion.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.AbelianIrrep","page":"Vector spaces","title":"TensorKit.AbelianIrrep","text":"abstract type AbelianIrrep <: Irrep end\n\nAbstract supertype for sectors which corresponds to irreps (irreducible representations) of abelian groups. They all have FusionStyle equal to Abelian() and thus trivial topological data, which is real valued.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.ZNIrrep","page":"Vector spaces","title":"TensorKit.ZNIrrep","text":"struct ZNIrrep{N} <: AbelianIrrep\n    n::Int8\nend\n\nRepresents irreps of the group ‚Ñ§_N for some value of N<64. Unicode synonyms are available for the cases N=2,3,4 as ‚Ñ§‚ÇÇ, ‚Ñ§‚ÇÉ, ‚Ñ§‚ÇÑ. Also the name Parity can be used as synonym for ‚Ñ§‚ÇÇ.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.U1Irrep","page":"Vector spaces","title":"TensorKit.U1Irrep","text":"struct U1Irrep <: AbelianIrrep\n    charge::HalfInt\nend\n\nRepresents irreps of the group U‚ÇÅ == SO‚ÇÇ, both of which are valid unicode synonyms. The irrep is labelled by a charge, which should be an integer for a linear representation. However, it is often useful to allow half integers to represent irreps of U‚ÇÅ subgroups of SU‚ÇÇ. Hence, the charge is stored as a HalfInt from the package HalfIntegers.jl.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.SU2Irrep","page":"Vector spaces","title":"TensorKit.SU2Irrep","text":"struct SU2Irrep <: Irrep\n    j::HalfInt\nend\n\nRepresents irreps of the group SU‚ÇÇ, which is also a valid unicode synonym. The irrep is labelled by a half integer j, stored as a HalfInt from the HalfIntegers.jl package. Half-integer and integer irreps of SU‚ÇÇ are also projective and linear representation of SO‚ÇÉ, which is another valid unicode synonym.\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#TensorKit.CU1Irrep","page":"Vector spaces","title":"TensorKit.CU1Irrep","text":"struct CU1Irrep <: Irrep\n    j::HalfInt # value of the U1 charge\n    s::Int # rep of charge conjugation:\nend\n\nRepresents irreps of the group U‚ÇÅ  C (U‚ÇÅ and charge conjugation or reflection), which is also known as just O‚ÇÇ. Unicode synomyms are thus CU‚ÇÅ or O‚ÇÇ. The irrep is labelled by a positive half integer j (the U‚ÇÅ charge) and an integer s indicating the behaviour under charge conjugation. They take values:\n\nif j == 0, s = 0 (trivial charge conjugation) or s = 1 (non-trivial charge conjugation)\nif j > 0, s = 2 (two-dimensional representation)\n\n\n\n\n\n","category":"type"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Methods often apply similar to e.g. spaces and corresponding tensors or tensor maps, e.g.:","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"field\nsectortype\nsectors\nhassector\ndim\ndims\nblocksectors\nblockdim","category":"page"},{"location":"lib/spaces/#TensorKit.field","page":"Vector spaces","title":"TensorKit.field","text":"function field(V::VectorSpace) -> Field\n\nReturn the field type over which a vector space is defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectortype","page":"Vector spaces","title":"TensorKit.sectortype","text":"function sectortype(a) -> Sector\n\nReturn the type of sector over which object a (e.g. a representation space or a tensor) is defined. Also works in type domain.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.sectors","page":"Vector spaces","title":"TensorKit.sectors","text":"sectors(V::ElementarySpace) -> sectortype(V)\nsectors(V::ProductSpace{S,N}) -> NTuple{N,sectortype{V}}\n\nReturn the different sectors of object a (e.g. a representation space or a tensor).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.hassector","page":"Vector spaces","title":"TensorKit.hassector","text":"function hassector(V::VectorSpace, a::Sector) -> Bool\n\nReturn whether a vector space V has a subspace corresponding to sector a with non-zero dimension, i.e. dim(V, a) > 0.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dim","page":"Vector spaces","title":"TensorKit.dim","text":"dim(V::VectorSpace) -> Int\n\nReturn the total dimension of the vector space V as an Int.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dims","page":"Vector spaces","title":"TensorKit.dims","text":"dims(::ProductSpace{S,N}) -> Dims{N} = NTuple{N,Int}\n\nReturn the dimensions of the spaces in the tensor product space as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.blocksectors","page":"Vector spaces","title":"TensorKit.blocksectors","text":"dims(::ProductSpace{S,N}) -> Dims{N} = NTuple{N,Int}\n\nReturn the dimensions of the spaces in the tensor product space as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The following methods act specifically on ElementarySpace spaces:","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"isdual\ndual\nconj\nflip\n:‚äï\noneunit","category":"page"},{"location":"lib/spaces/#TensorKit.isdual","page":"Vector spaces","title":"TensorKit.isdual","text":"isdual(V::ElementarySpace) -> Bool\n\nReturn wether an ElementarySpace V is normal or rather a dual space. Always returns false for spaces where V == dual(V).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.dual","page":"Vector spaces","title":"TensorKit.dual","text":"dual(V::VectorSpace) -> VectorSpace\n\nReturn the dual space of V; also obtained via V'. It is assumed that typeof(V) == typeof(V').\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.conj","page":"Vector spaces","title":"Base.conj","text":"conj(V::S) where {S<:ElementarySpace} -> S\n\nReturn the conjugate space of V.\n\nFor field(V)==‚Ñù, conj(V) == V. It is assumed that typeof(V) == typeof(conj(V)).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.flip","page":"Vector spaces","title":"TensorKit.flip","text":"flip(V::S) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that has the same value of isdual as dual(V), but yet is isomorphic to V rather than to dual(V). The spaces flip(V) and dual(V) only differ in the case of RepresentationSpace{G}.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:‚äï","page":"Vector spaces","title":"TensorKit.:‚äï","text":"‚äï(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the direct sum sum of the spaces V1, V2, ... Note that all the individual spaces should have the same value for isdual, as otherwise the direct sum is not defined.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.oneunit","page":"Vector spaces","title":"Base.oneunit","text":"oneunit(V::S) where {S<:ElementarySpace} -> S\n\nReturn the corresponding vector space of type S that represents the trivial one-dimensional space, i.e. the space that is isomorphic to the corresponding field. Note that this is different from one(V::S), which returns the empty product space ProductSpace{S,0}(()).\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"or also on ProductSpace","category":"page"},{"location":"lib/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"fuse\n:‚äó\none\nmin\nmax","category":"page"},{"location":"lib/spaces/#TensorKit.fuse","page":"Vector spaces","title":"TensorKit.fuse","text":"fuse(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\nfuse(P::ProductSpace{S}) where {S<:ElementarySpace} -> S\n\nReturn a single vector space of type S that is isomorphic to the fusion product of the individual spaces V1, V2, ..., or the spaces contained in P.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#TensorKit.:‚äó","page":"Vector spaces","title":"TensorKit.:‚äó","text":"‚äó(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} -> S\n\nCreate a ProductSpace{S}(V1, V2, V3...) representing the tensor product of several elementary vector spaces. For convience, Julia's regular multiplication operator * applied to vector spaces has the same effect.\n\nThe tensor product structure is preserved, see fuse for returning a single elementary space of type S that is isomorphic to this tensor product.\n\n\n\n\n\n","category":"function"},{"location":"lib/spaces/#Base.one","page":"Vector spaces","title":"Base.one","text":"function one(::Sector) -> Sector\nfunction one(::Type{<:Sector}) -> Sector\n\nReturn the unit element within this type of sector.\n\n\n\n\n\none(::S) where {S<:ElementarySpace} -> ProductSpace{S,0}\none(::ProductSpace{S}) where {S<:ElementarySpace} -> ProductSpace{S,0}\n\nReturn a tensor product of zero spaces of type S, i.e. this is the unit object under the tensor product operation, such that V ‚äó one(V) == V.\n\n\n\n\n\n","category":"function"},{"location":"man/intro/#s_intro-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Before providing a typical \"user guide\" and discussing the implementation of TensorKit.jl on the next pages, let us discuss some of the rationale behind this package.","category":"page"},{"location":"man/intro/#ss_tensor-1","page":"Introduction","title":"What is a tensor?","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor t is an element from the   tensor product of N vector spaces   V_1  V_2  V_N, where N is referred to as the rank or order of the   tensor, i.e.\nt  V_1  V_2    V_N","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"If you think of a tensor as an object with indices, a rank N tensor has N indices where every index is associated with the corresponding vector space in that it labels a particular basis in that space. We will return to index notation at the very end of this manual.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"As the tensor product of vector spaces is itself a vector space, this implies that a tensor behaves as a vector, i.e. tensors from the same tensor product space can be added and multiplied by scalars. The tensor product is only defined for vector spaces over the same field of scalars, e.g. there is no meaning in ‚Ñù^5  ‚ÑÇ^3. When all the vector spaces in the tensor product have an inner product, this also implies an inner product for the tensor product space. It is hence clear that the different vector spaces in the tensor product should have some form of homogeneity in their structure, yet they do not need to be all equal and can e.g. have different dimensions. It goes without saying that defining the vector spaces and their properties will be an important part of the definition of a tensor. As a consequence, this also constitutes a significant part of the implementation, and is discussed in the section on Vector spaces.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Aside from the interpretation of a tensor as a vector, we also want to interpret it as a matrix (or more correctly, a linear map) in order to decompose tensors using linear algebra factorisations (e.g. eigenvalue or singular value decomposition). Henceforth, we use the term \"tensor map\" as follows:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor map t is a linear map from a source or domain   W_1  W_2    W_N_2 to a target or codomain V_1  V_2    V_N_1, i.e.\ntW_1  W_2    W_N_2  V_1  V_2    V_N_1","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor of rank N is then just a special case of a tensor map with N_1 = N and N_2 = 0. A contraction between two tensors is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise which vector spaces appear in the domain and the codomain of the tensor map, and in which order. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices (i.e. the vector spaces). For example, a linear map W  V is often denoted as a rank 2 tensor in V  W^*, where W^* corresponds to the dual space of W. This simple example introduces two new concepts.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Typical vector spaces can appear in the domain and codomain in different related forms,  e.g. as normal space or dual space. In fact, the most generic case is that every vector  space V has associated with it  a dual space V^*,  a conjugate space  overlineV and a conjugate dual space overlineV^*. The four different  vector spaces V, V^*, overlineV and overlineV^* correspond to the  representation spaces of respectively the fundamental, dual or contragredient, complex  conjugate and dual complex conjugate representation of the general linear group  mathsfGL(V) [tung]. In index notation these spaces are denoted with  respectively contravariant (upper), covariant (lower), dotted contravariant  and dotted covariant indices.\nFor real vector spaces, the conjugate (dual) space is identical to the normal (dual)  space and we only have upper and lower indices, i.e. this is the setting of e.g.  general relativity. For (complex) vector spaces with a sesquilinear inner product  overlineV  V  ‚ÑÇ, the inner product allows to define an isomorphism from the  conjugate space to the dual space (known as  Riesz representation theorem  in the more general context of Hilbert spaces).\nIn particular, in spaces with a Euclidean inner product (the setting of e.g. quantum  mechanics), the conjugate and dual space are naturally isomorphic (because the dual and  conjugate representation of the unitary group are the same). Again we only need upper  and lower indices (or kets and bras).\nFinally, in ‚Ñù^d with a Euclidean inner product, these four different spaces are all  equivalent and we only need one type of index. The space is completely characterized by  its dimension d. This is the setting of much of classical mechanics and we refer to  such tensors as cartesian tensors and the corresponding space as cartesian space. These  are the tensors that can equally well be represented as multidimensional arrays (i.e.  using some AbstractArray{<:Real,N} in Julia) without loss of structure.\nThe implementation of all of this is discussed in Vector spaces.\nIn the generic case, the identification between maps W  V and tensors in  V  W^* is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between V  W and W  V that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories, which is introduced on the next  page. Nonetheless, we try to hide these canonical isomorphisms from the user wherever  possible, and one does not need to know category theory to be able to use this package.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"This brings us to our final (yet formal) definition","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"A tensor (map) is a homomorphism between two objects from the category mathbfVect   (or some subcategory thereof). In practice, this will be mathbfFinVect, the   category of finite dimensional vector spaces. More generally even, our concept of a   tensor makes sense, in principle, for any linear (a.k.a. mathbfVect-enriched)   monoidal category. We refer to the section   \"Monoidal categories and their properties\".","category":"page"},{"location":"man/intro/#ss_symmetries-1","page":"Introduction","title":"Symmetries and block sparsity","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Physical problems often have some symmetry, i.e. the setup is invariant under the action of a group mathsfG which acts on the vector spaces V in the problem according to a certain representation. Having quantum mechanics in mind, TensorKit.jl is so far restricted to unitary representations. A general representation space V can be specified as the number of times every irreducible representation (irrep) a of mathsfG appears, i.e.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"V = bigoplus_a ‚ÑÇ^n_a  R_a","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"with R_a the space associated with irrep a of mathsfG, which itself has dimension d_a (often called the quantum dimension), and n_a the number of times this irrep appears in V. If the unitary irrep a for g  mathsfG is given by u_a(g), then the group action of mathsfG on V is given by the unitary representation","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"u(g) = bigoplus_a  ùüô_n_a  u_a(g)","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"with ùüô_n_a the n_a  n_a identity matrix. The total dimension of V is given by _a n_a d_a.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The reason for implementing symmetries is to exploit the computation and memory gains resulting from restricting to tensor maps tW_1  W_2    W_N_2  V_1  V_2    V_N_1 that are invariant under the symmetry, i.e. that act as intertwiners between the symmetry action on the domain and the codomain. Indeed, such tensors should be block diagonal because of Schur's lemma, but only after we couple the individual irreps in the spaces W_i to a joint irrep, which is then again split into the individual irreps of the spaces V_i. The basis change from the tensor product of irreps in the (co)domain to the joint irrep is implemented by a sequence of Clebsch‚ÄìGordan coefficients, also known as a fusion (or splitting) tree. We implement the necessary machinery to manipulate these fusion trees under index permutations and repartitions for arbitrary groups mathsfG. In particular, this fits with the formalism of monoidal categories, and more specifically fusion categories, and only requires the topological data of the group, i.e. the fusion rules of the irreps, their quantum dimensions and the F-symbol (6j-symbol or more precisely Racah's W-symbol in the case of mathsfSU_2). In particular, we don't actually need the Clebsch‚ÄìGordan coefficients themselves (but they can be useful for checking purposes).","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Further details are provided in Sectors, representation spaces and fusion trees.","category":"page"},{"location":"man/spaces/#s_spaces-1","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"using TensorKit","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"From the Introduction, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type VectorSpace","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type VectorSpace end","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"which serves in a sense as the category mathbfVect. All instances of subtypes of VectorSpace will represent vector spaces. In particular, we define two abstract subtypes","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type ElementarySpace{ùïú} <: VectorSpace end\nconst IndexSpace = ElementarySpace\n\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Here, ElementarySpace is a super type for all vector spaces that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace. It is parametrically dependent on ùïú, the field of scalars (see the next section on Fields).","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"On the other hand, subtypes of CompositeSpace{S} where S<:ElementarySpace are composed of a number of elementary spaces of type S. So far, there is a single concrete type ProductSpace{S,N} that represents the homogeneous tensor product of N vector spaces of type S. Its properties are discussed in the section on Composite spaces, together with possible extensions for the future.","category":"page"},{"location":"man/spaces/#ss_fields-1","page":"Vector spaces","title":"Fields","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces are defined over a field of scalars. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract type Field end\n\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\n\nconst ‚Ñù = RealNumbers()\nconst ‚ÑÇ = ComplexNumbers()","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Note that ‚Ñù and ‚ÑÇ can be typed as \\bbR+TAB and \\bbC+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia's Number hierarchy is to introduce some syntactic sugar without committing type piracy. In particular, we now have","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"3 ‚àà ‚Ñù\n5.0 ‚àà ‚ÑÇ\n5.0+1.0*im ‚àà ‚Ñù\nFloat64 ‚äÜ ‚Ñù\nComplexF64 ‚äÜ ‚ÑÇ\n‚Ñù ‚äÜ ‚ÑÇ\n‚ÑÇ ‚äÜ ‚Ñù","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"and furthermore‚Äîprobably more usefully‚Äî‚Ñù^n and ‚ÑÇ^n create specific elementary vector spaces as described in the next section. The underlying field of a vector space or tensor a can be obtained with field(a).","category":"page"},{"location":"man/spaces/#ss_elementaryspaces-1","page":"Vector spaces","title":"Elementary vector spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"As mentioned at the beginning of this section, vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of ElementarySpace. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type (i.e. with the same type parameters in case of a parametric type). In particular, every ElementarySpace should implement the following methods","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"dim(::ElementarySpace) -> ::Int returns the dimension of the space as an Int\ndual(::S) where {S<:ElementarySpace} -> ::S returns the   dual space dual(V), using an instance of   the same concrete type (i.e. not via type parameters); this should satisfy   dual(dual(V)==V\nconj(::S) where {S<:ElementarySpace} -> ::S returns the   complex conjugate space   conj(V), using an instance of the same concrete type (i.e. not via type parameters);   this should satisfy conj(conj(V))==V and we automatically have   conj(V::ElementarySpace{‚Ñù}) = V.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"For convenience, the dual of a space V can also be obtained as V'.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"There is concrete type GeneralSpace which is completely characterized by its field ùïú, its dimension and whether its the dual and/or complex conjugate of ùïú^d.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"struct GeneralSpace{ùïú} <: ElementarySpace{ùïú}\n    d::Int\n    dual::Bool\n    conj::Bool\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We furthermore define the abstract type","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract InnerProductSpace{ùïú} <: ElementarySpace{ùïú}","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to contain all vector spaces V which have an inner product and thus a canonical mapping from dual(V) to V (for ùïú ‚äÜ ‚Ñù) or from dual(V) to conj(V) (otherwise). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Finally there is","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"abstract EuclideanSpace{ùïú} <: InnerProductSpace{ùïú}","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to contain all spaces V with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms dual(V) == V (for ùïú == ‚Ñù) or dual(V) == conj(V) (for ùïú == ‚ÑÇ). In particular, we have two concrete types","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"immutable CartesianSpace <: EuclideanSpace{‚Ñù}\n    d::Int\nend\nimmutable ComplexSpace <: EuclideanSpace{‚ÑÇ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"to represent the Euclidean spaces ‚Ñù^d or ‚ÑÇ^d without further inner structure. They can be created using the syntax ‚Ñù^d and ‚ÑÇ^d, or (‚ÑÇ^d)'for the dual space of the latter. Note that the brackets are required because of the precedence rules, since d' == d for d::Integer. Some examples:","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"dim(‚Ñù^10)\n(‚Ñù^10)' == ‚Ñù^10\nisdual((‚ÑÇ^5))\nisdual((‚ÑÇ^5)')\nisdual((‚Ñù^5)')\ndual(‚ÑÇ^5) == (‚ÑÇ^5)' == conj(‚ÑÇ^5)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We refer to the next section on Sectors, representation spaces and fusion trees for further information about RepresentationSpace, which is another subtype of EuclideanSpace{‚ÑÇ} with an inner structure corresponding to the irreducible representations of a group.","category":"page"},{"location":"man/spaces/#ss_compositespaces-1","page":"Vector spaces","title":"Composite spaces","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Composite spaces are vector spaces that are built up out of individual elementary vector spaces. The most prominent (and currently only) example is a tensor product of N elementary spaces of the same type S, which is implemented as","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Given some V1::S, V2::S, V3::S of the same type S<:ElementarySpace, we can easily construct ProductSpace{S,3}((V1,V2,V3)) as ProductSpace(V1,V2,V3) or using V1 ‚äó V2 ‚äó V3, where ‚äó is simply obtained by typing \\otimes+TAB. In fact, for convenience, also the regular multiplication operator * acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"V1 = ‚ÑÇ^2\nV2 = ‚ÑÇ^3\nV1 ‚äó V2 ‚äó V1' == V1 * V2 * V1' == ProductSpace(V1,V2,V1') == ProductSpace(V1,V2) ‚äó V1'\nV1^3\ndim(V1 ‚äó V2)\ndims(V1 ‚äó V2)\ndual(V1 ‚äó V2)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Here, the new function dims maps dim to the individual spaces in a ProductSpace and returns the result as a tuple. Note that the rationale for the last result was explained in the subsection Duals of Monoidal categories and their properties (optional).","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Following Julia's Base library, the function one applied to a ProductSpace{S,N} returns the multiplicative identity, which is ProductSpace{S,0}. The same result is obtained when acting on an instance V of S::ElementarySpace directly, however note that V ‚äó one(V) will yield a ProductSpace{S,1}(V) and not V itself. Similar to Julia Base, one also works in the type domain.","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"In the future, other CompositeSpace types could be added. For example, the wave function of an N-particle quantum system in first quantization would require the introduction of a SymmetricSpace{S,N} or a AntiSymmetricSpace{S,N} for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of V^N, where V::S represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.","category":"page"},{"location":"man/spaces/#Some-more-functionality-1","page":"Vector spaces","title":"Some more functionality","text":"","category":"section"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Some more convenience functions are provided for the euclidean spaces CartesianSpace and ComplexSpace, as well as for RepresentationSpace discussed in the next section. All functions below that act on more than a single elementary space, are only defined when the different spaces are of the same concrete subtype S<:ElementarySpace","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"The function fuse(V1, V2, ...) or fuse(V1 ‚äó V2 ‚äó ...) returns an elementary space that is isomorphic to V1 ‚äó V2 ‚äó ..., in the sense that a unitary tensor map can be constructed between those spaces, e.g. from W = V1 ‚äó V2 ‚äó ... to V = fuse(V1 ‚äó V2 ‚äó ...). The function flip(V1) returns a space that is isomorphic to V1 but has isdual(flip(V1)) == isdual(V1'), i.e. if V1 is a normal space than flip(V1) is a dual space. Again, isomorphism here implies that a unitary map (but there is no canonical choice) can be constructed between both spaces. flip(V1) is different from dual(V1) in the case of RepresentationSpace. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from V1 to flip(V1). We refer to [Index operations](@ref) for further information. Some examples:","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"fuse(‚Ñù^5, ‚Ñù^3)\nfuse(‚ÑÇ^3, (‚ÑÇ^5)', ‚ÑÇ^2)\nflip(‚ÑÇ^4)","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"We also define the direct sum V1 and V2 as V1 ‚äï V2, where ‚äï is obtained by typing \\oplus+TAB. This is possible only if isdual(V1) == isdual(V2). With a little pun on Julia Base, oneunit applied to an elementary space (in the value or type domain) returns the one-dimensional space, which is isomorphic to the scalar field of the space itself. Some examples illustrate this better","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"‚Ñù^5 ‚äï ‚Ñù^3\n‚ÑÇ^5 ‚äï ‚ÑÇ^3\n‚ÑÇ^5 ‚äï (‚ÑÇ^3)'\noneunit(‚Ñù^3)\n‚ÑÇ^5 ‚äï oneunit(ComplexSpace)\noneunit((‚ÑÇ^3)')\n(‚ÑÇ^5) ‚äï oneunit((‚ÑÇ^5))\n(‚ÑÇ^5)' ‚äï oneunit((‚ÑÇ^5)')","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"For two spaces V1 and V2, min(V1,V2) returns the space with the smallest dimension, whereas max(V1,V2) returns the space with the largest dimension, as illustrated by","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"min(‚Ñù^5, ‚Ñù^3)\nmax(‚ÑÇ^5, ‚ÑÇ^3)\nmax(‚ÑÇ^5, (‚ÑÇ^3)')","category":"page"},{"location":"man/spaces/#","page":"Vector spaces","title":"Vector spaces","text":"Again, we impose isdual(V1) == isdual(V2). As before, the use of these methods is to construct unitary or isometric tensors that map between different spaces, which will be elaborated upon in the section on Tensors.","category":"page"},{"location":"man/sectors/#s_sectorsrepfusion-1","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"using TensorKit","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. In particular, the Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The corresponding vector spaces will be canonically represented as V = _a ‚ÑÇ^n_a  R_a, where a labels the different irreps, n_a is the number of times irrep a appears and R_a is the vector space associated with irrep a. Irreps are also known as spin sectors (in the case of mathsfSU_2) or charge sectors (in the case of mathsfU_1), and we henceforth refer to a as a sector. As is briefly discussed below, the approach we follow does in fact go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a (ribbon) fusion category. Nonetheless, every step can be appreciated by using the representation theory of mathsfSU_2 or mathsfSU_3 as example. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space V is completely specified by the values of n_a.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors. The transformation from the uncoupled sectors in the domain (or codomain) of the tensor map to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group's Clebsch‚ÄìGordan (CG) coefficients. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or 6j-symbols (more accurately, the F-symbol is actually Racah's W-coefficients in the case of mathsfSU_2).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space V composed of a direct sum of different sectors. In the third section, we explain the details of fusion trees, i.e. their construction and manipulation. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists. But first, we provide a quick theoretical overview of the required data of the representation theory of a group.","category":"page"},{"location":"man/sectors/#ss_representationtheory-1","page":"Sectors, representation spaces and fusion trees","title":"Representation theory and unitary fusion categories","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let the different irreps or sectors be labeled as a, b, c, ‚Ä¶ First and foremost, we need to specify the fusion rules a  b =  N_ab^c c with N_ab^c some non-negative integers. There should always exists a unique trivial sector u such that a  u = a = u  a. Furthermore, there should exist a unique sector overlinea such that N_aoverlinea^u = 1, whereas for all b neq overlinea, N_ab^u = 0. For unitary irreps of groups, overlinea corresponds to the complex conjugate of the representation a, or a representation isomorphic to it. For example, for the representations of mathsfSU_2, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. a = overlinea), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are however not equal but related by a similarity transform).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The meaning of the fusion rules is that the space of transformations R_a  R_b  R_c (or vice versa) has dimension N_ab^c. In particular, we assume the existence of a basis consisting of unitary tensor maps X_ab^cŒº  R_c  R_a  R_b with Œº = 1  N_ab^c such that","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X_ab^cŒº)^ X_ab^cŒº = mathrmid_R_c","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_Œº = 1^N_ab^c X_ab^cŒº (X_ab^cŒº)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X_ab^cŒº are the splitting tensors, their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e. acting on the multiplicity label Œº = 1  N_ab^c. For mathsfSU_2, where N_ab^c is zero or one and the multiplicity labels are absent, the entries of X_ab^c are precisely given by the CG coefficients. The point is that we do not need to know the tensors X_ab^cŒº explicitly, but only the topological data of (the representation category of) the group, which describes the following transformation:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation between (a  b)  c to a  (b  c):\n(X_ab^eŒº  mathrmid_c)  X_ec^dŒΩ = _fŒ∫Œª F^abc_d^eŒºŒΩ_fŒ∫Œª (mathrmid_a  X_bc^fŒ∫)  X_af^dŒª\nBraiding or permuting as defined by œÉ_ab R_a  R_b  R_b  R_a:\nœÉ_R_aR_b  X_ab^cŒº = _ŒΩ R_ab^c^Œº_ŒΩ X_ba^cŒΩ","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The dimensions of the spaces R_a on which representation a acts are denoted as d_a and referred to as quantum dimensions. In particular d_u = 1 and d_a = d_overlinea. This information is also encoded in the F-symbol as d_a =  F^a overlinea a_a^u_u ^-1. Note that there are no multiplicity labels in that particular F-symbol as N_aoverlinea^u = 1.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If, for every a and b, there is a unique c such that a  b = c (i.e. N_ab^c = 1 and N_ab^c = 0 for all other c), the category is abelian. Indeed, the representations of a group have this property if and only if the group multiplication law is commutative. In that case, all spaces R_a associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all N_ab^c equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of mathsfSU_2, and those where some N_ab^c are larger than one, e.g. the representations of mathsfSU_3.","category":"page"},{"location":"man/sectors/#ss_sectors-1","page":"Sectors, representation spaces and fusion trees","title":"Sectors","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We introduce a new abstract type to represent different possible sectors","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Sector end","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Any concrete subtype of Sector should be such that its instances represent a consistent set of sectors, corresponding to the irreps of some group, or, more generally, the simple objects of a (unitary) fusion category. We refer to Appendix E of [kitaev] for a good reference.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The minimal data to completely specify a type of sector are","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"the fusion rules, i.e. a  b =  N_ab^c c; this is implemented by a function   Nsymbol(a,b,c)\nthe list of fusion outputs from a  b; while this information is contained in   N_ab^c, it might be costly or impossible to iterate over all possible values of   c and test Nsymbol(a,b,c); instead we implement for a ‚äó b to return an iterable   object (e.g. tuple, array or a custom Julia type that listens to Base.iterate) and   which generates all c for which N_ab^c  0 (just once even if N_ab^c1)\nthe identity object u, such that a  u = a = u  a; this is implemented by the   function one(a) (and also in type domain) from Julia Base\nthe dual or conjugate representation overlinea for which   N_aoverlinea^u = 1; this is implemented by conj(a) from Julia Base;   dual(a) also works as alias, but conj(a) is the method that should be defined\nthe F-symbol or recoupling coefficients F^abc_d^e_f, implemented as the   function Fsymbol(a,b,c,d,e,f)\nthe R-symbol R_ab^c, implemented as the function Rsymbol(a,b,c)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For practical reasons, we also require some additional methods to be defined:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"isreal(::Type{<:Sector}) returns whether the topological data of this type of sector   is real-valued or not (in which case it is complex-valued). Note that this does not   necessarily require that the representation itself, or the Clebsch-Gordan coefficients,   are real. There is a fallback implementation that checks whether the F-symbol and R-symbol evaluated with all sectors equal to the identity sector have real eltype.\nhash(a, h) creates a hash of sectors, because sectors and objects created from them   are used as keys in lookup tables (i.e. dictionaries)\nisless(a,b) associates a canonical order to sectors (of the same type), in order to   unambiguously represent representation spaces V = _a ‚ÑÇ^n_a  R_a.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Further information, such as the quantum dimensions d_a and Frobenius-Schur indicator œá_a (only if a == overlinea) are encoded in the F-symbol. They are obtained as dim(a) and frobeniusschur(a). These functions have default definitions which extract the requested data from Fsymbol(a,conj(a),a,a,one(a),one(a)), but they can be overloaded in case the value can be computed more efficiently.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We also define a parametric type to represent an indexable iterator over the different values of a sector as","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorValues{G<:Sector} end\nBase.IteratorEltype(::Type{<:SectorValues}) = HasEltype()\nBase.eltype(::Type{SectorValues{G}}) where {G<:Sector} = G\nBase.values(::Type{G}) where {G<:Sector} = SectorValues{G}()","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that an instance of the singleton type SectorValues{G} is obtained as values(G). A new sector G<:Sector should define","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.iterate(::SectorValues{G}[, state]) = ...\nBase.IteratorSize(::Type{SectorValues{G}}) = # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::SectorValues{G}) = ...\nBase.getindex(::SectorValues{G}, i::Int) = ...\nfindindex(::SectorValues{G}, c::G) = ...","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If the number of values in a sector G is finite (i.e. IteratorSize(values(G)) == HasLength()), the methods getindex and findindex provide a way to map the different sector values from and to the standard range 1, 2, ‚Ä¶, length(values(G)). This is used to efficiently represent RepresentationSpace objects for this type of sector, as discussed in the next section on Representation Spaces. Note that findindex acts similar to Base.indexin, but with the order of the arguments reversed (so that is more similar to getindex), and returns an Int rather than an Array{0,Union{Int,Nothing}}.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is useful to distinguish between three cases with respect to the fusion rules. For irreps of Abelian groups, we have that for every a and b, there exists a unique c such that a  b = c, i.e. there is only a single fusion channel. This follows simply from the fact that all irreps are one-dimensional. All other cases are referred to as non-abelian, i.e. the irreps of a non-abelian group or some more general fusion category. We still distinguish between the case where all entries of N_ab^c  1, i.e. they are zero or one. In that case, F^abc_d^e_f and R_ab^c are scalars. If some N_ab^c  1, it means that the same sector c can appear more than once in the fusion product of a and b, and we need to introduce some multiplicity label Œº for the different copies. We implement a \"trait\" (similar to IndexStyle for AbstractArrays in Julia Base), i.e. a type hierarchy","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type FusionStyle end\nstruct Abelian <: FusionStyle\nend\nabstract type NonAbelian <: FusionStyle end\nstruct SimpleNonAbelian <: NonAbelian # non-abelian fusion but multiplicity free\nend\nstruct DegenerateNonAbelian <: NonAbelian # non-abelian fusion with multiplicities\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types G<:Sector should then indicate which fusion style they have by defining FusionStyle(::Type{G}).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In a similar manner, it is useful to distinguish between different styles of braiding. Remember that for group representations, braiding acts as swapping or permuting the vector spaces involved. By definition, applying this operation twice leads us back to the original situation. If that is the case, the braiding is said to be symmetric. For more general fusion categories, associated with the physics of anyonic particles, this is generally not the case and, as a result, permutations of tensor indices are not unambiguously defined. The correct description is in terms of the braid group. This will be discussed in more detail below. Fermions are somewhat in between, as their braiding is symmetric, but they have a non-trivial twist. We thereto define a new type hierarchy","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type BraidingStyle end # generic braiding\nabstract type SymmetricBraiding <: BraidingStyle end\nstruct Bosonic <: SymmetricBraiding end\nstruct Fermionic <: SymmetricBraiding end\nstruct Anyonic <: BraidingStyle end","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types G<:Sector should then indicate which fusion style they have by defining BraidingStyle(::Type{G}). Note that Bosonic() braiding does not mean that all permutations are trivial and R_{a,b}^c = 1, but that R_{a,b}^c R_{b,a}^c = 1. For example, for the irreps of mathsfSU_2, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is -1, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a Bosonic() braiding style, all twists are simply +1. The case of fermions and anyons are discussed below.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Before discussing in more detail how a new sector type should be implemented, let us study the cases which have already been implemented. Currently, they all correspond to the irreps of groups.","category":"page"},{"location":"man/sectors/#sss_groups-1","page":"Sectors, representation spaces and fusion trees","title":"Existing group representations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first sector type is called Trivial, and corresponds to the case where there is actually no symmetry, or thus, the symmetry is the trivial group with only an identity operation and a trivial representation. Its representation theory is particularly simple:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct Trivial <: Sector\nend\nBase.one(a::Sector) = one(typeof(a))\nBase.one(::Type{Trivial}) = Trivial()\nBase.conj(::Trivial) = Trivial()\n‚äó(::Trivial, ::Trivial) = (Trivial(),)\nNsymbol(::Trivial, ::Trivial, ::Trivial) = true\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1\nBase.isreal(::Type{Trivial}) = true\nFusionStyle(::Type{Trivial}) = Abelian()\nBraidingStyle(::Type{Trivial}) = Bosonic()","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The Trivial sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For all abelian groups, we gather a number of common definitions","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type AbelianIrrep <: Sector end\n\nBase.@pure FusionStyle(::Type{<:AbelianIrrep}) = Abelian()\nBase.@pure BraidingStyle(::Type{<:AbelianIrrep}) = Bosonic()\n\nNsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = c == first(a ‚äó b)\nFsymbol(a::G, b::G, c::G, d::G, e::G, f::G) where {G<:AbelianIrrep} =\n    Int(Nsymbol(a,b,e)*Nsymbol(e,c,d)*Nsymbol(b,c,f)*Nsymbol(a,f,d))\nfrobeniusschur(a::AbelianIrrep) = 1\nBsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = Float64(Nsymbol(a, b, c))\nRsymbol(a::G, b::G, c::G) where {G<:AbelianIrrep} = Float64(Nsymbol(a, b, c))\nBase.isreal(::Type{<:AbelianIrrep}) = true","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With these common definition, we implement the representation theory of the two most common Abelian groups, namely ‚Ñ§_N","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct ZNIrrep{N} <: AbelianIrrep\n    n::Int8\n    function ZNIrrep{N}(n::Integer) where {N}\n        new{N}(mod(n, N))\n    end\nend\nBase.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)\nBase.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)\n‚äó(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)\n\nBase.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()\nBase.length(::SectorValues{ZNIrrep{N}}) where N = N\nBase.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =\n    return i == N ? nothing : (ZNIrrep{N}(i), i+1)\nBase.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =\n    1 <= i <= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))\nfindindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and mathsfU_1","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct U1Irrep <: AbelianIrrep\n    charge::HalfInt\nend\nBase.one(::Type{U1Irrep}) = U1Irrep(0)\nBase.conj(c::U1Irrep) = U1Irrep(-c.charge)\n‚äó(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)\n\nBase.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{U1Irrep}, i = 0) =\n    return i <= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)\n# the following are not used and thus not really necessary\nfunction Base.getindex(::SectorValues{U1Irrep}, i::Int)\n    i < 1 && throw(BoundsError(values(U1Irrep), i))\n    return U1Irrep(iseven(i) ? half(i>>1) : -half(i>>1))\nend\nfindindex(::SectorValues{U1Irrep}, c::U1Irrep) = (n = twice(c.charge); 2*abs(n)+(n<=0))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We also define some abbreviated Unicode aliases","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const ‚Ñ§‚ÇÇ = ZNIrrep{2}\nconst ‚Ñ§‚ÇÉ = ZNIrrep{3}\nconst ‚Ñ§‚ÇÑ = ZNIrrep{4}\nconst U‚ÇÅ = U1Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In the definition of U1Irrep, HalfInt<:Number is a Julia type defined in HalfIntegers.jl, which is also used for SU2Irrep below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of U‚ÇÅ can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of HalfInt, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"U‚ÇÅ(0.5)\nU‚ÇÅ(0.4)\nU‚ÇÅ(1) ‚äó U‚ÇÅ(1//2)\nu = first(U‚ÇÅ(1) ‚äó U‚ÇÅ(1//2))\nNsymbol(u, conj(u), one(u))\nz = ‚Ñ§‚ÇÉ(1)\nz ‚äó z\nconj(z)\none(z)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For ZNIrrep{N}, we use an Int8 for compact storage, assuming that this type will not be used with N>64 (we need 2*(N-1) <= 127 in order for a ‚äó b to work correctly).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As a further remark, even in the abelian case where a ‚äó b is equivalent to a single new label c, we return it as an iterable container, in this case a one-element tuple (c,).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned above, we also provide the following definitions","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)\nBase.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)\nBase.isless(c1::U1Irrep, c2::U1Irrep) where {N} =\n    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) < c1.charge == -c2.charge","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Since sectors or objects made out of tuples of sectors (see the section on Fusion Trees below) are often used as keys in look-up tables (i.e. subtypes of AbstractDictionary in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value. Note that hashes will only be used to compare sectors of the same type. The isless function provides a canonical order for sectors of a given type G<:Sector, which is useful to uniquely and unambiguously specify a representation space V = _a ‚ÑÇ^n_a  R_a, as described in the section on Representation spaces below.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first example of a non-abelian representation category is that of mathsfSU_2, the implementation of which is summarized by","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SU2Irrep <: Sector\n    j::HalfInt\nend\nBase.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))\nBase.conj(s::SU2Irrep) = s\n‚äó(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))\ndim(s::SU2Irrep) = s.j.num+1\nBase.@pure FusionStyle(::Type{SU2Irrep}) = SimpleNonAbelian()\nNsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.Œ¥(sa.j, sb.j, sc.j)\nFsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,\n        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =\n    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return 0.\n    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0\nend\nBase.hash(s::SU2Irrep, h::UInt) = hash(s.j, h)\nBase.isless(s1::SU2Irrep, s2::SU2Irrep) = isless(s1.j, s2.j)\nconst SU‚ÇÇ = SU2Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and some methods for pretty printing and converting from real numbers to irrep labels. As one can notice, the topological data (i.e. Nsymbol and Fsymbol) are provided by the package WignerSymbols.jl. The iterable a ‚äó b is a custom type, that the user does not need to care about. Some examples","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = SU‚ÇÇ(3//2)\nconj(s)\ndim(s)\ncollect(s ‚äó s)\nfor s‚Ä≤ in s ‚äó s\n    @show Nsymbol(s, s, s‚Ä≤)\n    @show Rsymbol(s, s, s‚Ä≤)\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A final non-abelian representation theory is that of the semidirect product mathsfU‚ÇÅ  ‚Ñ§_2, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of ‚Ñ§_2 acts as charge conjugation C. It has the effect of interchaning mathsfU_1 irreps n and -n, and turns them together in a joint 2-dimensional index, except for the case n=0. Irreps are therefore labeled by integers n  0, however for n=0 the ‚Ñ§‚ÇÇ symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with mathsfU)_1 charge 0. Given mathsfU_1  mathsfSO_2, this group is also simply known as mathsfO_2, and the two representations with n = 0 are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as CU‚ÇÅ or CU1Irrep in full.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct CU1Irrep <: Sector\n    j::HalfInteger # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::HalfInteger, s::Int = ifelse(j>0, 2, 0))\n        if ((j > 0 && s == 2) || (j == 0 && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU‚ÇÅ irrep\")\n        end\n    end\nend\nBase.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInteger), 0)\nBase.conj(c::CU1Irrep) = c\ndim(c::CU1Irrep) = ifelse(c.j == zero(HalfInteger), 1, 2)\nBase.@pure FusionStyle(::Type{CU1Irrep}) = SimpleNonAbelian()\n...\nconst CU‚ÇÅ = CU1Irrep","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of Fsymbol.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"So far, no sectors have been implemented with FusionStyle(G) == DegenerateNonAbelian(), though an example would be the representation theory of mathsfSU_3. Such sectors are not yet fully supported; certain operations remain to be implemented.","category":"page"},{"location":"man/sectors/#sss_productsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Combining different sectors","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator √ó, which can be entered as \\times+TAB. Some examples","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = ‚Ñ§‚ÇÉ(1) √ó U‚ÇÅ(1)\ntypeof(a)\nconj(a)\none(a)\ndim(a)\ncollect(a ‚äó a)\nFusionStyle(a)\nb = ‚Ñ§‚ÇÉ(1) √ó SU‚ÇÇ(3//2)\ntypeof(b)\nconj(b)\none(b)\ndim(b)\ncollect(b ‚äó b)\nFusionStyle(c)\nc = SU‚ÇÇ(1) √ó SU‚ÇÇ(3//2)\ntypeof(c)\nconj(c)\none(c)\ndim(c)\ncollect(c ‚äó c)\nFusionStyle(c)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We refer to the source file of ProductSector for implementation details.","category":"page"},{"location":"man/sectors/#sss_newsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Defining a new type of sector","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"By know, it should be clear how to implement a new Sector subtype. Ideally, a new G<:Sector type is a struct G ... end (immutable) that has isbitstype(G) == true (see Julia's manual), and implements the following minimal set of methods","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.one(::Type{G}) = G(...)\nBase.conj(a::G) = G(...)\nBase.isreal(::Type{G}) = ... # true or false\nTensorKit.FusionStyle(::Type{G}) = ... # Abelian(), SimpleNonAbelian(), DegenerateNonAbelian()\nTensorKit.BraidingStyle(::Type{G}) = ... # Bosonic(), Fermionic(), Anyonic()\nTensorKit.Nsymbol(a::G, b::G, c::G) = ...\n    # Bool or Integer if FusionStyle(G) == DegenerateNonAbelian()\nBase.:‚äó(a::G, b::G) = ... # some iterable object that generates all possible fusion outputs\nTensorKit.Fsymbol(a::G, b::G, c::G, d::G, e::G, f::G)\nTensorKit.Rsymbol(a::G, b::G, c::G)\nBase.hash(a::G, h::UInt)\nBase.isless(a::G, b::G)\nBase.iterate(::TensorKit.SectorValues{G}[, state]) = ...\nBase.IteratorSize(::Type{TensorKit.SectorValues{G}}) = ... # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::TensorKit.SectorValues{G}) = ...\nBase.getindex(::TensorKit.SectorValues{G}, i::Int) = ...\nTensorKit.findindex(::TensorKit.SectorValues{G}, c::G) = ...","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Additionally, suitable definitions can be given for","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.dim(a::G) = ...\nTensorKit.frobeniusschur(a::G) = ...\nTensorKit.Bsymbol(a::G, b::G, c::G) = ...","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If FusionStyle(G) == DegenerateNonAbelian(), then the multiple outputs c in the tensor product of a and b will be labeled as i=1, 2, ‚Ä¶, Nsymbol(a,b,c). Optionally, a different label can be provided by defining","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorKit.vertex_ind2label(i::Int, a::G, b::G, c::G) = ...\n# some label, e.g. a `Char` or `Symbol`","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following function will then automatically determine the corresponding label type (which should not vary, i.e. vertex_ind2label should be type stable)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.@pure vertex_labeltype(G::Type{<:Sector}) =\n    typeof(vertex_ind2label(1, one(G), one(G), one(G)))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following type, which already appeared in the implementation of SU2Irrep above, can be useful for providing the return type of a ‚äó b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorSet{G<:Sector,F,S}\n    f::F\n    set::S\nend\n...\nfunction Base.iterate(s::SectorSet{G}, args...) where {G<:Sector}\n    next = iterate(s.set, args...)\n    next === nothing && return nothing\n    val, state = next\n    return convert(G, s.f(val)), state\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"That is, SectorSet(f, set) behaves as an iterator that applies x->convert(G, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.","category":"page"},{"location":"man/sectors/#sss_generalsectors-1","page":"Sectors, representation spaces and fusion trees","title":"Generalizations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned before, the framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary fusion category. In fact, because we also need a braiding (corresponding to Rsymbol(a,b,c)) it is a so- called ribbon fusion category. However, the category does not need to be modular.  The category of representations of a finite group[1] corresponds to a typical example (which is not modular and which have a symmetric braiding). Other examples are the representation of quasi-triangular Hopf algebras, which are typically known as anyon theories in the physics literature, e.g. Fibonacci anyons, Ising anyons, ‚Ä¶ In those cases, quantum dimensions d_a are non-integer, and there is no vector space interpretation to objects R_a (which we can identify with just a) in the decomposition V = _a ‚ÑÇ^n_a  R_a. The different sectors a, ‚Ä¶ just represent abstract objects. However, there is still a vector space associated with the homomorphisms a  b  c, whose dimension is N_ab^c. The objects X_ab^cŒº for Œº = 1N_ab^c serve as an abstract basis for this space and from there on the discussion is completely equivalent.","category":"page"},{"location":"man/sectors/#ss_rep-1","page":"Sectors, representation spaces and fusion trees","title":"Representation spaces","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We have introduced Sector subtypes as a way to label the irreps or sectors in the decomposition V = _a ‚ÑÇ^n_a  R_a. To actually represent such spaces, we now also introduce a corresponding type RepresentationSpace, which is a subtype of EuclideanSpace{‚ÑÇ}, i.e.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type RepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ} end","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that this is still an abstract type, nonetheless it will be the type name that the user calls to create specific instances.","category":"page"},{"location":"man/sectors/#Types-1","page":"Sectors, representation spaces and fusion trees","title":"Types","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The actual implementation comes in two flavors","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct GenericRepresentationSpace{G<:Sector} <: RepresentationSpace{G}\n    dims::SectorDict{G,Int}\n    dual::Bool\nend\nstruct FiniteRepresentationSpace{G<:Sector,N} <: RepresentationSpace{G}\n    dims::NTuple{N,Int}\n    dual::Bool\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The GenericRepresentationSpace implementation stores the different sectors a and their corresponding degeneracy n_a as key value pairs in an Associative array, i.e. a dictionary dims::SectorDict. SectorDict is a constant type alias for a specific dictionary implementation, either Julia's default Dict or the type SortedVectorDict implemented in TensorKit.jl. Note that only sectors a with non-zero n_a are stored. This implementation is used for sectors G which have IteratorSize(values(G)) == IsInfinite().","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If IteratorSize(values(G)) == HasLength(), the second implementation FiniteRepresentationSpace is used instead, which stores the values n_a for the different sectors in a tuple, the lenght of which is given by N = length(values(G)). The methods getindex(values(G), i) and findindex(values(G), a) are used to map between a sector a::G and a corresponding index i ‚àà 1:N.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As mentioned, creating instances of these types goes via RepresentationSpace, using a list of pairs a=>n_a, i.e. V = RepresentationSpace(a=>n_a, b=>n_b, c=>n_c). In this case, the sector type G is inferred from the sectors. However, it is often more convenient to specify the sector type explicitly, since then the sectors are automatically converted to the correct type, i.e. compare","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"RepresentationSpace{U1Irrep}(0=>3, 1=>2, -1=>1) ==\n    RepresentationSpace(U1Irrep(0)=>3, U1Irrep(1)=>2, U1Irrep(-1)=>1)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"or using Unicode","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"RepresentationSpace{U‚ÇÅ}(0=>3, 1=>2, -1=>1) ==\n    RepresentationSpace(U‚ÇÅ(0)=>3, U‚ÇÅ(-1)=>1, U‚ÇÅ(1)=>2)","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"However, both are still to long for the most common cases. Therefore, we provide a number of type aliases, both in plain ASCII and in Unicode","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const ‚Ñ§‚ÇÇSpace = ZNSpace{2}\nconst ‚Ñ§‚ÇÉSpace = ZNSpace{3}\nconst ‚Ñ§‚ÇÑSpace = ZNSpace{4}\nconst U‚ÇÅSpace = GenericRepresentationSpace{U‚ÇÅ}\nconst CU‚ÇÅSpace = GenericRepresentationSpace{CU‚ÇÅ}\nconst SU‚ÇÇSpace = GenericRepresentationSpace{SU‚ÇÇ}\n\n# non-Unicode alternatives\nconst Z2Space = ‚Ñ§‚ÇÇSpace\nconst Z3Space = ‚Ñ§‚ÇÉSpace\nconst Z4Space = ‚Ñ§‚ÇÑSpace\nconst U1Space = U‚ÇÅSpace\nconst CU1Space = CU‚ÇÅSpace\nconst SU2Space = SU‚ÇÇSpace","category":"page"},{"location":"man/sectors/#Methods-1","page":"Sectors, representation spaces and fusion trees","title":"Methods","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There are a number of methods to work with instances V of RepresentationSpace. The function sectortype returns the type of the sector labels. It also works on other vector spaces, in which case it returns Trivial. The function sectors returns an iterator over the different sectors a with non-zero n_a, for other ElementarySpace types it returns (Trivial,). The degeneracy dimensions n_a can be extracted as dim(V, a), it properly returns 0 if sector a is not present in the decomposition of V. With hassector(V, a) one can check if V contains a sector a with dim(V,a)>0. Finally, dim(V) returns the total dimension of the space V, i.e. _a n_a d_a or thus dim(V) = sum(dim(V,a) * dim(a) for a in sectors(V)).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Other methods for ElementarySpace, such as dual, fuse and flip also work. In fact, RepresentationSpace is the reason flip exists, cause in this case it is different then dual. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a. In order for flip(V) to be isomorphic to V, it is such that, if V = RepresentationSpace(a=>n_a,...) then flip(V) = dual(RepresentationSpace(dual(a)=>n_a,....)).","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Furthermore, for two spaces V1 = RepresentationSpace(a=>n1_a, ...) and V2 = RepresentationSpace(a=>n2_a, ...), we have min(V1,V2) = RepresentationSpace(a=>min(n1_a,n2_a), ....) and similarly for max, i.e. they act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of min(V1,V2) or max(V1,V2) is neither equal to V1 or V2.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For W a ProductSpace{<:RepresentationSpace{G},N}, sectors(W) returns an iterator that generates all possible combinations of sectors as represented as NTuple{G,N}. The function dims(W, as) returns the corresponding tuple with degeneracy dimensions, while dim(W, as) returns the product of these dimensions. hassector(W, as) is equivalent to dim(W, as)>0. Finally, there is the function blocksectors(W) which returns a list (of type Vector) with all possible \"block sectors\" or total/coupled sectors that can result from fusing the individual uncoupled sectors in W. Correspondingly, blockdim(W, a) counts the total dimension of coupled sector a in W. The machinery for computing this is the topic of the next section on Fusion trees, but first, it's time for some examples.","category":"page"},{"location":"man/sectors/#Examples-1","page":"Sectors, representation spaces and fusion trees","title":"Examples","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let's start with an example involving mathsfU_1:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = RepresentationSpace{U‚ÇÅ}(0=>3, 1=>2, -1=>1)\nV1 == U1Space(0=>3, 1=>2, -1=>1) == U‚ÇÅSpace(0=>3, 1=>2, -1=>1)\n(sectors(V1)...,)\ndim(V1, U‚ÇÅ(1))\ndim(V1)\nhassector(V1, U‚ÇÅ(1))\nhassector(V1, U‚ÇÅ(2))\ndual(V1)\nflip(V1)\nV2 = U1Space(0=>2, 1=>1, -1=>1, 2=>1, -2=>1)\nmin(V1,V2)\nmax(V1,V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\ncollect(sectors(W))\ndims(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\ndim(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\nhassector(W, (U‚ÇÅ(0), U‚ÇÅ(0)))\nhassector(W, (U‚ÇÅ(2), U‚ÇÅ(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, U‚ÇÅ(0))","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and then with mathsfSU_2:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = RepresentationSpace{SU‚ÇÇ}(0=>3, 1//2=>2, 1=>1)\nV1 == SU2Space(0=>3, 1/2=>2, 1=>1) == SU‚ÇÇSpace(0=>3, 0.5=>2, 1=>1)\n(sectors(V1)...,)\ndim(V1, SU‚ÇÇ(1))\ndim(V1)\nhassector(V1, SU‚ÇÇ(1))\nhassector(V1, SU‚ÇÇ(2))\ndual(V1)\nflip(V1)\nV2 = SU2Space(0=>2, 1//2=>1, 1=>1, 3//2=>1, 2=>1)\nmin(V1,V2)\nmax(V1,V2)\n‚äï(V1,V2)\nW = ‚äó(V1,V2)\ncollect(sectors(W))\ndims(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\ndim(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\nhassector(W, (SU‚ÇÇ(0), SU‚ÇÇ(0)))\nhassector(W, (SU‚ÇÇ(2), SU‚ÇÇ(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, SU‚ÇÇ(0))","category":"page"},{"location":"man/sectors/#ss_fusiontrees-1","page":"Sectors, representation spaces and fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Work in progress","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using symmetric tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is however essential that we know the basis transform from the individual (uncoupled) sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks. We refer to the latter as block sectors, as we already encountered in the previous section blocksectors and blockdim defined on the type ProductSpace.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To couple or fuse the different sectors together into a single block sector, we sequentially fuse together two sectors into a single coupled sector, which is then fused with the next uncoupled sector. For this, we assume the existence of a basis of unitary tensor maps X_ab^cŒº  R_c  R_a  R_b, introduced in the section on representation theory.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"such that (X_ab^cŒº)^ X_ab^cŒº = mathrmid_R_c and","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_Œº = 1^N_ab^c X_ab^cŒº (X_ab^cŒº)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X_ab^cŒº are the splitting tensors, their hermitian conjugate are the fusion tensors. For mathsfSU_2, their entries are given by the Clebsch‚ÄìGordan coefficients","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For mathsfSU_2, their entries are precisely given by the CG coefficients. The point is that we do not need to know the tensors X_ab^cŒº, the topological data of (the representation category of) the group describes the following transformation:","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation between (a  b)  c to a  (b  c):\n(X_ab^eŒº  mathrmid_c)  X_ec^dŒΩ = _fŒ∫Œª F^abc_d^eŒºŒΩ_fŒ∫Œª (X_ab^eŒº  mathrmid_c) X_ec^dŒΩ (mathrmid_a  X_bc^fŒ∫)  X_af^dŒª\nBraiding or permuting as defined by œÉ_ab R_a  R_b  R_b  R_a:\nœÉ_ab  X_ab^cŒº = _ŒΩ R_ab^c^Œº_ŒΩ X_ba^cŒΩ","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Furthermore, there is a relation between splitting vertices and fusion vertices given by the B-symbol, but we refer to the section on Fusion trees for the precise definition and further information. The required data is completely encoded in the the F-symbol, and corresponding Julia function Bsymbol(a,b,c) is implemented as","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"function Bsymbol(a::G, b::G, c::G) where {G<:Sector}\n    if FusionStyle(G) isa Abelian || FusionStyle(G) isa SimpleNonAbelian\n        Fsymbol(a, b, dual(b), a, c, one(a))\n    else\n        reshape(Fsymbol(a,b,dual(b),a,c,one(a)), (Nsymbol(a,b,c), Nsymbol(c,dual(b),a)))\n    end\nend","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"but a more efficient implementation may be provided.","category":"page"},{"location":"man/sectors/#Canonical-representation-1","page":"Sectors, representation spaces and fusion trees","title":"Canonical representation","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Possible-manipulations-1","page":"Sectors, representation spaces and fusion trees","title":"Possible manipulations","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Fermions-1","page":"Sectors, representation spaces and fusion trees","title":"Fermions","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/#Bibliography-1","page":"Sectors, representation spaces and fusion trees","title":"Bibliography","text":"","category":"section"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"[tung]:     Tung, W. K. (1985). Group theory in physics: an introduction to symmetry principles, group representations, and special functions in classical and quantum physics.\n        World Scientific Publishing Company.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"[kitaev]: Kitaev, A. (2006). Anyons in an exactly solved model and beyond. Annals of Physics, 321(1), 2-111.","category":"page"},{"location":"man/sectors/#","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"[1]: Strictly speaking the number of sectors, i.e. simple objects, in a fusion category needs to be finite, so that RepmathsfG is only a fusion category for a finite group mathsfG. It is clear our formalism also works for compact Lie groups with an infinite number of irreps, since any finite-dimensional vector space will only have a finite number of all possible irreps in its decomposition.","category":"page"},{"location":"index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"#TensorKit.jl-1","page":"Home","title":"TensorKit.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for large-scale tensor computations, with a hint of category theory.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = TensorKit","category":"page"},{"location":"#Package-summary-1","page":"Home","title":"Package summary","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"TensorKit.jl aims to be a generic package for working with tensors as they appear throughout the physical sciences. TensorKit implements a parametric type Tensor (which is actually a specific case of the type TensorMap) and defines for these types a number of vector space operations (scalar multiplication, addition, norms and inner products), index operations (permutations) and linear algebra operations (multiplication, factorizations). Finally, tensor contractions can be performed using the @tensor macro from TensorOperations.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Currently, most effort is oriented towards tensors as they appear in the context of quantum many body physics and in particular the field of tensor networks. Such tensors often have large dimensions and take on a specific structure when symmetries are present. To deal with generic symmetries, we employ notations and concepts from category theory all the way down to the definition of a tensor.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At the same time, TensorKit.jl focusses on computational efficiency and performance. The underlying storage of a tensor's data can be any DenseArray. Currently, certain operations are already multithreaded, either by distributing the different blocks in case of a structured tensor (i.e. with symmetries) or by using multithreading provided by the package Strided.jl. In the future, we also plan to investigate using GPUArrays as underlying storage for the tensors data, so as to leverage GPUs for the different operations defined on tensors.","category":"page"},{"location":"#Contents-of-the-manual-1","page":"Home","title":"Contents of the manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\", \"man/categories.md\", \"man/spaces.md\", \"man/sectors.md\", \"man/tensors.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"lib/spaces.md\"]\nDepth = 2","category":"page"},{"location":"man/categories/#s_categories-1","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The purpose of this section (which can safely be skipped), is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors. In particular, we are interested in the category mathbfVect, but our concept of tensors can be extended to morphisms of any category that shares similar properties. These properties are reviewed below.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In particular, we will as example also study the more general case of mathbfSVect, i.e. the category of super vector spaces, which contains mathbfVect as a subcategory and which are useful to describe fermions.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In the end, the goal of identifying tensor manipulations in TensorKit.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following exposition is mostly based on [turaev], combined with input from [selinger], [kassel], [kitaev], and nLab, to which  we refer for further information. Furthermore, we recommend the nice introduction of Beer et al.","category":"page"},{"location":"man/categories/#ss_categoryfunctor-1","page":"Introduction to category theory (optional)","title":"Categories, functors and natural transformations","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"To start, a category C consists of","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"a class Ob(C) of objects V, W, ‚Ä¶\nfor each pair of objects V and W, a set Hom_C(WV) of morphisms fWV;   for a given map f, W is called the domain or source, and V the   codomain or target.\ncomposition of morphisms fWV and gXW into (f  g)XV that is   associative, such that for hYX we have f  (g  h) = (f  g)  h\nfor each object V, an identity morphism mathrmid_VVV such that   f  mathrmid_W = f = mathrmid_V  f.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The morphisms in Hom_C(VV) are known as endomorphism and this set is also denoted as End_C(V). When the category C is clear, we can drop the subscript in Hom(WV). A morphism fWV is an isomorphism if there exists a morphism f^-1VW called its inverse, such that f^-1  f = mathrmid_W and f  f^-1 = mathrmid_V.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"We associate a graphical representation to morphisms as boxes with an incoming and outgoing line denoting the object in its source and target. The flow from source to target, and thus the direction of morphism composition f  g (a.k.a flow of time) can be chosen left to right (like the arrow in fWV), right to left (like the composition order f  g, or the matrix product), bottom to top (quantum field theory convention) or top to bottom (quantum circuit convention). Throughout this manual, we stick to this latter convention (which is not very common in manuscripts on category theory):","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: composition)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The direction of the arrows, which become important once we introduce duals, are also subject to convention, and are here chosen to to follow the arrow in fWV, i.e. the source comes in and the target goes out. Strangely enough, this is opposite to the most common convention.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In the case of interest, i.e. the category mathbf(Fin)Vect_ùïú (or some subcategory thereof), the objects are (finite-dimensional) vector spaces over a field ùïú, and the morphisms are linear maps between these vector spaces with \"matrix multiplication\" as composition. More importantly, the morphism spaces Hom(WV) are themselves vector spaces. More general categories where the morphism spaces are vector spaces over a field ùïú (or modules over a ring ùïú) and the composition of morphisms is a bilinear operation are called ùïú-linear categories (or ùïú-algebroids, or mathbfVect_ùïú-enriched categories). In that case, the endomorphisms End(V) are a ùïú-algebra with mathrmid_V as the identity.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"We also introduce with some definitions which will be useful further on. A functor F between two categories C and D is, colloquially speaking, a mapping between categories that preserves morphism composition and identities. More specifically, FCD assigns to every object V  Ob(C) an object F(V)  Ob(D), and to each morphism f  Hom_C(WV) a morphism F(f)  Hom_D(F(W) F(V)) such that F(f) _D F(g) = F(f _C g) and F(mathrmid_V) = mathrmid_F(V) (where we denoted the possibly different composition laws in C and D explicitly with a subscript). In particular, every category C has an identity functor 1_C that acts trivially on objects and morphisms. Functors can also be composed. A ùïú-linear functor between two ùïú-linear categories has a linear action on morphisms.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Given two categories C and D, and two functors F and G that map from C to D, a natural transformation œÜFG is a family of morphisms œÜ_V  Hom_D(F(V)G(V)) in D, labeled by the objects V of C, such that œÜ_V  F(f) = G(f)  œÜ_W for all morphisms f  Hom_C(WV). If all morphisms œÜ_V are isomorphisms, œÜ is called a natural isomorphism and the two functors F and G are said to be isomorphic.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The product of two categories C and C, denoted C  C, is the category with objects Ob(CC) = Ob(C)  Ob(C), whose elements are denoted as tuples (VV), and morphisms Hom_CC((WW) (VV)) = Hom_C(WV)  Hom_C(WV). Composition acts as (ff)  (gg) = (ff gg) and the identity is given by mathrmid_VV = (mathrmid_V mathrmid_V). In a similar fashion, we can define the product of functors FCD and FCD as a functor FF (CC)(DD) mapping objects (VV) to (F(V) F(V)) and morphisms (ff) to (F(f) F(f)).","category":"page"},{"location":"man/categories/#ss_monoidalcategory-1","page":"Introduction to category theory (optional)","title":"Monoidal categories","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The next property of the category mathbfVect that we want to highlight and generalize is that which allows to take tensor products. Indeed, a category C is said to be a tensor category (a.k.a. a monoidal category), if it has","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"a binary operation on objects  Ob(C)  Ob(C)  Ob(C)\na binary operation on morphisms, also denoted as , such that    Hom_C(W_1V_1)  Hom_C(W_2V_2)  Hom_C(W_1  W_2 V_1  V_2)\nan identity or unit object I\nthree families of natural isomorphisms:\n V  Ob(C), a left unitor (a.k.a. left unitality constraint) Œª_V I  V  V\n V  Ob(C), a right unitor (a.k.a. right unitality constraint) œÅ_V V  I  V\n V_1 V_2 V_3  Ob(C), an associator (a.k.a. associativity constraint)   Œ±_V_1V_2V_3(V_1  V_2)  V_3  V_1  (V_2  V_3)\nthat satisfy certain consistency conditions (coherence axioms), which are known as the   pentagon equation (stating that the two possible mappings from   (((V_1  V_2)  V_3)  V_4) to (V_1  (V_2  (V_3  V_4))) are compatible) and   the triangle equation (expressing compatibility between the two possible ways to map   ((V_1  I)  V_2) to (V_1  (I  V_2))).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In terms of functors and natural transformations,  is a functor from the product category C  C to C. Furthermore, the left (or right) unitor Œª (or œÅ)) is a natural isomorphism between a nameless functor CC that maps objects V  I  V (or VV  I) and the identity functor 1_C. Similarly, the associator Œ± is a natural isomorphism between the two functors (  1_C) and (1_C  ) from C  C  C to C.  In a k-linear category, the tensor product of morphisms is also a bilinear operation. A monoidal category is said to be strict if I  V = V = V  I and (V_1V_2)V_3 = V_1(V_2V_3), and the left and right unitor and associator are just the identity morphisms for these objects.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For the category mathbfVect, the identity object I is just the scalar field ùïú over which the vector spaces are defined, and which can be identified with a one- dimensional vector space. This is not automatically a strict category, especially if one considers how to represent tensor maps on a computer. The distinction between V, I  V and V  I amounts to adding or removing an extra factor I to the tensor product structure of the domain or codomain, and so the left and right unitor are analogous to removing extra dimensions of size 1 from a multidimensional array. The fact that arrays with and without additional dimensions 1 are not automatically identical and an actual operation is required to insert or remove them, has led to some controversy in several programming languages that provide native support for multidimensional arrays.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For what concerns the associator, the distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3) is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We elaborate on this in the section on fusion trees. However, we can already note that we will always represent tensor products using a canonical order (((V_1  V_2)  V_3)   V_N). A similar approach can be followed to turn any tensor category into a strict tensor category (see Section XI.5 of [kassel]).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The different natural isomorphisms involving the unit object have various relations, such as Œª_VW  Œ±_IVW = l_V  mathrmid_W and Œª_I = œÅ_I  I  I  I. The last relation defines an isomorphism between I  I and I, which can also be used to state that for f g  End_C(I), f  g = œÅ_I  (f  g)  Œª_I^-1 = g  f. Hence, the tensor product of morphisms in End_C(I) can be related to morphism composition in End_C(I), and furthermore, the monoid of endomorphisms End_C(I) is commutative (abelian). In the case of a ùïú-linear category, it is an abelian ùïú-algebra. In the case of mathbfVect, End(I) is indeed isomorphic to the field of scalars ùïú. We return to the general case where End_C(I) is isomorphic to ùïú itself in the last section on Fusion categories.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Furthermore, Mac Lane's coherence theorem states that the triangle and pentagon condiation are sufficient to ensure that any consistent diagram made of associators and left and right unitors (involving all possible objects in C) commutes. For what concerns the graphical notation, the natural isomorphisms will not be represented and we make no distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3). Similarly, the identity object I is can be added or removed at will, and when drawn, is often represented by a dotted or dashed line. Note that any consistent way of inserting the assocatior or left or right unitor to convert a graphical representation to a diagram of compositions and tensor products of morphisms gives rise to the same result, by virtue of Mac Lane's coherence theorem. Using the horizontal direction to stack tensor products, this gives rise to the following graphical notation for the tensor product of two morphisms, and for a general morphism t between a tensor product of objects in source and target","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: tensorproduct)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Another relevant example is the category mathbfSVect_ùïú, which has as objects super vector spaces over ùïú, which are vector spaces with a ‚Ñ§‚ÇÇ grading, i.e. they are decomposed as a direct sum V = V_0  V_1. Furthermore, the morphisms between two super vector spaces are restricted to be grading preserving, i.e. f Hom_mathbfSVect(WV) has f(W_0)  V_0 and f(W_1)  V_1. The graded tensor product between two super vector spaces is defined as (V_mathrmgW) = (V _mathrmg W)_0  (V _mathrmg W)_1 with (V _mathrmg W)_0 = (V_0  W_0)  (V_1  W_1) and (V _mathrmg W)_1 = (V_0  W_1)  (V_1  W_0). The unit object is again isomorphic to ùïú, i.e. I_0 = ùïú and I_1 = 0, a zero-dimensional vector space. In particular, the category mathbfSVect_ùïú contains mathbfVect_ùïú as a (monoidal) subcategory, by only selecting those objects V for which V_1 = 0. We will return to the example of mathbfSVect throughout the remainder of this page.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Finally, we generalize the notion of a functor between monoidal categories. A monoidal functor between two tensor categories (C _C I_C Œ±_C Œª_C œÅ_C) and (D _D I_D Œ±_D Œª_D œÅ_D) is a functor FCD together with two monoidal constraints, namely","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"a morphism F‚ÇÄI_D  F(I_C);\na natural transformation F_2=F_2(XY) F(X) _D F(Y)  F(X _C Y)  XY Ob(C)   between the functors _D(FF) and F _C from CC to D.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A monoidal natural transformation œÜ between two monoidal functors FCD and GCDis a natural transformation œÜFG that furthermore satisfies","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"œÜ_I_C F_0 = G_0;\n XY  Ob(C): œÜ_X  Y F_2(XY) = G_2(XY)(œÜ_X  œÜ_Y).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For further reference, we also define the following categories which can be associated with a related to the category mathcalC = (C  I Œ± Œª œÅ)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"mathcalC^mathrmop = (C^mathrmop  I Œ±^mathrmop Œª^mathrmop œÅ^mathrmop)   where the opposite category C^mathrmop has the same objects as C but has   Hom_C^mathrmop(XY) = Hom_C(YX) and a composition law   g ^mathrmop f = f  g, with  the composition law of C. Furthermore,   we have Œ±^mathrmop_XYZ = (Œ±_XYZ)^-1,   Œª^mathrmop_X = (Œª_X)^-1 and œÅ^mathrmop_X = (œÅ_X)^-1;\nmathcalC^mathrmop = (C ^mathrmop I Œ±^mathrmop Œª^mathrmop œÅ^mathrmop)   where the functor ^mathrmopCC  C is the opposite monoidal product, which   acts as X ^mathrmrev Y = Y  X on objects and similar on morphisms.   Furthermore, Œ±^mathrmop_XYZ = (Œ±_ZYX)^-1,   Œª^mathrmop_X = œÅ_X and œÅ^mathrmop_X = Œª_X;\nThe two previous transformations (which commute) composed:   mathcalC^mathrmrev = (C^mathrmop ^mathrmop I Œ±^mathrmrev Œª^mathrmrev œÅ^mathrmrev)   with Œ±^mathrmrev_XYZ = Œ±_ZYX, Œª^mathrmrev_X = (œÅ_X)^-1,   œÅ^mathrmrev_X = (Œª_X)^-1.","category":"page"},{"location":"man/categories/#ss_dual-1","page":"Introduction to category theory (optional)","title":"Duality: rigid, pivotal and spherical categories","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Another property of the category mathbfVect that we want to generalize is the notion of duals. For a vector space V, i.e. an object of  mathbfVect, the dual V^* is itself a vector space. Evaluating the action of dual vector on a vector can, because of linearity, be interpreted as a morphism from V^*  V to I. Note that elements of a vector space V have no categorical counterpart in themselves, but can be interpreted as morphism from I to V. To map morphisms from Hom(WV) to elements of V  W^*, i.e. morphisms in Hom(I V  W^*), we use another morphism Hom(I W  W^*) which can be considered as the inverse of the evaluation map.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Hence, duality in a monoidal category is defined via an exact paring, i.e. two families of non-degenerate morphisms, the evaluation (or co-unit) œµ_V ^V  V  I and the coevaluation (or unit) Œ∑_V I  V  ^V which satisfy the \"snake rules\":","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"œÅ_V  (mathrmid_V  œµ_V)  (Œ∑_V  mathrmid_V)  Œª_V^-1 = mathrmid_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œª_^V^-1  (œµ_V  mathrmid_^V)  (mathrmid_^V  Œ∑_V)  œÅ_^V^-1 = mathrmid_^V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and can be used to define an isomorphism between Hom(W  V U) and Hom(W U  ^V). Note that if there are e.g. different duals (with corrsponding exact pairings) associated to an object V, a mixed snake composition using the evaluation of one and coevaluation of the other duality can be used to construct an isomorphism between the two associated dual objects.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For complex vector spaces, using a bra-ket notation and a generic basis n for V and dual basis m for V^* (such that mn = Œ¥_mn), the evaluation is given by œµ_V^V  V  ‚ÑÇ m  n  Œ¥_mn and the coevaluation or unit is Œ∑_V‚ÑÇ V  ^VŒ±  Œ± _n n  n. Note that this does not require an inner product, i.e. no relation or mapping from n to n was defined. For a general tensor map tW_1  W_2    W_N_2  V_1  V_2    V_N_1, by successively applying Œ∑_W_N_2, Œ∑_W_N_2-1, ‚Ä¶, Œ∑_W_1 (in combination with the left or right unitor), we obtain a tensor in V_1  V_2    V_N_1  W_N_2^*    W_1^*. It does makes sense to define or identify (W_1  W_2    W_N_2)^* = W_N_2^*    W_1^*. Indeed, it can be shown that an exact pairing between V  W and ^W  ^V can be constructed out of the evaluation and coevaluation of V and W, such that ^W  ^V is isomorphic to ^(V  W).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Graphically, we represent the exact pairing and snake rules as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: left dual)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note that we denote the dual objects ^V as a line V with arrows pointing in the opposite (i.e. upward) direction. This notation is related to quantum field theory, where anti-particles are (to some extent) interpreted as particles running backwards in time.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"These exact pairings are known as the left evaluation and coevaluation, and ^V is the left dual of V. Likewise, then, V is a right dual of ^V, and we can also define a right dual V^ of V and associated pairings, the right evaluation tildeœµ_V V  V^  I and coevaluation tildeŒ∑_V I  V^  V, satisfying","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: right dual)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For a general morphism f  Hom(WV), we furthermore define the left and right transpose ^f  Hom(^V ^W) and f^  Hom(V^ W^) as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: transpose)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where on the right we also illustrate the mapping from t  Hom(W_1  W_2  W_3 V_1  V_2) to a morphism in Hom(I V_1  V_2  ^ W_1  ^ W_2  ^ W_3). Note that, by virtue of the snake rules, ^(mathrmid_V) = mathrmid_^V and (mathrmid_V)^ = mathrmid_V^.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note that the graphical notation, at least the lines with opposite arrows, do not allow to distinguish between the right dual V^ and the left dual ^V. We come back to this point below.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A left (or right) duality in a (monoidal) category is now defined as an association of a left (or right) dual with every object of the category, with corresponding exact pairings, and a category admitting such a duality is a left (or right) rigid category (or left or right autonomous category). Given that left (or right) morphism transposition satisfies ^(f  g)= ^g  ^f= ^f ^mathrmop ^g and recalling ^(V  W) = ^W  ^V (and similar for right duality), we can define duality in a functorial way. A (left or right) rigid category mathcalC is a category which admits a (left or right) duality functor, i.e. a functor from mathcalC to mathcalC^mathrmrev that maps objects to its (left or right) dual, and morphisms to its (left or right) transpose. In particular, the snake rules can now be read as the functioral requirement that ^(mathrmid_V) = mathrmid_^V.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In all of this, left and right duality can be completely distinct. Equivalently, the left dual of the left dual of an object V, i.e. ^V is not necessarily V itself. For finite-dimensional vector spaces, however, ^V and V, or thus ^V and V^ are isomorphic. The categorical generalization is that of a pivotal category (or sovereign category), i.e. a monoidal category with duals X^* = ^X = X^ = X^* such that the left and right duality functor coincide, and thus also the left and right transpose of morphisms, i.e. f^* = ^f = f^  Hom(V^*W*) for any fHom(WV). Given that tildeœµ_X and tildeŒ∑_X can be interpreted as an exact pairing œµ_X^* and Œ∑_X^*, this can be used to recognize X as a left dual of X^*, which is then not necessarily equal but at least isomorphic to X^** with the isomorphism given by the mixed snake composition alluded to in the beginning of this section, i.e. Œ¥_X X  X^** given by Œ¥_X = (tildeœµ_X  mathrmid_X^*)  (id_X  Œ∑_X^*). A more formal statement is that Œ¥ is a natural isomorphism between the double dual functor and the identity functor of a category C. In a similar manner, such a Œ¥ can be used to define a natural isomorphism between left and right dual functor (which is a slight generalization of the above definition of a pivotal category), and as such it is often called the pivotal structure.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Hence, in a pivotal category, left and right duals are the same or isomorphic, and so are objects and their double duals. As such, we will not distinguish between them in the graphical representation and suppress the natural isomorphism Œ¥. Note, as already suggested by the graphical notation above, that we can interpret transposing a morphism as rotating its graphical notation by 180 degrees (either way).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Furthermore, in a pivotal category, we can define a map from End(V), the endomorphisms of an object V to endomorphisms of the identity object I, i.e. the field of scalars in the case of the category mathbfVect, known as the trace of f. In fact, we can define both a left trace as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"mathrmtr_mathrml(f) = œµ_V  (f  mathrmid_V^*)  tildeŒ∑_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and a right trace as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"mathrmtr_mathrmr(f) = tildeœµ_V  (mathrmid_V^*  f)  Œ∑_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"They are graphically represented as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: trace)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and they do not need to coincide. Note that mathrmtr_mathrml(f) = mathrmtr_mathrmr(f*) and that mathrmtr_mathrmlmathrmr(fg) = mathrmtr_mathrmlmathrmr(gf). The (left or right) trace of the identity morphism mathrmid_V defines the corresponding (left or right) dimension of the object V, i.e. mathrmdim_mathrmlmathrmr(V) = tr_mathrmlmathrmr(mathrmid_V). In a spherical category, both definitions of the trace coincide for all V and we simply refer to the trace mathrmtr(f) of an endomorphism. The particular value mathrmdim(V) = tr(mathrmid_V) is known as the (quantum) dimension of the object V, referred to as dim(V) in TensorKit.jl.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For further information and a more detailed treatment of rigid and pivotal categories, we refer to [turaev] and [selinger]. We conclude this section by studying the example of mathbfSVect. Let us, in every super vector space V, define a basis n that is compatible with the grading, such n=01 indicates that n  V_n. We again define a dual basis m for V^* (such that mn = Œ¥_mn), and then define the left evaluation by œµ_VV^*  V  ‚ÑÇ m _mathrmg n  mn = Œ¥_mn and the left coevaluation by Œ∑_V‚ÑÇ V  V^*Œ±  Œ± _n n _mathrmg n. Note that this does not require an inner product and satisfies the snake rules. For the right evaluation and coevaluation, there are two natural choices, namely tildeœµ_VV  V^*  ‚ÑÇ n _mathrmg m  (1)^n Œ¥_mn and tildeŒ∑_V‚ÑÇ  V^*  V Œ±  _n (1)^n n _mathrmg n. The resulting trace of an endomorphism f  End(V) is given by mathrmtr^mathrml(f) = mathrmtr^mathrmr(f) = mathrmtr(f) = _n (-1)^n nfn and is known as either the regular trace (in the case of +1) or the supertrace (in the case of -1). In particular, mathrmdim(V) = mathrmdim(V_0)  mathrmdim(V_1), and can be negative in the case of the supertrace. Both are valid choices to make mathbfSVect into a spherical category.","category":"page"},{"location":"man/categories/#ss_braiding-1","page":"Introduction to category theory (optional)","title":"Braidings, twists and ribbons","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"While duality and the pivotal structure allow to move vector spaces back and forth between the domain (source) and codomain (target) of a tensor map, reordering vector spaces within the domain or codomain of a tensor map , i.e. within a tensor product V_1  V_2   V_N requires additional structure. In particular, we need at the very least a braided tensor category C, which is endowed with a braiding œÑ, i.e. a natural isomorphism œÑ_VWVW  WV_VW  Ob(C) between the functors  and ^mathrmop such that œÑ_VV(f  g) = (fg)œÑ_WW for any morphisms f  Hom(WV) and g  Hom(WV). A valid braiding needs to satisfy a coherence condition with the associator Œ± known as the hexagon equation, which expresses that the braiding is -multiplicative, i.e. œÑ_UVW = (mathrmid_V  œÑ_UW)(œÑ_UVmathrmid_W) and œÑ_UVW = (œÑ_UWmathrmid_VW)(mathrmid_U  œÑ_VW) (where the associator has been omitted). We also have Œª_V  œÑ_VI = œÅ_VI, œÅ_V  œÑ_IV = Œª_V and œÑ_VI = œÑ_IV^-1 for any V  Ob(C).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The braiding isomorphism œÑ_VW and its inverse are graphically represented as the lines V and W crossing over and under each other:","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: braiding)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"such that we have","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: braiding relations)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where the expression on the right hand side, œÑ_WVœÑ_VW can generically not be simplified. Hence, for general braidings, there is no unique choice to identify a tensor in VW and WV, as the isomorphisms œÑ_VW, œÑ_WV^-1, œÑ_VW  œÑ_WV  œÑ_VW, ‚Ä¶ mapping from VW to WV can all be different. In order for there to be a unique map from V_1  V_2   V_N to any permutation of the objects in this tensor product, the braiding needs to be symmetric, i.e. œÑ_VW = œÑ_WV^-1 or, equivalently œÑ_WV  œÑ_VW = mathrmid_VW. The resulting category is then referred to as a symmetric tensor category. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross, where the crossing represents the action of œÑ_VW = œÑ_WV^-1.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In the case of the category mathbfVect a valid braiding consists of just flipping the the objects/morphisms involved, e.g. for a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia's function permutedims on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries (where the fusion tree needs to be reordered, as discussed in Sectors, representation spaces and fusion trees) or in the case of mathbfSVect, which will again be studied in detail at the end of this section.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The braiding of a space and a dual space also follows naturally, it is given by œÑ_V^*W = Œª_W  V^*  (œµ_V  mathrmid_W  V^*)  (mathrmid_V^*  œÑ_VW^-1  mathrmid_V^*)  (mathrmid_V^* W  Œ∑_V)  œÅ_V^*  W^-1, i.e.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: braiding dual)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Balanced categories C are braided categories that come with a twist Œ∏, a natural transformation from the identity functor 1_C to itself, such that Œ∏_V  f = f  Œ∏_W for all morphisms f  Hom(WV), and for which main requirement is that","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ∏_VW = œÑ_WV  (Œ∏_W  Œ∏_V)  œÑ_VW = (Œ∏_V  Œ∏_W)  œÑ_WV  œÑ_VW","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In particular, a braided pivotal category is balanced, as we can even define two such twists, namely a left and right twist given by","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ∏^mathrml_V = (œµ_V  mathrmid_V)(mathrmid_V*  œÑ_VV) (tildeŒ∑_V  id_V)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ∏^mathrmr_V = (mathrmid_V  tildeœµ_V)(œÑ_VV  mathrmid_V*)(id_V  œµ_V)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where we omitted the necessary left and right unitors and associators. Graphically, the twists and their inverse (for which we refer to [turaev]) are then represented as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: twists)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The graphical representation also makes it straightforward to verify that (Œ∏^mathrml_V)^* = Œ∏^mathrmr_V^*, (Œ∏^mathrmr_V)^* = Œ∏^mathrml_V^* and mathrmtr_mathrml( Œ∏^mathrmr_V ) = mathrmtr_mathrmr( Œ∏^mathrml_V ).","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"When Œ∏^mathrml = Œ∏^mathrmr, or thus, equivalently, Œ∏_V^* = Œ∏_V^* for either Œ∏^mathrml or Œ∏^mathrmr, the category is said to be tortile or also a ribbon category, because its graphical representation is compatible with the isotopy of a ribbon, i.e. where the lines representing objects are depicted as ribbons. For convenience, we continue to denote them as lines. Ribbon categories are necessarily spherical, i.e. one can prove the equivalence of the left and right trace.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Alternatively, one can start from a balanced and rigid category (e.g. with a left duality), and use the twist Œ∏, which should satisfy Œ∏_V^* = Œ∏_V^*, to define a pivotal structure, or, to define the exact pairing for the right dual functor as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"tildeŒ∑_V = œÑ_VV^*  (Œ∏_V  mathrmid_V^*)  Œ∑_V = (mathrmid_V^*  Œ∏_V)  œÑ_VV^*  Œ∑_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"tildeœµ_V = œµ_V  (mathrmid_V^*  Œ∏_V)  œÑ_VV^* = œµ_V  œÑ_VV^*  (Œ∏_V  mathrmid_V^*)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"or graphically","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: pivotal from twist)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where we have drawn Œ∏ as Œ∏^mathrml on the left and as Œ∏^mathrmr on the right, but in this case they are one and the same as starting point. This construction of the pivotal structure can than be used to define the trace, which is spherical, i.e.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"tr(f) = œµ_V  œÑ_VV^*  (( Œ∏_V  f)  mathrmid_V^*)  Œ∑_V = œµ_V  (mathrmid_V^*  (f  Œ∏_V))  œÑ_VV^*  Œ∑_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note finally, that a ribbon category where the braiding is symmetric, is known as a compact closed category. For a symmetric braiding, the trivial twist Œ∏_V = mathrmid_V is always a valid choice, but it might not be the choice that one necessarily want to use. Let us study the case of mathbfSVect again. Again invoking our basis m  V and n  W, the braiding œÑ_VW is given by the Koszul sign rule, i.e. œÑ_VWm _mathrmg n  (-1)^m n n _mathrmg m. Hence, braiding amounts to flipping the two spaces, but picks up an additional minus sign if both m  V_1 and n  W_1. This braiding is symmetric, i.e. œÑ_WV  œÑ_VW = mathrmid_VW. Between spaces and dual spaces, we similarly obtain the braiding rule m _mathrmg n  (-1)^m n n _mathrmg m. Combining the braiding and the pivotal structure gives rise to a ribbon category, and thus, a compact closed category, where the resulting twist is given by Œ∏_V  n  (1)^n n for tildeœµ_VV  V^*  ‚ÑÇ n _mathrmg m  (1)^n Œ¥_mn and corresponding tildeŒ∑_V. Hence, if the right (co)evaluation contains a minus sign, the twist is Œ∏_V = mathrmid_V, which, as mentioned above, is always a valid twist for a symmetric category. However, if the right (co)evaluation contains no minus sign, the twist acts as the parity endomorphism, i.e. as +1 on V_0 and as -1 on V_1, which, as we will see in the next section, corresponds to a choice bearing additional structure.","category":"page"},{"location":"man/categories/#ss_adjoints-1","page":"Introduction to category theory (optional)","title":"Adjoints and dagger categories","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A dagger category C is a category together with an involutive functor CC^mathrmop, i.e. it acts as the identity on objects, whereas on morphisms fWV it defines a morphism f^VW such that","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"mathrmid_V^ = mathrmid_V\n(g  f)^ = g^ ^mathrmop f^ = f^  g^\n(f^)^ = f","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"If the category is ‚ÑÇ-linear, the dagger functor is often assumed to be antilinear, i.e. (Œª f)^ = barŒª f^ for Œª  ‚ÑÇ and f  Hom(VW). In a dagger category, a morphism fWV is said to be unitary if it is an isomorphism and f^-1 = f^. Furthermore, an endomorphism fVV is hermitian or self-adjoint if f^ = f.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In the graphical representation, the dagger of a morphism can be represented by mirroring the morphism around a horizontal axis, and then reversing all arrows (bringing them back to their original orientation before the mirror operation):","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: dagger)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where for completeness we have also depicted the graphical representation of the transpose, which is a very different operation. In particular, the dagger does not reverse the order of the tensor product. Note that, for readibility, we have not mirrored or rotated the label in the box, but this implies that we need to use a type of box for which the action of mirroring or rotating can be observed.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"There is more to be said about the interplay between the dagger and duals. Given a left evaluation œµ_V V^*  V  I and coevaluation Œ∑_V I  V  V^*, we can define a right evaluation tildeœµ_V = (Œ∑_V)^ and coevaluation tildeœµ_V = (œµ_V)^. Hence, left rigid dagger categories are automatically pivotal dagger categories.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The (right) twist defined via the pivotal structure now becomes","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ∏_V = (mathrmid_V  (Œ∑_V)^)  (œÑ_VV  mathrmid_V^*)  (mathrmid_V  Œ∑_V)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity. We will return to this in the discussion of fermions.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Finally, the adjoint allows to define two Hermitian forms on the morphisms, namely  f g _mathrmlmathrmr = mathrmtr_mathrmlmathrmr(f^ g), which coincide for a spherical category.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"This concludes the most important categorical definitions and structures that we want to discuss for the category mathbfVect, but which can also be realized in other categories. In particular, the interface of TensorKit.jl could in principle represent morphisms from a ùïú-linear monoidal category, but assumes categories with duals to be pivotal and in fact spherical, and categories with a braiding to be ribbon categories. A dagger ribbon category where the braiding is symmetric, i.e. a dagger category which is also a compact closed category and where the right (co)evaluation is given via the dagger of the left (co)evaluation is called a dagger compact category. This is the playground of quantum mechanics of bosonic and fermionic systems. However, we also allow for non- symmetric braiding in TensorKit.jl, though this functionality is currently much more limited.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Again studying the category mathbfSVect_‚ÑÇ (now explicitly over the complex numbers) and using the conventional adjoint or the complex Euclidean inner product to define the dagger functor, the right (co)evaluation that is obtained from applying the dagger to the left (co)evaluation is the defintion we gave above with the +1 sign. This choice gives rise to a regular trace (versus the supertrace) of endomorphisms, to positive dimensions, and a non-trivial twist that acts as the parity endomorphism. The resulting category is then a dagger compact category, that can be used for the quantum mechanical description of fermionic systems. The bosonic version is obtained by restricting to the subcategory mathbfVect.","category":"page"},{"location":"man/categories/#ss_fusion-1","page":"Introduction to category theory (optional)","title":"Direct sums, simple objects and fusion categories","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"These last two section on fusion categories is also applicable, in a straightforward manner, to mathbfVect and mathbfSVect, but is rather meant to provide the background of working with symmetries. We first need two new concepts:","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"An object W  Ob(C) is a direct sum of objects V_1 V_2  V_k  Ob(C) if   there exists a family morphisms x_Œ±  Hom(V_Œ±W) and y^Œ±  Hom(WV_Œ±) such that   mathrmid_W = _Œ±=1^k x_Œ±  y^Œ± and y^Œ±  x_Œ≤ = Œ¥^Œ±_Œ≤ mathrmid_V_Œ±.   The morphisms x_Œ± and y^Œ± are known as inclusions and projections   respectively, and in the context of dagger categories it is natural to assume   y^Œ± = x_Œ±^ in order to obtain an orthogonal direct sum decomposition.\nA simple object of V  Ob(C) a ùïú-linear category C is an object for   which End_C(V)  ùïú, i.e. the algebra of endomorphisms on V is isomorphic to   the field (or ring) ùïú. The isomorphism is typically of the form   k  ùïú  k mathrmid_V  End_C(V), i.e. mathrmid_V is the only linearly   independent endomorphism of V and all other endomorphisms are proportional to it.   In particular, for mathbfSVect and its subcategory mathbfVect, the unit   object I is a simple object.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In particular, for a pivotal ùïú-linear category where I is simple, it holds that the left and right dimensions of any simple object V are invertible in ùïú, and that any endomorphism f  End(V) can be written as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"f = (mathrmdim_mathrml(V))^-1 mathrmtr_mathrml(V) mathrmid_V = (mathrmdim_mathrmr(V))^-1 mathrmtr_mathrmr(V) mathrmid_V","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Strictly speaking, this holds only if the category is non-degenerate, which means that I is simple and that any non-degenerate pairing eV  W  I induces a non- degenerate pairing Hom(IV)  Hom(IW)  End(I). This property is always satisfied for a pre-fusion category C, i.e. a monoidal ùïú-linear category having a set mathcalS  Ob(C) of simple objects mathcalS=I V_1 V_2 ldots such that","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"the monoidal unit I_C  mathcalS;\nHom_C(V_iV_j) = 0 (the singleton set containing only the zero homomorphism) for any   distinct V_i V_j  mathcalS;\nevery object V  Ob(C) can be written as a direct sum of a finite family of   elements from mathcalS.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note that in the direct sum decomposition of an object V, a particular simple object V_i might appear multiple times. This number is known as the multiplicity index N^V_i, and equal to the rank of Hom(VV_i) or, equivalently, of Hom(V_iV). Hence, we can choose inclusion and projection maps x_iŒºV_iV and y^iŒºVV_i for Œº = 1ldots N^V_i, such that mathrmid_V = sum_isum_Œº=1^N_V^i x_iŒº  y^iŒº and y^iŒº  x_jŒΩ = Œ¥^i_j Œ¥^Œº_ŒΩ. In particular, for a simple object V, it either appears in mathcalS or is isomorphic to an object S. We thus have N^V_i = 1 for one particular object V_i and N^V_j= 0 for all other j, with x_i and y^i = (x_i)^-1 representing the isomorphism between V and V_i.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For the resulting homomorphisms between two general object W and V, this implies that","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Hom(WV)  _V_i  mathcalS Hom(WV_i)  Hom(V_iV)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and thus that the rank of Hom(WV) is given by _i N^W_i N^V_i.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A fusion category is a pre-fusion category that has (left or right) duals, i.e. that is rigid, and that only has a finite number of isomorphism classes of simple objects. Note that the duality functor maps End(V) to End(V^*), such that, if V is a simple object, so must be V^*. Henceforth, we will be sloppy about the distinction between a pre-fusion or fusion category, only use the latter term, even when it is not fully justified.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Before continuing, let us use some examples to sketch the relevance of the concept of fusion categories. As mentioned, the categories mathbfVect_ùïú and mathbfSVect_ùïú have I  ùïú as simple object. For mathbfVect, this is the only simple object, i.e. any other vector space V over ùïú, can be thought of as a direct sum over dim(V) multiple copies of ùïú. In mathbfSVect, the object J = 0  ùïú with J_0=0 the zero dimensional space and J_1  ùïú is another simple object. Clearly, there are no non-zero grading preserving morphisms between I and J, i.e. Hom(IJ) = 0, whereas Hom(JJ)  ùïú. Any other super vector space V=V_0  V_1 can be written as a direct sum over mathrmdim(V_0) copies of I and mathrmdim(V_1) copies of J.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A more representative example is that of the category C = mathbfRep(G), the category of representations of a group G. Colloquially, this could be thought of as a subcategory of Vect containing as objects vector spaces V on which a representation of G is defined, denoted as u_V(g) for g  G, and as morphisms the equivariant transformations, i.e. intertwiners between the representations on the source and target:","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Hom_C(WV) = f  Hom_mathbfVect(WV) u_V(g)  f = f  u_W(g)  g  G","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note that the u_V(g) is itself generally not an element from End_C(V). Simple objects V_a are those corresponding irreducible representations (irreps) a of the group G, for which Schur's lemma implies End_C(V_a)  ùïú and Hom_C(V_a V_b) = 0 if a and b are not equivalent irreps. On the dual space V^*, the group acts with the contragradient representation, i.e. u_V^*(g) = ((u_V(g))^-1)^* = u_V(g^-1)^*, where one should remind that ^* denotes the transpose. For a finite group or compact Lie group, we can introduce a dagger and restrict to unitary representations, such that u_V(g)^-1 = u_V(g)^ and the contragradient representation becomes the complex conjugated representation. The resulting category can then be given the structure of a unitary ribbon (pre-)fusion category. (Note that the number of isomorphism classes of simple objects, i.e. the number of non-equivalent irreps, is finite only in the case of a finite group). This example is very relevant to working with symmetries in TensorKit.jl, and will be expanded upon in more detail below.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Fusion categories have a number of simplifying properties. A pivotal fusion category is spherical as soon as mathrmdim^mathrml(V_i) = mathrmdim^mathrmr(V_i) (i.e. the trace of the identity morphism) for all (isomorphism classes of) simple objects (note that all isomorphic simple objects have the same dimension). A braided pivotal fusion category is spherical if and only if it is a ribbon category.","category":"page"},{"location":"man/categories/#ss_topologicalfusion-1","page":"Introduction to category theory (optional)","title":"Topological data of a unitary pivotal fusion category","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"More explicitly, the different structures (monoidal structure, duals and pivotal structure, braiding and twists) in a fusion category can be characterized in terms of the simple objects, which we will henceforth denoted with just a instead of V_a.","category":"page"},{"location":"man/categories/#Monoidal-structure-1","page":"Introduction to category theory (optional)","title":"Monoidal structure","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Starting with the monoidal or tensor product, we start by characterizing how the object a  b can be decomposed as a direct sum over simple objects c, which gives rise to the multiplicity indices N_c^ab, as well as the inclusion maps, which we henceforth denote as X_cŒº^abcab for Œº=1N^c_ab. In the context of a unitary fusion category, on which we now focus, the corresponding projection maps are Y^cŒº_ab = (X_cŒº^ab)^abc such that","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(X_cŒº^ab)^  X_cŒº^ab = Œ¥_cc Œ¥_ŒºŒº mathrmid_c","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Graphically, we represent these relations as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: fusion)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and also refer to the inclusion and projection maps as splitting and fusion tensor, respectively.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For both (ab)c and a(bc), which are isomorphic via the associator Œ±_abc, we must thus obtain a direct sum decomposition with the same multiplicity indices, leading to the associativity constraint","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"N_d^abc= _e N_e^ab N_d^ec = _f N_f^bc N_d^af","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The corresponding inclusion maps can be chosen as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"X_d(eŒºŒΩ)^abc = (X_eŒº^ab  mathrmid_c)  X_dŒΩ^ec  d(ab)c","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"tildeX_d(fŒ∫Œª)^abc = (mathrmid_a  X_fŒ∫^bc)  X_dŒª^af  da(bc)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and satisfy","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(X_d(eŒºŒΩ)^abc)^  X_d(eŒºŒΩ)^abc = Œ¥_ee Œ¥_ŒºŒº Œ¥_ŒΩŒΩ Œ¥_dd mathrmid_d","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"_deŒºŒΩ X_d(eŒºŒΩ)^abc  (X_d(eŒºŒΩ)^abc)^ = mathrmid_(ab)c","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and similar for tildeX_d(fŒ∫Œª)^abc. Applying the associator leads to a relation","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ±_abc  X_d(eŒºŒΩ)^abc = _fŒ∫Œª F^abc_d_(eŒºŒΩ)^(fŒ∫Œª) tildeX_d(fŒ∫Œª)^abc","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"which defines the F-symbol, i.e. the matrix elements of the associator","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(tildeX_d(fŒ∫Œª)^abc)^  Œ±_abc  X_d(eŒºŒΩ)^abc = Œ¥_dd F^abc_d_(eŒºŒΩ)^(fŒ∫Œª) mathrmid_d","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Note that the left hand side represents a map in Hom(dd), which must be zero if d is different from d, hence the Œ¥_dd on the right hand side. In a strict category, or in the graphical notation, the associator Œ± is omitted and these relations thus represent a unitary basis transform between the basis of inclusion maps X_d(eŒºŒΩ)^abc and tildeX_d(fŒ∫Œª)^abc, which is also called an F-move, i.e. graphically:","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: Fmove)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The matrix F^abc_d is thus a unitary matrix. The pentagon coherence equation can also be rewritten in terms of these matrix elements, and thus yields the celebrated pentagon equation for the F-symbols. In a similar fashion, the unitors result in N^a1_b = N^1a_b = Œ¥^a_b (where we have now written 1 instead of I for the unit object) and the triangle equation leads to additional relations between the F- symbols involving the unit object. In particular, if we identify X^1a_a1a(1a) with Œª_a^ and X^a1_a1a(a1) with œÅ_a^, the triangle equation and its collaries imply that F^1ab_c_(11Œº)^(cŒΩ1) = Œ¥^ŒΩ_Œº, and similar relations for F^a1b_c and F^ab1_c, which are graphically represented as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: Fmove1)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"In the case of group representations, i.e. the category RepG, the splitting and fusion tensors are known as the Clebsch-Gordan coefficients, especially in the case of mathsfSU_2. An F-move amounts to a recoupling and the F-symbols can thus be identified with the 6j-symbols (strictly speaking, Racah's W-symbol for mathsfSU_2).","category":"page"},{"location":"man/categories/#Duality-and-pivotal-structure-1","page":"Introduction to category theory (optional)","title":"Duality and pivotal structure","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Next up is duality. Since we are assuming a dagger category, it can be assumed pivotal, where the left dual objects are identical to the right dual objects, and the left and right (co)evaluation are related via the dagger. We have already pointed out above that the dual object a^* of a simple object a is simple, and thus, it must be isomorphic to one of the representives bara of the different isomorphism classes of simple objects that we have chosen. Note that it can happen that bara=a. Duality implies an isomorphism between Hom(WV) and Hom(IVW^*), and thus, for a simple object a, End(a)  ùïú is isomorphic to Hom(1aa^*), such that the latter is also isomorphic to ùïú, or thus N^abara_1 = 1. Also, all possible duals of a must be isomorphic, and thus there is a single representive bara, meaning that N^ab_1 = Œ¥^bbara, i.e. for all other b  bara, Hom(1ab)  Hom(b^*a) = 0. Note that also barbara=a.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Let us now be somewhat careful with respect to the isomorphism between a^* and bara. If bara  a, we can basically choose the representative of that isomorphism class as bara = a^*. However, this choice might not be valid if bara=a, as in that case the choice is already fixed, and might be different from a. To give a concrete example, the j=12 representation of mathsfSU_2 has a dual (contragradient, but because of unitarity, complex conjugated) representation which is isomorphic to itself, but not equal. In the context of tensors in quantum physics, we would like to be able to represent this representation and its conjugate, so we need to take the distinction and the isomorphism between them into account. This means that Hom(a^*bara) is isomorphic to ùïú and contains a single linearly independent element, Z_a, which is a unitary isomorphism such that Z_a^dagger  Z_a = mathrmid_a^* and Z_a  Z_a^dagger = mathrmid_bara. Using the transpose, we obtain Z_a^*  Hom(bara^*a), and thus it is proportional to Z_bara, i.e. Z_a^* = œá_a Z_bara with œá_a a complex phase (assuming ùïú = ‚ÑÇ). Another transpose results in Z_bara^* = œá_bara Z_a with œá_bara = barœá_a, where bar of a scalar quantity denotes its complex conjugate to avoid confusion with the transpose functor. If aand bara are distinct, we can essentially choose Z_bara such that œá_a is 1. However, for a=bara, the value of œá_a cannot be changed, but must satisfy œá_a^2 = 1, or thus œá_a = 1. This value is a topological invariant known as the Frobenius-Schur indicator. Graphically, we represent this isomorphism and its relations as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: Zisomorphism)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"We can now discuss the relation between the exact pairing and the fusion and splitting tensors. Given that the (left) coevaluation Œ∑_a  Hom(1 aa^*), we can define the splitting tensor as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"X^abara_1 = frac1sqrtd_a(mathrmid_a  Z_a)  Œ∑_a = frac1sqrtd_a(Z_a^*  mathrmid_bara)  tildeŒ∑_bara  Hom(1 abara)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The prefactor takes care of normalization, i.e. with Œ∑_a^ = tildeœµ_a, we find Œ∑_a^  Œ∑_a = tildeœµ_a  Œ∑_a = mathrmtr(mathrmid_a) = d_a mathrmid_1, and thus (X^abara_1)^  X^abara_1 = mathrmid_1. With this information, we can then compute F^abaraa_a, which has a single element (it's a 1  1 matrix), and find F^abaraa_a = fracœá_ad_a, where we've used tildeŒ∑_a = œµ_a^ and the snake rules. Again, the graphical representation is more enlightning:","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: ZtoF)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"With these definitions, we can now also evaluate the action of the evaluation map on the splitting tensors, namely","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: splittingfusionrelation)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"where again bar denotes complex conjugation in the second line, and we introduced two new families matrices A^ab_c and B^ab_c that are composed out of entries of the F- symbol, namely","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"A^ab_c^nu_mu = sqrtfracd_a d_bd_c   overlineF^baraab_b_(111)^(cŒºŒΩ)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"and","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"B^ab_c^nu_mu = sqrtfracd_a d_bd_c F^abbarb_b^(111)_(cŒºŒΩ)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Composing the left hand side of first graphical equation with its dagger, and noting that the resulting element fEnd(a) must satisfy f = d_a^-1 tr(f) mathrmid_a, i.e.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: Brelation)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"allows to conclude that B^ab_c^ŒΩ_Œº overlineB^ab_c^ŒΩ_Œº = delta_ŒºŒº, i.e. B^ab_c is a unitary matrix. The same result follows for A^ab_c in analogue fashion.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Let us again study in more detail the example RepG. The quantum dimension d_a of an irrep a is just the normal vector space dimension (over ùïú) of the space on which the irrep acts. The dual of an irrep a is its contragradient representation, which in the case of unitary representations amounts to the complex conjugate representation. This representation can be isomorphic to an already defined irrep bara, for example a itself. If that happens, it does not automatically imply that the irrep a is real-valued. For example, all irreps of mathsfSU_2 are self- dual, with the isomorphism given by a œÄ rotation over the y-axis (in the standard basis). The resulting Frobenius-Schur indicator is +1 for integer spin irreps, and -1 for half-integer spin irreps. The value œá_a=+1 indicates that the representation can be made real, e.g. the integer spin representations can be written as tensor representations of mathsfSO_3 by a change of basis. The value œá_a=-1 indicates that the representation is quaternionic and cannot be made real.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The (co)evaluation expresses that the standard contraction of a vector with a dual vector yields a scalar, i.e. a representation and its dual (the contragradient) yields the trivial representation when correctly contracted. The coevaluation together with the isomorphism between the conjugate of irrep a and some irrep bara yields a way to define the Clebsch-Gordan coefficients (i.e. the splitting and fusion tensor) for fusing a  bara to the trivial irrep, i.e. to what is called a singlet in the case of mathsfSU_2.","category":"page"},{"location":"man/categories/#Braidings-and-twists-1","page":"Introduction to category theory (optional)","title":"Braidings and twists","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Finally, we can study the braiding structure of a pivotal fusion category. Not all fusion categories have a braiding structure. The existence of a braiding isomorphism œÑ_VWVWWV requires at the very least that N^ab_c = N^ba_c at the level of the simple objects. We can then express œÑ_ab in terms of its matrix elements as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"œÑ_ab  X^ab_cŒº = _ŒΩ R^ab_c^ŒΩ_Œº X^ba_cŒΩ","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"or graphically","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: braidingR)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The hexagon coherence axiom for the braiding and the associator can then be reexpressed in terms of the F-symbols and R-symbols.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"We can now compute the twist, which for simple objects needs to be scalars (or in fact complex phases because of unitarity) multiplying the identity morphism, i.e.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Œ∏_a =  mathrmid_a sum_bŒº fracd_bd_a R^aa_b^Œº_Œº","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"or","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: simpletwist)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"Henceforth, we reserve Œ∏_a for the scalar value itself. Note that Œ∏_a = Œ∏_bara as our category is spherical and thus a ribbon category, and that the defining relation of a twist implies","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"R^ba_c^Œ∫_Œº R^ab_c^Œº_ŒΩ = fractheta_cŒ∏_a Œ∏_b Œ¥^Œ∫_ŒΩ","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"If a = bara, we can furthermore relate the twist, the braiding and the Frobenius- Schur indicator via Œ∏_a œá_a R^aa_1 =1, because of","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"(Image: twistfrobeniusschur)","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"For the recurring example of RepG, the braiding acts simply as the swap of the two vector spaces on which the representations are acting and is thus symmetric, i.e. œÑ_ba  œÑ_ab = mathrmid_ab. All the twists are simply Œ∏_a = 1. For an irrep that is self-dual, i.e. bara=a, the final expression simplifies to R^aa_1 = œá_a and thus states that the fusion from a  a to the trivial sector is either symmetric under swaps if œá_a=1 or antisymmetric if œá_a=-1. For the case of mathsfSU_2, the coupling of two spin j states to a singlet it symmetric for integer j and odd for half-integer j.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"With this, we conclude our exposition of unitary fusion categories. There are many fusion categories that do not originate from the representation theory of groups, but are related to quantum groups and the representation theory of quasi-triangular Hopf algebras. They have non-integer quantum dimensions and generically admit for braidings which are not symmetric. A particular class of interesting fusion categories are modular fusion categories, which provide the mathematical structure for the theory of anyons and topological sectors in topological quantum states of matter. Thereto, one defines the modular S matrix, defined as","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"S_ab = frac1D mathrmtr(œÑ_ab  œÑ_ba) = frac1D _c N^ab_c d_c fracŒ∏_cŒ∏_a Œ∏_b","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"The normalization constant is given by D = sqrtsum_a d_a^2, and thus truly requires a fusion category with a finite number of (isomorphism classes of) simple objects. For a modular fusion category, the symmetric matrix S is non-degenerate, and in fact (for a unitary fusion category) unitary. Note, however, that for a symmetric braiding S_ab = fracd_a d_bD and thus S is a rank 1 matrix. In particular, RepG is never a modular category and the properties associated with this are not of importance for TensorKit.jl. We refer to the references for further information about modular categories.","category":"page"},{"location":"man/categories/#Bibliography-1","page":"Introduction to category theory (optional)","title":"Bibliography","text":"","category":"section"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"[turaev]:   Turaev, V. G., & Virelizier, A. (2017). Monoidal categories and topological field theory (Vol. 322).\n        Birkh√§user.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"[selinger]: Selinger, P. (2010). A survey of graphical languages for monoidal categories.\n        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"[kassel]:   Kassel, C. (2012). Quantum groups (Vol. 155).\n        Springer Science & Business Media.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"[kitaev]:   Kitaev, A. (2006). Anyons in an exactly solved model and beyond.\n        Annals of Physics, 321(1), 2-111.","category":"page"},{"location":"man/categories/#","page":"Introduction to category theory (optional)","title":"Introduction to category theory (optional)","text":"[beer]:     From categories to anyons: a travelogue\n        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf\n        [https://arxiv.org/pdf/1811.06670.pdf](https://arxiv.org/pdf/1811.06670.pdf)","category":"page"},{"location":"man/old/#TensorKit.jl-1","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A Julia tensor package with a hint of category theory. ***","category":"page"},{"location":"man/old/#Introduction-1","page":"TensorKit.jl","title":"Introduction","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"TensorKit.jl is a Julia package for working with tensors, which are consistently treated as the elements of a tensor product of vector spaces or, more generally, as linear maps between pairs of such tensor product spaces. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction.","category":"page"},{"location":"man/old/#What-is-a-tensor?-1","page":"TensorKit.jl","title":"What is a tensor?","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In abstract sense, tensors (and tensor maps; see below) correspond to the morphisms in the category Vect, i.e. the category with vector spaces as objects, or some subcategory thereof.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"some subspace thereof. While tensors can typically be represented as multidimensional arrays with respect to a chosen basis, they have a richer mathematical structure depending on the type of vector spaces used in the tensor product construction. Henceforth, we represent a tensor using index notation and refer to the different \"dimensons\" as indices. The tensor T^i_1overlineimath_4_i_2overlineimath_3 represents a an element of the tensor product space V_1 \\otimes V_2^{\\ast} \\otimes \\overline{V}_3 \\otimes \\overline{V}_4^{\\ast} where general complex vector spaces V can appear in four different ways:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"contravariant index i_1 : normal vector space V_1\ncontravariant index i_2 : dual space V_2^ast\nbarred or dotted covariant index overlineimath_3 : complex conjugate space overlineV_3\nbarred or dotted contravariant index overlineimath_4 : complex conjugate of the dual space overlineV_4^ast , which is equivalent to the dual of the complex conjugate space","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The four different vector spaces V , V^ast , overlineV and overlineV^ast correspond to the representation spaces of respectively the fundamental, dual or contragredient, complex conjugate and dual complex conjugate representation of the general linear group mathsfGL(V) [tung]. Simplifications will occur for certain types of vector spaces.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Vector-spaces-1","page":"TensorKit.jl","title":"Vector spaces","text":"","category":"section"},{"location":"man/old/#Elementary-vector-spaces-1","page":"TensorKit.jl","title":"Elementary vector spaces","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Tensors in TensorToolbox.jl are treated as elements of a tensor product of a homogeneous family of elementary vector spaces, which we also refer to as index spaces and can be user defined. We thus define a type hierarchy for representing a hierarchy of common vector spaces:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract VectorSpace\nabstract ElementarySpace{F} <: VectorSpace\nconst IndexSpace = ElementarySpace","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"where the parameter F can be used to represent a field over which the vector space is defined. In particular, we define a unicode shorthand for two common fields, which we take from the Julia Number type hierarchy:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"const ‚Ñù=Real\nconst ‚ÑÇ=Complex{Real}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Every ElementarySpace should implement the following methods","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"dim(::ElementarySpace) -> ::Int   returns the dimension of the space as an Int\ndual{S<:ElementarySpace}(::S) -> ::S   returns the dual space dual(V), preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy dual(dual(V)==V\nconj{S<:ElementarySpace}(::S) -> ::S   returns the complex conjugate space conj(V), preferably using an instance of the same concrete type (i.e. not via type parameters) to combine well with the way tensors are defined; this should satisfy conj(conj(V))==V and we automatically have conj{F<:Real}(V::ElementarySpace{F}) = V.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In particular, there is concrete type GeneralSpace which is completely characterized by its field F, its dimension and whether its the dual and/or complex conjugate of mathbbF^d .","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We furthermore define the abstract type","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract InnerProductSpace{F} <: ElementarySpace{F}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to contain all vector spaces V which have an inner product and thus a natural mapping from dual(V) to V (for F<:Real) or from dual(V) to conj(V) (for F<:Complex). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Finally there is","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract EuclideanSpace{F} <: InnerProductSpace{F}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to contain all spaces V with a standard Euclidean inner product (i.e. where the metric is the identity). These spaces have the natural isomorphisms dual(V)==V (for F<:Real) or dual(V)==conj(V) (for F<:Complex). In particular, we have two concrete types","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"immutable CartesianSpace <: EuclideanSpace{‚Ñù}\n    d::Int\nend\nimmutable ComplexSpace <: EuclideanSpace{‚ÑÇ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"to represent the Euclidean spaces ‚Ñù^d or ‚ÑÇ^d without further inner structure. They can be created using the syntax ‚Ñù^d and ‚ÑÇ^d.","category":"page"},{"location":"man/old/#WIP:-Graded-spaces,-superselection-sectors-and-braiding-1","page":"TensorKit.jl","title":"WIP: Graded spaces, superselection sectors and braiding","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"If tensors are used to describe system with a certain symmetry corresponding to a group mathsfG , this implies that the vector spaces V involved carry a corresponding representation rho_V mathsfG to V . For compact groups and an otherwise complex euclidean space V , these representations can be chosen unitary and it makes sense to decompose V according to the irreducible representations of mathsfG as","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"V=bigoplus_lambda R_lambda otimes mathbbC^d_lambda","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"V","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"thus becomes a graded vector space with the different sectors labelled by the irreducible representations lambda of mathsfG , and where every sector decomposes as the tensor product of the irrep space R_lambda and a part mathbbC^d_lambda that transforms trivially. More generally, a vector space can be graded by the representations of a Hopf algebra, corresponding to a set of labels constituting a unitary fusion category.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The implementation of graded vector spaces is currently limited to those cases where V represents a complex Euclidean space, which would be the typical case for unitary representations of groups. This amounts to the definition","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract UnitaryRepresentationSpace{G<:Sector} <: EuclideanSpace{‚ÑÇ}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Here, Sector is an abstract type. A subtype of Sector corresponds to a particular fusion category and the possible objects correspond to the different labels, i.e. the different charges or superselection sectors. Sector objects should support the functionality to map objects (labels) to the corresponding conjugate label (anticharge), to create the trivial object (identity, zero charge) and to determine the outcome of the fusion product. So far, only abelian categories are implemented, corresponding to the representations of abelian groups:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract Sector\nabstract Abelian <: Sector\nabstract NonAbelian <: Sector\nimmutable Parity <: Abelian\n    charge::Bool\nend\nimmutable ZNCharge{N} <: Abelian\n    charge::Int\n    ZNCharge(charge::Int)=new(mod(charge,N))\nend\nimmutable U1Charge <: Abelian\n    charge::Int\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"***TODO: Braiding***","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"When the different superselection sectors correspond to e.g. different fermion or anyon occupation numbers, a natural action will arise when changing the order of the corresponding vectors in a tensor product. The graded vector space thus becomes a braided vector space. The simplest example is that of a vector space V graded by fermion parity. An element of V1‚äóV2 can be mapped to one of V2‚äóV1 by permuting the two tensor indices and adding a phase -1 in the sector where both indices have an odd fermion number. More generally, a complete braiding tensor R_alphabeta^gamma needs to be specified.","category":"page"},{"location":"man/old/#ElementarySpace-methods-1","page":"TensorKit.jl","title":"ElementarySpace methods","text":"","category":"section"},{"location":"man/old/#Composite-spaces-1","page":"TensorKit.jl","title":"Composite spaces","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Composite spaces are built out of elementary vector spaces of a homogeneous type S. The most relevant case is the abstract family TensorSpace{S,N} used to denote certain subspaces in the tensor product space of N vector spaces of type S. These spaces will be used to define rank-N tensors, where the different tensor indices i_j correspond to the elements of a basis in V_j for j=12N . We start with the definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract CompositeSpace{S<:ElementarySpace} <: VectorSpace\nabstract TensorSpace{S<:ElementarySpace,N} <: CompositeSpace{S}","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The homogenity restriction is the only sensible way of defining tensor product spaces, since there is no point in defining i.e. a tensor with a group action on some indices and not on other indices and it is even impossible to define the tensor product space of vector spaces over different fields. It is thus not possible to construct tensor product spaces of e.g. mathbbR^d_1 and mathbbC^d_2 , but it is possible to construct tensor product spaces of mathbbC^d_1 and mathbbC^d_2 , or even the dual of the latter. Therefore, for new vector spaces, it is important that any related vector space (e.g. the dual or conjugated space) with which one wants to construct tensor product spaces are of the same concrete type (e.g. no type parameters to denote dual spaces).","category":"page"},{"location":"man/old/#ProductSpace-1","page":"TensorKit.jl","title":"ProductSpace","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The complete tensor product space is represented by the concrete type ProductSpace{S,N}. This corresponds to the definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"immutable ProductSpace{S<:ElementarySpace,N} <: TensorSpace{S,N}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The ProductSpace of a set of elementary spaces V1, V2, ... of type S can be created as  V1 ‚äó V2 ‚äó .... Product spaces can be iterated over and indexed in order to extract the elementary spaces, or the tensor product of a subset of them. The dual and conjugate spaces are defined by mapping these actions to the respective elementary vector spaces V1, V2, ... For convience, we also define the transpose of a ProductSpace by reversing the factors V1 to VN, and the ctranspose by reversing the conjugated spaces. While there is no such thing as the transpose of a vector space, this definition is convenient because it is compatible with the way (c)transpose is defined for tensors. Finally, the dim of a ProductSpace is given by the product of the dim of its constituents.","category":"page"},{"location":"man/old/#WIP:-InvariantSpace-1","page":"TensorKit.jl","title":"WIP: InvariantSpace","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A InvariantSpace corresponds to the subspace of the tensor product of some UnitaryRepresentationSpaces that fuses to the identity (i.e. total 'charge' zero). In the case of irreducible representations of groups, it corresponds to the invariant subspace, i.e. the subspace of the tensor product that couples to the trivial representation. The different sectors of an InvariantSpace are labelled not only by the set of sectors of the individual elementary spaces (under the constraint that they have a fusion channel to trivial charge), but also by the intermediate fusion sectors. This gives rise to the concept of a fusion tree.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"In order to describe and manipulate the trivial sector in the tensor product of UnitaryRepresentationSpaces, one thus needs to be able to store and manipulate fusion trees using recouplings (F-moves) or braidings (R-moves). So far, this has only been implemented for spaces with Abelian fusion rules and trivial braiding.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"TODO: develop interface to work with fusion trees and braidings\nTODO: implement some non-trivial cases (SU(2) symmetry, fermions, ...)","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"References:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"General theory of anyons and unitary fusion categoies\nGeneral treatment of symmetries in tensors\nU1 symmetric tensors\nSU2 symmetric tensors\nAnyonic tensors 1 , Anyonic tensors 2","category":"page"},{"location":"man/old/#TODO:-Symmetric-and-antisymmetric-vector-spaces-(Fock-space)-1","page":"TensorKit.jl","title":"TODO: Symmetric and antisymmetric vector spaces (Fock space)","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"For the tensor product of N identical copies of a given vector space V, we can also consider the symmetric or antisymmetric subspace of V^otimes N , corresponding to e.g. the N particle boson or fermion Fock space corresponding to a single particle Hilbert Space V. This has of course also other applications and can be extended to tensors with (anti)symmetry in subsets of indices.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensors-1","page":"TensorKit.jl","title":"Tensors","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The most important elements in TensorToolbox.jl are of course tensors. A rank N tensor is interpreted as the element of (a subspace of) the tensor product of some N elementary vector spaces, represented as a TensorSpace{S,N} object V. A tensor needs to store its components as a list of numbers of type T<:Number. The following observations are in order:","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The element type T must not be the same as the field of the vector space, i.e. a tensor in a (tensor product) of ComplexSpaces can have real components, but a tensor in the product space of CartesianSpaces should not have complex entries. However, this is not strictly enforced.\nThe components represent the tensor with respect to a canonical choice of basis in V; so far there is no support to represent different basis choices and the transformations between them. This might change in the future.\nThe number of (independent) components of a tensor is given by dim V. When V is a proper subspace of V1 ‚äó V2 ‚äó ... ‚äó VN, then dim V is not just the product of the dimensions of the elementary spaces and the independent components cannot simply be represent as a N-dimensional array.","category":"page"},{"location":"man/old/#Different-tensor-types-1","page":"TensorKit.jl","title":"Different tensor types","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The only difference between tensors (so far) is how their independent components are stored. All other characteristics are encoded in the type of vector space.","category":"page"},{"location":"man/old/#DenseTensor-1","page":"TensorKit.jl","title":"DenseTensor","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We start the type hierarchy with an abstract type and currently have a single concrete tensor type, DenseTensor, that stores its components using a Vector{T}, corresponding to the following definitions","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"abstract AbstractTensor{S,T,N}\nimmutable DenseTensor{S,T,N,P} <: AbstractTensor{S,T,N}\n    data::Vector{T}\n    space::P\nend","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Here, we should have P<:TensorSpace{S,N}. With the current Julia type system, this cannot be enforced in the type but only in its constructor (which also checks that length(data)=dim(space). This might change with the type system redesign.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"We can then define some useful type aliasses for e.g. the standard tensor living in the full tensor product space","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"typealias Tensor{S,T,N} DenseTensor{S,T,N,ProductSpace{S,N}}\ntypealias CartesianTensor{T,N} Tensor{CartesianSpace,T,N}\ntypealias ComplexTensor{T,N} Tensor{ComplexSpace,T,N}\ntypealias InvariantTensor{S,T,N} DenseTensor{S,T,N,InvariantSpace{S,N}}\ntypealias U1Tensor{T,N} ...","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"and so on.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"A tensor can be created from a set of components as","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"tensor(data, space)","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"where data can be an arbitrary Vector{T}.","category":"page"},{"location":"man/old/#TODO:-DiagonalTensor-1","page":"TensorKit.jl","title":"TODO: DiagonalTensor","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"For the specific case of a rank N=2 tensor in V ‚äó dual(V), it is often useful to have an explicit diagonal representation, e.g. to store the eigenvalues or singular values corresponding to a given tensor factorization (see below).","category":"page"},{"location":"man/old/#Other-tensors-?-1","page":"TensorKit.jl","title":"Other tensors ?","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Should there be sparse tensors?","category":"page"},{"location":"man/old/#Tensor-properties-1","page":"TensorKit.jl","title":"Tensor properties","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The basic tensor methods allow to construct tensors and query their characteristics","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"space(t) returns the vector space of a tensor t.\neltype(t) returns the element type T of the coefficient vector.\nnumind(t)=order(t) returns the number of tensor indices N, i.e. the number of elementary vector spaces in space(t).\nin(t,V) can be used to check if space(t) is a subspace of V.\nvec(t) returns the coefficient vector data which allows to modify the tensor components\nfull(t) returns an Array{T,N} representation of a rank N tensor. Only when space(t) is a ProductSpace is this isomorphic to the vector of coefficients, otherwise zeros or repeated coefficients might appear. Therefore, full(t) does not share data with the tensor and cannot be used to modified its contens.","category":"page"},{"location":"man/old/#Constructing-and-converting-tensors-1","page":"TensorKit.jl","title":"Constructing and converting tensors","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"tensor(data,V) can be used to construct a DenseTensor. Here, data represents an arbitrary Array{T,N}. If the vector space V is provided, the multidimensional characteristics of data are ignored. Only vec(data) is used and the only requirement is that length(data) equals dim(V). If V is absent, then tensor(data) creates a CartesianTensor if T<:Real with V=ProductSpace(map(CartesianSpace,size(data))). If T<:Complex, a ComplexTensor is constructed, even though there it is already ambiguous whether the normal complex Euclidean space or the dual space should be constructed for every index.\nzeros(T,V) creates a tensor in V filled with zero coefficients, which is equivalent to the zero vector. If T is omitted, it is given the default value T=Float64.\nrand(T,V) creates a tensor in V filled with random coefficients. A default value of T=Float64 is asssumed when T is omitted.\nsimilar(t,T,V) constructs an unitialized tensor similar to t, but with element type T and for different space V (of the same type of space(t)).\ncomplex(t) converts t to a tensor with complex-valued coefficients; it does nothing if  eltype(t)<:Complex.\nreal(t) and imag(t) returns a tensor with the real and imaginary parts of the coefficients; this is a basis-dependent operations and refers to the canonical basis with respect to which the coefficients are stored.\nfloat32, float64, complex64 and complex128 can be used to cast the tensor coefficients into a specific format.","category":"page"},{"location":"man/old/#Basic-linear-algebra-methods-1","page":"TensorKit.jl","title":"Basic linear algebra methods","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"The following methods allow to  perform basic linear algebra (corresponding to their interpretation as elements in a vector space):","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"arithmetic: tensors in the same vector space can be added, subtracted en multiplied with scalars. There are also mutating methods such as scale! and axpy!.\nconj(t) conjugates the tensor in the canonical basis. Note that this also maps the tensor to the space conj(V) which is different from V. Therefore, conj! is not an inplace operation but can be used to store the result of conjugating the tensor src in a preallocated tensor dst in conj(V) using conj!(dst,src).\ntranspose(t) implements an isomorphism from V=V1 ‚äó V2 ‚äó ... ‚äó VN to reverse(V) = VN ‚äó ... ‚äó V2 ‚äó V1, i.e. it reverses the order of the indices. For a tensor with N=1, this has no effect. For a tensor with N=2, this corresponds to the most general definition of the transpose of a linear map. A linear map fVto W can be identified with a tensor in W ‚äó dual(V). The transpose of this tensor lives in dual(V) ‚äó W, which can be identified with a linear map from dual(W) to dual(V), in accordance with the aforementioned definition. Only for real Euclidean vector spaces is dual(V) == V and does this correspond to a map from W to V.  For N>2, there is no standard definition of transpose, but reversing all indices corresponds to the convention used in the Penrose graphical notation, where transposing corresponds to mirroring the diagrammatic representation of the tensor. There is again a mutating version transpose!(dst,src) that allows to store the result of transposing src in the preallocated tensor dst.\nctranspose(t) is equivalent to conj(transpose(t)) but performs this operation in a single step. In particular, for N=2, it maps a tensor in W ‚äó dual(V) to a tensor in dual(conj(V)) ‚äó conj(W). For complex Euclidean spaces (where dual(V)=conj(V)) or real Euclidean spaces (where dual(V)=V and conj(V)=V), the conjugate transpose of a tensor in W ‚äó dual(V) is a tensor in V ‚äó dual(W), which can be interpreted as a linear map from W to V, according to the definition of the adjoint map. As before, ctranpose!(dst,src) stores the result in the preallocated destination tensor.\ndot(t1,t2) computers the inner product between two tensors t1 and t2. This is only possible if space(t1)==space(t2) and if this space is the tensor product of elementary vector spaces with an inner product, i.e. S<:InnerProductSpace. However, the interface for specifying general inner products still needs to be developed, and thus so far dot(t1,t2) only works if S<:EuclideanSpace. We choose the canonical basis of euclidean spaces orthonormal, such that dot(t1,t2) = dot(vec(t1),vec(t2)), i.e. the inner product corresponds to the normal scalar product of the coefficient vectors.\nvecnorm(t) computes the norm of tensor t; it is essentially equivalent to sqrt(dot(t,t)) and is therefore subject to the same restrictions (S<:EuclideanSpace) and satisfies vecnorm(t)=norm(vec(t)).","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Currently, conj, transpose and ctranspose allocate new tensors for storing the result. This might change in the future such that they return a simple view over the same data, although this is not entirely trivial for tensors which do not live in a simple ProductSpace{S,N}.","category":"page"},{"location":"man/old/#TODO:-Indexing-1","page":"TensorKit.jl","title":"TODO: Indexing","text":"","category":"section"},{"location":"man/old/#Tensor-operations-1","page":"TensorKit.jl","title":"Tensor operations","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"scalar(t) can be applied to a rank N=0 tensor to construct the single scalar component, since in that case space(t) is an empty tensor product space and thus equivalent to the corresponding number field.","category":"page"},{"location":"man/old/#Tensor-factorizations-1","page":"TensorKit.jl","title":"Tensor factorizations","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensor-Maps-1","page":"TensorKit.jl","title":"Tensor Maps","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"Linear maps between tensor spaces with possible efficient implementation.","category":"page"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Tensor-Networks-1","page":"TensorKit.jl","title":"Tensor Networks","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"","category":"page"},{"location":"man/old/#Bibliography-1","page":"TensorKit.jl","title":"Bibliography","text":"","category":"section"},{"location":"man/old/#","page":"TensorKit.jl","title":"TensorKit.jl","text":"[tung]: Wu-Ki Tung. Group Theory in Physics: Introduction to Symmetry Principles, Group Representations, and Special Functions in Classical and Quantum Physics. World Scientific Publishing Company, 1985.  ","category":"page"}]
}
